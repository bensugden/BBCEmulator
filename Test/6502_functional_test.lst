AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    1
---------------------------------------------------- 6502_functional_test.txt ----------------------------------------------------

6102 lines read, no errors in pass 1.
                        ;
                        ; 6 5 0 2   F U N C T I O N A L   T E S T
                        ;
                        ; Copyright (C) 2012-2015  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test all opcodes of a 6502 emulator using all
                        ; addressing modes with focus on propper setting of the processor status
                        ; register bits.
                        ; 
                        ; version 04-dec-2017
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 from http://www.kingswood-consulting.co.uk/assemblers/
                        ; command line switches: -l -m -s2 -w -h0
                        ;                         |  |  |   |  no page headers in listing
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex
                        ; (code_segment) and enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ; Please note that in early tests some instructions will have to be used before
                        ; they are actually tested!
                        ;
                        ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
                        ; Tests documented behavior of the original NMOS 6502 only! No unofficial
                        ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
                        ; not be tested. Decimal ops will only be tested with valid BCD operands and
                        ; N V Z flags will be ignored.
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   28-jul-2012  1st version distributed for testing
                        ;   29-jul-2012  fixed references to location 0, now #0
                        ;                added license - GPLv3
                        ;   30-jul-2012  added configuration options
                        ;   01-aug-2012  added trap macro to allow user to change error handling
                        ;   01-dec-2012  fixed trap in branch field must be a branch
                        ;   02-mar-2013  fixed PLA flags not tested
                        ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
                        ;                added test sequence check to detect if tests jump their fence
                        ;   23-jul-2013  added RAM integrity check option
                        ;   16-aug-2013  added error report to standard output option
                        ;   13-dec-2014  added binary/decimal opcode table switch test
                        ;   14-dec-2014  improved relative address test
                        ;   23-aug-2015  added option to disable self modifying tests
                        ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
                        ;                added small branch offset pretest
                        ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
                        ;   04-dec-2017  fixed BRK only tested with interrupts enabled
                        ;                added option to skip the remainder of a failing test
                        ;                in report.i65
                        
                        
                        ; C O N F I G U R A T I O N
                        
                        ;ROM_vectors writable (0=no, 1=yes)
                        ;if ROM vectors can not be used interrupts will not be trapped
                        ;as a consequence BRK can not be tested but will be emulated to test RTI
0001 =                  ROM_vectors = 1
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0001 =                  load_data_direct = 1
                        
                        ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
                        ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
                        ;tested if you allow changing the interrupt status (I_flag = 3)
0001 =                  I_flag = 1
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, $50 (80) consecutive Bytes required
                        ;                                add 2 if I_flag = 2
0000 =                  zero_page = 0  
                        
                        ;data_segment memory start address, $6A (106) consecutive Bytes required
0200 =                  data_segment = $200  
                            if (data_segment & $ff) != 0
                                ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
                            endif  
                        
                        ;code_segment memory start address, 13kB of consecutive space required
                        ;                                   add 2.5 kB if I_flag = 2
0400 =                  code_segment = $400  
                        
                        ;self modifying code may be disabled to allow running in ROM
                        ;0=part of the code is self modifying and must reside in RAM
                        ;1=tests disabled: branch range
0000 =                  disable_selfmod = 0
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel, add 3.5 kB)
0000 =                  report = 0
                        
                        ;RAM integrity test option. Checks for undesired RAM writes.
                        ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
                        ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
ffff =                  ram_top = -1
                        
                        ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
                        ;2=disable including decimal flag in processor status
0000 =                  disable_decimal = 0
                        
                                noopt       ;do not take shortcuts
                        
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                                endm
                        trap_ne macro
                                bne *           ;failed not equal (non zero)
                                endm
                        trap_cs macro
                                bcs *           ;failed carry set
                                endm
                        trap_cc macro
                                bcc *           ;failed carry clear
                                endm
                        trap_mi macro
                                bmi *           ;failed minus (bit 7 set)
                                endm
                        trap_pl macro
                                bpl *           ;failed plus (bit 7 clear)
                                endm
                        trap_vs macro
                                bvs *           ;failed overflow set
                                endm
                        trap_vc macro
                                bvc *           ;failed overflow clear
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        trap_cs macro
                                bcc skip\?
                                trap            ;failed carry set
                        skip\?
                                endm
                        trap_cc macro
                                bcs skip\?
                                trap            ;failed carry clear
                        skip\?
                                endm
                        trap_mi macro
                                bpl skip\?
                                trap            ;failed minus (bit 7 set)
                        skip\?
                                endm
                        trap_pl macro
                                bmi skip\?
                                trap            ;failed plus (bit 7 clear)
                        skip\?
                                endm
                        trap_vs macro
                                bvc skip\?
                                trap            ;failed overflow set
                        skip\?
                                endm
                        trap_vc macro
                                bvs skip\?
                                trap            ;failed overflow clear
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
0038 =                  faod    equ fao+decmode     ;+ ignore decimal
003c =                  faid    equ fai+decmode     ;+ ignore decimal
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to allow masking of status bits.
                        ;masking test of decimal bit
                        ;masking of interrupt enable/disable on load and compare
                        ;masking of always on bits after PHP or BRK (unused & break) on compare
                            if disable_decimal < 2
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8i   ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fai)&m8    ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1|fai)       ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    cmp #(\1|fao)&m8i   ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8    ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    eor #\1|fao         ;invert expected flags + always on bits
                                    endm
                                endif
                            else
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faid)&m8   ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1|faid)      ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8   ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #\1|faod        ;invert expected flags + always on bits
                                    endm
                                endif
                            endif
                        
                        ;macros to set (register|memory|zeropage) & status
                        set_stat    macro       ;setting flags in the processor status register
                                    load_flag \1
                                    pha         ;use stack to load status
                                    plp
                                    endm
                        
                        set_a       macro       ;precharging accu & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda #\1     ;precharge accu
                                    plp
                                    endm
                        
                        set_x       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldx #\1     ;precharge index x
                                    plp
                                    endm
                        
                        set_y       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldy #\1     ;precharge index y
                                    plp
                                    endm
                        
                        set_ax      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;precharge accu
                                    plp
                                    endm
                        
                        set_ay      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,y    ;precharge accu
                                    plp
                                    endm
                        
                        set_z       macro       ;precharging indexed zp & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to zeropage
                                    sta zpt
                                    plp
                                    endm
                        
                        set_zx      macro       ;precharging zp,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed zeropage
                                    sta zpt,x
                                    plp
                                    endm
                        
                        set_abs     macro       ;precharging indexed memory & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to memory
                                    sta abst
                                    plp
                                    endm
                        
                        set_absx    macro       ;precharging abs,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed memory
                                    sta abst,x
                                    plp
                                    endm
                        
                        ;macros to test (register|memory|zeropage) & status & (mask)
                        tst_stat    macro       ;testing flags in the processor status register
                                    php         ;save status
                                    pla         ;use stack to retrieve status
                                    pha
                                    cmp_flag \1
                                    trap_ne
                                    plp         ;restore status
                                    endm
                                    
                        tst_a       macro       ;testing result in accu & flags
                                    php         ;save flags
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_x       macro       ;testing result in x index & flags
                                    php         ;save flags
                                    cpx #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_y       macro       ;testing result in y index & flags
                                    php         ;save flags
                                    cpy #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_ax      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne     ;
                                    endm
                        
                        tst_ay      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,y    ;test result
                                    trap_ne     ;
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,y    ;test flags
                                    trap_ne
                                    endm
                                
                        tst_z       macro       ;indexed testing result in zp & flags
                                    php         ;save flags
                                    lda zpt
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_zx      macro       ;testing result in zp,x & flags
                                    php         ;save flags
                                    lda zpt,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_abs     macro       ;indexed testing result in memory & flags
                                    php         ;save flags
                                    lda abst
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_absx    macro       ;testing result in abs,x & flags
                                    php         ;save flags
                                    lda abst,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                                    
                        ; RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                        ;   uses zpt word as indirect pointer, zpt+2 word as checksum
                                if ram_top > -1
                        check_ram   macro 
                                    cld
                                    lda #0
                                    sta zpt         ;set low byte of indirect pointer
                                    sta zpt+3       ;checksum high byte
                                  if disable_selfmod = 0
                                    sta range_adr   ;reset self modifying code
                                  endif
                                    clc
                                    ldx #zp_bss-zero_page ;zeropage - write test area
                        ccs3\?      adc zero_page,x
                                    bcc ccs2\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs2\?      inx
                                    bne ccs3\?
                                    ldx #hi(abs1)   ;set high byte of indirect pointer
                                    stx zpt+1
                                    ldy #lo(abs1)   ;data after write & execute test area
                        ccs5\?      adc (zpt),y
                                    bcc ccs4\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs4\?      iny
                                    bne ccs5\?
                                    inx             ;advance RAM high address
                                    stx zpt+1
                                    cpx #ram_top
                                    bne ccs5\?
                                    sta zpt+2       ;checksum low is
                                    cmp ram_chksm   ;checksum low expected
                                    trap_ne         ;checksum mismatch
                                    lda zpt+3       ;checksum high is
                                    cmp ram_chksm+1 ;checksum high expected
                                    trap_ne         ;checksum mismatch
                                    endm            
                                else
                        check_ram   macro
                                    ;RAM check disabled - RAM size not set
                                    endm
                                endif
                        
                        next_test   macro           ;make sure, tests don't jump the fence
                                    lda test_case   ;previous test
                                    cmp #test_num
                                    trap_ne         ;test is out of sequence
                        test_num = test_num + 1
                                    lda #test_num   ;*** next tests' number
                                    sta test_case
                                    ;check_ram       ;uncomment to find altered RAM after each test
                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
0000 =                          org zero_page
                        ;break test interrupt save
0000 : 00               irq_a   ds  1               ;a register
0001 : 00               irq_x   ds  1               ;x register
                            if I_flag = 2
                        ;masking for I bit in status
                        flag_I_on   ds  1           ;or mask to load flags   
                        flag_I_off  ds  1           ;and mask to load flags
                            endif
0002 :                  zpt                         ;5 bytes store/modify test area
                        ;add/subtract operand generation and result/flag prediction
0002 : 00               adfc    ds  1               ;carry flag before op
0003 : 00               ad1     ds  1               ;operand 1 - accumulator
0004 : 00               ad2     ds  1               ;operand 2 - memory / immediate
0005 : 00               adrl    ds  1               ;expected result bits 0-7
0006 : 00               adrh    ds  1               ;expected result bit 8 (carry)
0007 : 00               adrf    ds  1               ;expected flags NV0000ZC (only binary mode)
0008 : 00               sb2     ds  1               ;operand 2 complemented for subtract
0009 :                  zp_bss
0009 : c3824100         zp1     db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
000d : 7f               zp7f    db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
000e : 001f7180         zpOR    db  0,$1f,$71,$80   ;test pattern for OR
0012 : 0fff7f80         zpAN    db  $0f,$ff,$7f,$80 ;test pattern for AND
0016 : ff0f8f8f         zpEO    db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
001a : 1702             ind1    dw  abs1            ;indirect pointer to pattern in absolute memory
001c : 1802                     dw  abs1+1
001e : 1902                     dw  abs1+2
0020 : 1a02                     dw  abs1+3
0022 : 1b02                     dw  abs7f
0024 : 1f01             inw1    dw  abs1-$f8        ;indirect pointer for wrap-test pattern
0026 : 0302             indt    dw  abst            ;indirect pointer to store area in absolute memory
0028 : 0402                     dw  abst+1
002a : 0502                     dw  abst+2
002c : 0602                     dw  abst+3
002e : 0b01             inwt    dw  abst-$f8        ;indirect pointer for wrap-test store
0030 : 4e02             indAN   dw  absAN           ;indirect pointer to AND pattern in absolute memory
0032 : 4f02                     dw  absAN+1
0034 : 5002                     dw  absAN+2
0036 : 5102                     dw  absAN+3
0038 : 5202             indEO   dw  absEO           ;indirect pointer to EOR pattern in absolute memory
003a : 5302                     dw  absEO+1
003c : 5402                     dw  absEO+2
003e : 5502                     dw  absEO+3
0040 : 4a02             indOR   dw  absOR           ;indirect pointer to OR pattern in absolute memory
0042 : 4b02                     dw  absOR+1
0044 : 4c02                     dw  absOR+2
0046 : 4d02                     dw  absOR+3
                        ;add/subtract indirect pointers
0048 : 0302             adi2    dw  ada2            ;indirect pointer to operand 2 in absolute memory
004a : 0402             sbi2    dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
004c : 0401             adiy2   dw  ada2-$ff        ;with offset for indirect indexed
004e : 0501             sbiy2   dw  sba2-$ff
0050 :                  zp_bss_end
                           
0200 =                          org data_segment
0200 : 00               test_case   ds  1           ;current test number
0201 : 0000             ram_chksm   ds  2           ;checksum for RAM integrity test
                        ;add/subtract operand copy - abs tests write area
0203 :                  abst                        ;5 bytes store/modify test area
0203 : 00               ada2    ds  1               ;operand 2
0204 : 00               sba2    ds  1               ;operand 2 complemented for subtract
0205 : 000000                   ds  3               ;fill remaining bytes
0208 :                  data_bss
                            if load_data_direct = 1
0208 : 2900             ex_andi and #0              ;execute immediate opcodes
020a : 60                       rts
020b : 4900             ex_eori eor #0              ;execute immediate opcodes
020d : 60                       rts
020e : 0900             ex_orai ora #0              ;execute immediate opcodes
0210 : 60                       rts
0211 : 6900             ex_adci adc #0              ;execute immediate opcodes
0213 : 60                       rts
0214 : e900             ex_sbci sbc #0              ;execute immediate opcodes
0216 : 60                       rts
                            else
                        ex_andi ds  3
                        ex_eori ds  3
                        ex_orai ds  3
                        ex_adci ds  3
                        ex_sbci ds  3
                            endif
0217 : c3824100         abs1    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
021b : 7f               abs7f   db  $7f             ;test pattern for compare
                        ;loads
021c : 80800002         fLDx    db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
0220 :                  rASL                        ;expected result ASL & ROL -carry  
0220 : 86048200         rROL    db  $86,$04,$82,0   ; "
0224 : 87058301         rROLc   db  $87,$05,$83,1   ;expected result ROL +carry
0228 :                  rLSR                        ;expected result LSR & ROR -carry
0228 : 61412000         rROR    db  $61,$41,$20,0   ; "
022c : e1c1a080         rRORc   db  $e1,$c1,$a0,$80 ;expected result ROR +carry
0230 :                  fASL                        ;expected flags for shifts
0230 : 81018002         fROL    db  fnc,fc,fn,fz    ;no carry in
0234 : 81018000         fROLc   db  fnc,fc,fn,0     ;carry in
0238 :                  fLSR
0238 : 01000102         fROR    db  fc,0,fc,fz      ;no carry in
023c : 81808180         fRORc   db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
0240 : 7f80ff0001       rINC    db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
0245 : 0080800200       fINC    db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
024a : 001f7180         absOR   db  0,$1f,$71,$80   ;test pattern for OR
024e : 0fff7f80         absAN   db  $0f,$ff,$7f,$80 ;test pattern for AND
0252 : ff0f8f8f         absEO   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
0256 : 00f11f00         absORa  db  0,$f1,$1f,0     ;test pattern for OR
025a : f0ffffff         absANa  db  $f0,$ff,$ff,$ff ;test pattern for AND
025e : fff0f00f         absEOa  db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
0262 : 00ff7f80         absrlo  db  0,$ff,$7f,$80
0266 : 02800080         absflo  db  fz,fn,0,fn
026a :                  data_bss_end
                        
                        
                                code
0400 =                          org code_segment
0400 : d8               start   cld
0401 : a2ff                     ldx #$ff
0403 : 9a                       txs
0404 : a900                     lda #0          ;*** test 0 = initialize
0406 : 8d0002                   sta test_case
0000 =                  test_num = 0
                        
                        ;stop interrupts before initializing BSS
                            if I_flag = 1
0409 : 78                       sei
                            endif
                            
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                            
                        ;pretest small branch offset
040a : a205                     ldx #5
040c : 4c3404                   jmp psb_test
040f :                  psb_bwok
040f : a005                     ldy #5
0411 : d008                     bne psb_forw
                                trap        ;branch should be taken
0413 : 4c1304          >        jmp *           ;failed anyway
                        
0416 : 88                       dey         ;forward landing zone
0417 : 88                       dey
0418 : 88                       dey
0419 : 88                       dey
041a : 88                       dey
041b :                  psb_forw
041b : 88                       dey
041c : 88                       dey
041d : 88                       dey
041e : 88                       dey
041f : 88                       dey
0420 : f017                     beq psb_fwok
                                trap        ;forward offset
0422 : 4c2204          >        jmp *           ;failed anyway
                        
                        
0425 : ca                       dex         ;backward landing zone
0426 : ca                       dex
0427 : ca                       dex
0428 : ca                       dex
0429 : ca                       dex
042a :                  psb_back
042a : ca                       dex
042b : ca                       dex
042c : ca                       dex
042d : ca                       dex
042e : ca                       dex
042f : f0de                     beq psb_bwok
                                trap        ;backward offset
0431 : 4c3104          >        jmp *           ;failed anyway
                        
0434 :                  psb_test
0434 : d0f4                     bne psb_back
                                trap        ;branch should be taken
0436 : 4c3604          >        jmp *           ;failed anyway
                        
0439 :                  psb_fwok
                                
                        ;initialize BSS segment
                            if load_data_direct != 1
                                ldx #zp_end-zp_init-1
                        ld_zp   lda zp_init,x
                                sta zp_bss,x
                                dex
                                bpl ld_zp
                                ldx #data_end-data_init-1
                        ld_data lda data_init,x
                                sta data_bss,x
                                dex
                                bpl ld_data
                              if ROM_vectors = 1
                                ldx #5
                        ld_vect lda vec_init,x
                                sta vec_bss,x
                                dex
                                bpl ld_vect
                              endif
                            endif
                        
                        ;retain status of interrupt flag
                            if I_flag = 2
                                php
                                pla
                                and #4          ;isolate flag
                                sta flag_I_on   ;or mask
                                eor #lo(~4)     ;reverse
                                sta flag_I_off  ;and mask
                            endif
                                
                        ;generate checksum for RAM integrity test
                            if ram_top > -1
                                lda #0 
                                sta zpt         ;set low byte of indirect pointer
                                sta ram_chksm+1 ;checksum high byte
                              if disable_selfmod = 0
                                sta range_adr   ;reset self modifying code
                              endif
                                clc
                                ldx #zp_bss-zero_page ;zeropage - write test area
                        gcs3    adc zero_page,x
                                bcc gcs2
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs2    inx
                                bne gcs3
                                ldx #hi(abs1)   ;set high byte of indirect pointer
                                stx zpt+1
                                ldy #lo(abs1)   ;data after write & execute test area
                        gcs5    adc (zpt),y
                                bcc gcs4
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs4    iny
                                bne gcs5
                                inx             ;advance RAM high address
                                stx zpt+1
                                cpx #ram_top
                                bne gcs5
                                sta ram_chksm   ;checksum complete
                            endif
                                next_test            
0439 : ad0002          >            lda test_case   ;previous test
043c : c900            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
043e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0001 =                 >test_num = test_num + 1
0440 : a901            >            lda #test_num   ;*** next tests' number
0442 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                            if disable_selfmod = 0
                        ;testing relative addressing with BEQ
0445 : a0fe                     ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
0447 :                  range_loop
0447 : 88                       dey             ;next relative address
0448 : 98                       tya
0449 : aa                       tax             ;precharge count to end of loop
044a : 1008                     bpl range_fw    ;calculate relative address
044c : 18                       clc             ;avoid branch self or to relative address of branch
044d : 6902                     adc #2
044f : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
0450 : ea                       nop
0451 : ea                       nop
0452 : ea                       nop
0453 : ea                       nop
0454 :                  range_fw
0454 : ea                       nop
0455 : ea                       nop
0456 : ea                       nop
0457 : ea                       nop
0458 : ea                       nop
0459 : 497f                     eor #$7f        ;complement except sign
045b : 8de704                   sta range_adr   ;load into test target
045e : a900                     lda #0          ;should set zero flag in status register
0460 : 4ce604                   jmp range_op
                                
0463 : ca                       dex             ; offset landing zone - backward branch too far
0464 : ca                       dex
0465 : ca                       dex
0466 : ca                       dex
0467 : ca                       dex
                                ;relative address target field with branch under test in the middle
0468 : ca                       dex             ;-128 - max backward
0469 : ca                       dex
046a : ca                       dex
046b : ca                       dex
046c : ca                       dex
046d : ca                       dex
046e : ca                       dex
046f : ca                       dex
0470 : ca                       dex             ;-120
0471 : ca                       dex
0472 : ca                       dex
0473 : ca                       dex
0474 : ca                       dex
0475 : ca                       dex
0476 : ca                       dex
0477 : ca                       dex
0478 : ca                       dex
0479 : ca                       dex
047a : ca                       dex             ;-110
047b : ca                       dex
047c : ca                       dex
047d : ca                       dex
047e : ca                       dex
047f : ca                       dex
0480 : ca                       dex
0481 : ca                       dex
0482 : ca                       dex
0483 : ca                       dex
0484 : ca                       dex             ;-100
0485 : ca                       dex
0486 : ca                       dex
0487 : ca                       dex
0488 : ca                       dex
0489 : ca                       dex
048a : ca                       dex
048b : ca                       dex
048c : ca                       dex
048d : ca                       dex
048e : ca                       dex             ;-90
048f : ca                       dex
0490 : ca                       dex
0491 : ca                       dex
0492 : ca                       dex
0493 : ca                       dex
0494 : ca                       dex
0495 : ca                       dex
0496 : ca                       dex
0497 : ca                       dex
0498 : ca                       dex             ;-80
0499 : ca                       dex
049a : ca                       dex
049b : ca                       dex
049c : ca                       dex
049d : ca                       dex
049e : ca                       dex
049f : ca                       dex
04a0 : ca                       dex
04a1 : ca                       dex
04a2 : ca                       dex             ;-70
04a3 : ca                       dex
04a4 : ca                       dex
04a5 : ca                       dex
04a6 : ca                       dex
04a7 : ca                       dex
04a8 : ca                       dex
04a9 : ca                       dex
04aa : ca                       dex
04ab : ca                       dex
04ac : ca                       dex             ;-60
04ad : ca                       dex
04ae : ca                       dex
04af : ca                       dex
04b0 : ca                       dex
04b1 : ca                       dex
04b2 : ca                       dex
04b3 : ca                       dex
04b4 : ca                       dex
04b5 : ca                       dex
04b6 : ca                       dex             ;-50
04b7 : ca                       dex
04b8 : ca                       dex
04b9 : ca                       dex
04ba : ca                       dex
04bb : ca                       dex
04bc : ca                       dex
04bd : ca                       dex
04be : ca                       dex
04bf : ca                       dex
04c0 : ca                       dex             ;-40
04c1 : ca                       dex
04c2 : ca                       dex
04c3 : ca                       dex
04c4 : ca                       dex
04c5 : ca                       dex
04c6 : ca                       dex
04c7 : ca                       dex
04c8 : ca                       dex
04c9 : ca                       dex
04ca : ca                       dex             ;-30
04cb : ca                       dex
04cc : ca                       dex
04cd : ca                       dex
04ce : ca                       dex
04cf : ca                       dex
04d0 : ca                       dex
04d1 : ca                       dex
04d2 : ca                       dex
04d3 : ca                       dex
04d4 : ca                       dex             ;-20
04d5 : ca                       dex
04d6 : ca                       dex
04d7 : ca                       dex
04d8 : ca                       dex
04d9 : ca                       dex
04da : ca                       dex
04db : ca                       dex
04dc : ca                       dex
04dd : ca                       dex
04de : ca                       dex             ;-10
04df : ca                       dex
04e0 : ca                       dex
04e1 : ca                       dex
04e2 : ca                       dex
04e3 : ca                       dex
04e4 : ca                       dex
04e5 : ca                       dex             ;-3
04e6 :                  range_op                ;test target with zero flag=0, z=1 if previous dex
04e7 =                  range_adr   = *+1       ;modifiable relative address
04e6 : f03e                     beq *+64        ;+64 if called without modification
04e8 : ca                       dex             ;+0
04e9 : ca                       dex
04ea : ca                       dex
04eb : ca                       dex
04ec : ca                       dex
04ed : ca                       dex
04ee : ca                       dex
04ef : ca                       dex
04f0 : ca                       dex
04f1 : ca                       dex
04f2 : ca                       dex             ;+10
04f3 : ca                       dex
04f4 : ca                       dex
04f5 : ca                       dex
04f6 : ca                       dex
04f7 : ca                       dex
04f8 : ca                       dex
04f9 : ca                       dex
04fa : ca                       dex
04fb : ca                       dex
04fc : ca                       dex             ;+20
04fd : ca                       dex
04fe : ca                       dex
04ff : ca                       dex
0500 : ca                       dex
0501 : ca                       dex
0502 : ca                       dex
0503 : ca                       dex
0504 : ca                       dex
0505 : ca                       dex
0506 : ca                       dex             ;+30
0507 : ca                       dex
0508 : ca                       dex
0509 : ca                       dex
050a : ca                       dex
050b : ca                       dex
050c : ca                       dex
050d : ca                       dex
050e : ca                       dex
050f : ca                       dex
0510 : ca                       dex             ;+40
0511 : ca                       dex
0512 : ca                       dex
0513 : ca                       dex
0514 : ca                       dex
0515 : ca                       dex
0516 : ca                       dex
0517 : ca                       dex
0518 : ca                       dex
0519 : ca                       dex
051a : ca                       dex             ;+50
051b : ca                       dex
051c : ca                       dex
051d : ca                       dex
051e : ca                       dex
051f : ca                       dex
0520 : ca                       dex
0521 : ca                       dex
0522 : ca                       dex
0523 : ca                       dex
0524 : ca                       dex             ;+60
0525 : ca                       dex
0526 : ca                       dex
0527 : ca                       dex
0528 : ca                       dex
0529 : ca                       dex
052a : ca                       dex
052b : ca                       dex
052c : ca                       dex
052d : ca                       dex
052e : ca                       dex             ;+70
052f : ca                       dex
0530 : ca                       dex
0531 : ca                       dex
0532 : ca                       dex
0533 : ca                       dex
0534 : ca                       dex
0535 : ca                       dex
0536 : ca                       dex
0537 : ca                       dex
0538 : ca                       dex             ;+80
0539 : ca                       dex
053a : ca                       dex
053b : ca                       dex
053c : ca                       dex
053d : ca                       dex
053e : ca                       dex
053f : ca                       dex
0540 : ca                       dex
0541 : ca                       dex
0542 : ca                       dex             ;+90
0543 : ca                       dex
0544 : ca                       dex
0545 : ca                       dex
0546 : ca                       dex
0547 : ca                       dex
0548 : ca                       dex
0549 : ca                       dex
054a : ca                       dex
054b : ca                       dex
054c : ca                       dex             ;+100
054d : ca                       dex
054e : ca                       dex
054f : ca                       dex
0550 : ca                       dex
0551 : ca                       dex
0552 : ca                       dex
0553 : ca                       dex
0554 : ca                       dex
0555 : ca                       dex
0556 : ca                       dex             ;+110
0557 : ca                       dex
0558 : ca                       dex
0559 : ca                       dex
055a : ca                       dex
055b : ca                       dex
055c : ca                       dex
055d : ca                       dex
055e : ca                       dex
055f : ca                       dex
0560 : ca                       dex             ;+120
0561 : ca                       dex
0562 : ca                       dex
0563 : ca                       dex
0564 : ca                       dex
0565 : ca                       dex
0566 : ca                       dex
0567 : ea                       nop             ;offset landing zone - forward branch too far
0568 : ea                       nop
0569 : ea                       nop
056a : ea                       nop
056b : ea                       nop
056c : f008                     beq range_ok    ;+127 - max forward
                                trap            ; bad range
056e : 4c6e05          >        jmp *           ;failed anyway
                        
0571 : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
0572 : ea                       nop
0573 : ea                       nop
0574 : ea                       nop
0575 : ea                       nop
0576 :                  range_ok
0576 : ea                       nop
0577 : ea                       nop
0578 : ea                       nop
0579 : ea                       nop
057a : ea                       nop
057b : c000                     cpy #0
057d : f003                     beq range_end   
057f : 4c4704                   jmp range_loop
0582 :                  range_end               ;range test successful
                            endif
                                next_test
0582 : ad0002          >            lda test_case   ;previous test
0585 : c901            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0587 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0002 =                 >test_num = test_num + 1
0589 : a902            >            lda #test_num   ;*** next tests' number
058b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;partial test BNE & CMP, CPX, CPY immediate
058e : c001                     cpy #1          ;testing BNE true
0590 : d003                     bne test_bne
                                trap 
0592 : 4c9205          >        jmp *           ;failed anyway
                        
0595 :                  test_bne
0595 : a900                     lda #0 
0597 : c900                     cmp #0          ;test compare immediate 
                                trap_ne
0599 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
059b : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
059d : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
059f : c901                     cmp #1
                                trap_eq 
05a1 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05a3 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05a5 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
05a7 : aa                       tax 
05a8 : e000                     cpx #0          ;test compare x immediate
                                trap_ne
05aa : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
05ac : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
05ae : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
05b0 : e001                     cpx #1
                                trap_eq 
05b2 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05b4 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05b6 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
05b8 : a8                       tay 
05b9 : c000                     cpy #0          ;test compare y immediate
                                trap_ne
05bb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
05bd : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
05bf : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
05c1 : c001                     cpy #1
                                trap_eq 
05c3 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05c5 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05c7 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                next_test
05c9 : ad0002          >            lda test_case   ;previous test
05cc : c902            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
05ce : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0003 =                 >test_num = test_num + 1
05d0 : a903            >            lda #test_num   ;*** next tests' number
05d2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ;testing stack operations PHA PHP PLA PLP
                                    
05d5 : a2ff                     ldx #$ff        ;initialize stack
05d7 : 9a                       txs
05d8 : a955                     lda #$55
05da : 48                       pha
05db : a9aa                     lda #$aa
05dd : 48                       pha
05de : cdfe01                   cmp $1fe        ;on stack ?
                                trap_ne
05e1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05e3 : ba                       tsx
05e4 : 8a                       txa             ;overwrite accu
05e5 : c9fd                     cmp #$fd        ;sp decremented?
                                trap_ne
05e7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05e9 : 68                       pla
05ea : c9aa                     cmp #$aa        ;successful retreived from stack?
                                trap_ne
05ec : d0fe            >        bne *           ;failed not equal (non zero)
                        
05ee : 68                       pla
05ef : c955                     cmp #$55
                                trap_ne
05f1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05f3 : cdff01                   cmp $1ff        ;remains on stack?
                                trap_ne
05f6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05f8 : ba                       tsx
05f9 : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
05fb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
05fd : ad0002          >            lda test_case   ;previous test
0600 : c903            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0602 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0004 =                 >test_num = test_num + 1
0604 : a904            >            lda #test_num   ;*** next tests' number
0606 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
                                set_stat $ff    ;all on
                       >            load_flag $ff    
0609 : a9ff            >            lda #$ff    |intdis      ;force disable interrupts
                       >
060b : 48              >            pha         ;use stack to load status
060c : 28              >            plp
                        
060d : 101a                     bpl nbr1        ;branches should not be taken
060f : 501b                     bvc nbr2
0611 : 901c                     bcc nbr3
0613 : d01d                     bne nbr4
0615 : 3003                     bmi br1         ;branches should be taken
                                trap 
0617 : 4c1706          >        jmp *           ;failed anyway
                        
061a : 7003             br1     bvs br2
                                trap 
061c : 4c1c06          >        jmp *           ;failed anyway
                        
061f : b003             br2     bcs br3
                                trap 
0621 : 4c2106          >        jmp *           ;failed anyway
                        
0624 : f00f             br3     beq br4
                                trap 
0626 : 4c2606          >        jmp *           ;failed anyway
                        
0629 :                  nbr1
                                trap            ;previous bpl taken 
0629 : 4c2906          >        jmp *           ;failed anyway
                        
062c :                  nbr2
                                trap            ;previous bvc taken
062c : 4c2c06          >        jmp *           ;failed anyway
                        
062f :                  nbr3
                                trap            ;previous bcc taken
062f : 4c2f06          >        jmp *           ;failed anyway
                        
0632 :                  nbr4
                                trap            ;previous bne taken
0632 : 4c3206          >        jmp *           ;failed anyway
                        
0635 : 08               br4     php
0636 : ba                       tsx
0637 : e0fe                     cpx #$fe        ;sp after php?
                                trap_ne
0639 : d0fe            >        bne *           ;failed not equal (non zero)
                        
063b : 68                       pla
                                cmp_flag $ff    ;returned all flags on?
063c : c9ff            >            cmp #($ff    |fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
063e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0640 : ba                       tsx
0641 : e0ff                     cpx #$ff        ;sp after php?
                                trap_ne
0643 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0      ;all off
                       >            load_flag 0      
0645 : a904            >            lda #0      |intdis      ;force disable interrupts
                       >
0647 : 48              >            pha         ;use stack to load status
0648 : 28              >            plp
                        
0649 : 301a                     bmi nbr11       ;branches should not be taken
064b : 701b                     bvs nbr12
064d : b01c                     bcs nbr13
064f : f01d                     beq nbr14
0651 : 1003                     bpl br11        ;branches should be taken
                                trap 
0653 : 4c5306          >        jmp *           ;failed anyway
                        
0656 : 5003             br11    bvc br12
                                trap 
0658 : 4c5806          >        jmp *           ;failed anyway
                        
065b : 9003             br12    bcc br13
                                trap 
065d : 4c5d06          >        jmp *           ;failed anyway
                        
0660 : d00f             br13    bne br14
                                trap 
0662 : 4c6206          >        jmp *           ;failed anyway
                        
0665 :                  nbr11
                                trap            ;previous bmi taken 
0665 : 4c6506          >        jmp *           ;failed anyway
                        
0668 :                  nbr12
                                trap            ;previous bvs taken 
0668 : 4c6806          >        jmp *           ;failed anyway
                        
066b :                  nbr13
                                trap            ;previous bcs taken 
066b : 4c6b06          >        jmp *           ;failed anyway
                        
066e :                  nbr14
                                trap            ;previous beq taken 
066e : 4c6e06          >        jmp *           ;failed anyway
                        
0671 : 08               br14    php
0672 : 68                       pla
                                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
0673 : c934            >            cmp #(0      |fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
0675 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                ;crosscheck flags
                                set_stat zero
                       >            load_flag zero
0677 : a906            >            lda #zero|intdis      ;force disable interrupts
                       >
0679 : 48              >            pha         ;use stack to load status
067a : 28              >            plp
                        
067b : d002                     bne brzs1
067d : f003                     beq brzs2
067f :                  brzs1
                                trap            ;branch zero/non zero
067f : 4c7f06          >        jmp *           ;failed anyway
                        
0682 : b002             brzs2   bcs brzs3
0684 : 9003                     bcc brzs4
0686 :                  brzs3
                                trap            ;branch carry/no carry
0686 : 4c8606          >        jmp *           ;failed anyway
                        
0689 : 3002             brzs4   bmi brzs5
068b : 1003                     bpl brzs6
068d :                  brzs5
                                trap            ;branch minus/plus
068d : 4c8d06          >        jmp *           ;failed anyway
                        
0690 : 7002             brzs6   bvs brzs7
0692 : 5003                     bvc brzs8
0694 :                  brzs7
                                trap            ;branch overflow/no overflow
0694 : 4c9406          >        jmp *           ;failed anyway
                        
0697 :                  brzs8
                                set_stat carry
                       >            load_flag carry
0697 : a905            >            lda #carry|intdis      ;force disable interrupts
                       >
0699 : 48              >            pha         ;use stack to load status
069a : 28              >            plp
                        
069b : f002                     beq brcs1
069d : d003                     bne brcs2
069f :                  brcs1
                                trap            ;branch zero/non zero
069f : 4c9f06          >        jmp *           ;failed anyway
                        
06a2 : 9002             brcs2   bcc brcs3
06a4 : b003                     bcs brcs4
06a6 :                  brcs3
                                trap            ;branch carry/no carry
06a6 : 4ca606          >        jmp *           ;failed anyway
                        
06a9 : 3002             brcs4   bmi brcs5
06ab : 1003                     bpl brcs6
06ad :                  brcs5
                                trap            ;branch minus/plus
06ad : 4cad06          >        jmp *           ;failed anyway
                        
06b0 : 7002             brcs6   bvs brcs7
06b2 : 5003                     bvc brcs8
06b4 :                  brcs7
                                trap            ;branch overflow/no overflow
06b4 : 4cb406          >        jmp *           ;failed anyway
                        
                        
06b7 :                  brcs8
                                set_stat minus
                       >            load_flag minus
06b7 : a984            >            lda #minus|intdis      ;force disable interrupts
                       >
06b9 : 48              >            pha         ;use stack to load status
06ba : 28              >            plp
                        
06bb : f002                     beq brmi1
06bd : d003                     bne brmi2
06bf :                  brmi1
                                trap            ;branch zero/non zero
06bf : 4cbf06          >        jmp *           ;failed anyway
                        
06c2 : b002             brmi2   bcs brmi3
06c4 : 9003                     bcc brmi4
06c6 :                  brmi3
                                trap            ;branch carry/no carry
06c6 : 4cc606          >        jmp *           ;failed anyway
                        
06c9 : 1002             brmi4   bpl brmi5
06cb : 3003                     bmi brmi6
06cd :                  brmi5
                                trap            ;branch minus/plus
06cd : 4ccd06          >        jmp *           ;failed anyway
                        
06d0 : 7002             brmi6   bvs brmi7
06d2 : 5003                     bvc brmi8
06d4 :                  brmi7
                                trap            ;branch overflow/no overflow
06d4 : 4cd406          >        jmp *           ;failed anyway
                        
06d7 :                  brmi8
                                set_stat overfl
                       >            load_flag overfl
06d7 : a944            >            lda #overfl|intdis      ;force disable interrupts
                       >
06d9 : 48              >            pha         ;use stack to load status
06da : 28              >            plp
                        
06db : f002                     beq brvs1
06dd : d003                     bne brvs2
06df :                  brvs1
                                trap            ;branch zero/non zero
06df : 4cdf06          >        jmp *           ;failed anyway
                        
06e2 : b002             brvs2   bcs brvs3
06e4 : 9003                     bcc brvs4
06e6 :                  brvs3
                                trap            ;branch carry/no carry
06e6 : 4ce606          >        jmp *           ;failed anyway
                        
06e9 : 3002             brvs4   bmi brvs5
06eb : 1003                     bpl brvs6
06ed :                  brvs5
                                trap            ;branch minus/plus
06ed : 4ced06          >        jmp *           ;failed anyway
                        
06f0 : 5002             brvs6   bvc brvs7
06f2 : 7003                     bvs brvs8
06f4 :                  brvs7
                                trap            ;branch overflow/no overflow
06f4 : 4cf406          >        jmp *           ;failed anyway
                        
06f7 :                  brvs8
                                set_stat $ff-zero
                       >            load_flag $ff-zero
06f7 : a9fd            >            lda #$ff-zero|intdis      ;force disable interrupts
                       >
06f9 : 48              >            pha         ;use stack to load status
06fa : 28              >            plp
                        
06fb : f002                     beq brzc1
06fd : d003                     bne brzc2
06ff :                  brzc1
                                trap            ;branch zero/non zero
06ff : 4cff06          >        jmp *           ;failed anyway
                        
0702 : 9002             brzc2   bcc brzc3
0704 : b003                     bcs brzc4
0706 :                  brzc3
                                trap            ;branch carry/no carry
0706 : 4c0607          >        jmp *           ;failed anyway
                        
0709 : 1002             brzc4   bpl brzc5
070b : 3003                     bmi brzc6
070d :                  brzc5
                                trap            ;branch minus/plus
070d : 4c0d07          >        jmp *           ;failed anyway
                        
0710 : 5002             brzc6   bvc brzc7
0712 : 7003                     bvs brzc8
0714 :                  brzc7
                                trap            ;branch overflow/no overflow
0714 : 4c1407          >        jmp *           ;failed anyway
                        
0717 :                  brzc8
                                set_stat $ff-carry
                       >            load_flag $ff-carry
0717 : a9fe            >            lda #$ff-carry|intdis      ;force disable interrupts
                       >
0719 : 48              >            pha         ;use stack to load status
071a : 28              >            plp
                        
071b : d002                     bne brcc1
071d : f003                     beq brcc2
071f :                  brcc1
                                trap            ;branch zero/non zero
071f : 4c1f07          >        jmp *           ;failed anyway
                        
0722 : b002             brcc2   bcs brcc3
0724 : 9003                     bcc brcc4
0726 :                  brcc3
                                trap            ;branch carry/no carry
0726 : 4c2607          >        jmp *           ;failed anyway
                        
0729 : 1002             brcc4   bpl brcc5
072b : 3003                     bmi brcc6
072d :                  brcc5
                                trap            ;branch minus/plus
072d : 4c2d07          >        jmp *           ;failed anyway
                        
0730 : 5002             brcc6   bvc brcc7
0732 : 7003                     bvs brcc8
0734 :                  brcc7
                                trap            ;branch overflow/no overflow
0734 : 4c3407          >        jmp *           ;failed anyway
                        
0737 :                  brcc8
                                set_stat $ff-minus
                       >            load_flag $ff-minus
0737 : a97f            >            lda #$ff-minus|intdis      ;force disable interrupts
                       >
0739 : 48              >            pha         ;use stack to load status
073a : 28              >            plp
                        
073b : d002                     bne brpl1
073d : f003                     beq brpl2
073f :                  brpl1
                                trap            ;branch zero/non zero
073f : 4c3f07          >        jmp *           ;failed anyway
                        
0742 : 9002             brpl2   bcc brpl3
0744 : b003                     bcs brpl4
0746 :                  brpl3
                                trap            ;branch carry/no carry
0746 : 4c4607          >        jmp *           ;failed anyway
                        
0749 : 3002             brpl4   bmi brpl5
074b : 1003                     bpl brpl6
074d :                  brpl5
                                trap            ;branch minus/plus
074d : 4c4d07          >        jmp *           ;failed anyway
                        
0750 : 5002             brpl6   bvc brpl7
0752 : 7003                     bvs brpl8
0754 :                  brpl7
                                trap            ;branch overflow/no overflow
0754 : 4c5407          >        jmp *           ;failed anyway
                        
0757 :                  brpl8
                                set_stat $ff-overfl
                       >            load_flag $ff-overfl
0757 : a9bf            >            lda #$ff-overfl|intdis      ;force disable interrupts
                       >
0759 : 48              >            pha         ;use stack to load status
075a : 28              >            plp
                        
075b : d002                     bne brvc1
075d : f003                     beq brvc2
075f :                  brvc1
                                trap            ;branch zero/non zero
075f : 4c5f07          >        jmp *           ;failed anyway
                        
0762 : 9002             brvc2   bcc brvc3
0764 : b003                     bcs brvc4
0766 :                  brvc3
                                trap            ;branch carry/no carry
0766 : 4c6607          >        jmp *           ;failed anyway
                        
0769 : 1002             brvc4   bpl brvc5
076b : 3003                     bmi brvc6
076d :                  brvc5
                                trap            ;branch minus/plus
076d : 4c6d07          >        jmp *           ;failed anyway
                        
0770 : 7002             brvc6   bvs brvc7
0772 : 5003                     bvc brvc8
0774 :                  brvc7
                                trap            ;branch overflow/no overflow
0774 : 4c7407          >        jmp *           ;failed anyway
                        
0777 :                  brvc8
                                next_test
0777 : ad0002          >            lda test_case   ;previous test
077a : c904            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
077c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0005 =                 >test_num = test_num + 1
077e : a905            >            lda #test_num   ;*** next tests' number
0780 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test PHA does not alter flags or accumulator but PLA does
0783 : a255                     ldx #$55        ;x & y protected
0785 : a0aa                     ldy #$aa
                                set_a 1,$ff     ;push
                       >            load_flag $ff     
0787 : a9ff            >            lda #$ff     |intdis      ;force disable interrupts
                       >
0789 : 48              >            pha         ;use stack to load status
078a : a901            >            lda #1     ;precharge accu
078c : 28              >            plp
                        
078d : 48                       pha
                                tst_a 1,$ff
078e : 08              >            php         ;save flags
078f : c901            >            cmp #1     ;test result
                       >            trap_ne
0791 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0793 : 68              >            pla         ;load status
0794 : 48              >            pha
                       >            cmp_flag $ff
0795 : c9ff            >            cmp #($ff|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0797 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0799 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
079a : a904            >            lda #0|intdis      ;force disable interrupts
                       >
079c : 48              >            pha         ;use stack to load status
079d : a900            >            lda #0     ;precharge accu
079f : 28              >            plp
                        
07a0 : 48                       pha
                                tst_a 0,0
07a1 : 08              >            php         ;save flags
07a2 : c900            >            cmp #0     ;test result
                       >            trap_ne
07a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07a6 : 68              >            pla         ;load status
07a7 : 48              >            pha
                       >            cmp_flag 0
07a8 : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
07aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07ac : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
07ad : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
07af : 48              >            pha         ;use stack to load status
07b0 : a9ff            >            lda #$ff     ;precharge accu
07b2 : 28              >            plp
                        
07b3 : 48                       pha
                                tst_a $ff,$ff
07b4 : 08              >            php         ;save flags
07b5 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07b7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07b9 : 68              >            pla         ;load status
07ba : 48              >            pha
                       >            cmp_flag $ff
07bb : c9ff            >            cmp #($ff|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
07bd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07bf : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
07c0 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
07c2 : 48              >            pha         ;use stack to load status
07c3 : a901            >            lda #1     ;precharge accu
07c5 : 28              >            plp
                        
07c6 : 48                       pha
                                tst_a 1,0
07c7 : 08              >            php         ;save flags
07c8 : c901            >            cmp #1     ;test result
                       >            trap_ne
07ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07cc : 68              >            pla         ;load status
07cd : 48              >            pha
                       >            cmp_flag 0
07ce : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
07d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07d2 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff
                       >            load_flag $ff
07d3 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
07d5 : 48              >            pha         ;use stack to load status
07d6 : a900            >            lda #0     ;precharge accu
07d8 : 28              >            plp
                        
07d9 : 48                       pha
                                tst_a 0,$ff
07da : 08              >            php         ;save flags
07db : c900            >            cmp #0     ;test result
                       >            trap_ne
07dd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07df : 68              >            pla         ;load status
07e0 : 48              >            pha
                       >            cmp_flag $ff
07e1 : c9ff            >            cmp #($ff|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
07e3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07e5 : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
07e6 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
07e8 : 48              >            pha         ;use stack to load status
07e9 : a9ff            >            lda #$ff     ;precharge accu
07eb : 28              >            plp
                        
07ec : 48                       pha
                                tst_a $ff,0
07ed : 08              >            php         ;save flags
07ee : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07f2 : 68              >            pla         ;load status
07f3 : 48              >            pha
                       >            cmp_flag 0
07f4 : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
07f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07f8 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff     ;pull
                       >            load_flag $ff     
07f9 : a9ff            >            lda #$ff     |intdis      ;force disable interrupts
                       >
07fb : 48              >            pha         ;use stack to load status
07fc : a900            >            lda #0     ;precharge accu
07fe : 28              >            plp
                        
07ff : 68                       pla
                                tst_a $ff,$ff-zero
0800 : 08              >            php         ;save flags
0801 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0803 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0805 : 68              >            pla         ;load status
0806 : 48              >            pha
                       >            cmp_flag $ff-zero
0807 : c9fd            >            cmp #($ff-zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0809 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
080b : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
080c : a904            >            lda #0|intdis      ;force disable interrupts
                       >
080e : 48              >            pha         ;use stack to load status
080f : a9ff            >            lda #$ff     ;precharge accu
0811 : 28              >            plp
                        
0812 : 68                       pla
                                tst_a 0,zero
0813 : 08              >            php         ;save flags
0814 : c900            >            cmp #0     ;test result
                       >            trap_ne
0816 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0818 : 68              >            pla         ;load status
0819 : 48              >            pha
                       >            cmp_flag zero
081a : c936            >            cmp #(zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
081c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
081e : 28              >            plp         ;restore status
                        
                                set_a $fe,$ff
                       >            load_flag $ff
081f : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0821 : 48              >            pha         ;use stack to load status
0822 : a9fe            >            lda #$fe     ;precharge accu
0824 : 28              >            plp
                        
0825 : 68                       pla
                                tst_a 1,$ff-zero-minus
0826 : 08              >            php         ;save flags
0827 : c901            >            cmp #1     ;test result
                       >            trap_ne
0829 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
082b : 68              >            pla         ;load status
082c : 48              >            pha
                       >            cmp_flag $ff-zero-minus
082d : c97d            >            cmp #($ff-zero-minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
082f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0831 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
0832 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0834 : 48              >            pha         ;use stack to load status
0835 : a900            >            lda #0     ;precharge accu
0837 : 28              >            plp
                        
0838 : 68                       pla
                                tst_a $ff,minus
0839 : 08              >            php         ;save flags
083a : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
083c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
083e : 68              >            pla         ;load status
083f : 48              >            pha
                       >            cmp_flag minus
0840 : c9b4            >            cmp #(minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0842 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0844 : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
0845 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0847 : 48              >            pha         ;use stack to load status
0848 : a9ff            >            lda #$ff     ;precharge accu
084a : 28              >            plp
                        
084b : 68                       pla
                                tst_a 0,$ff-minus
084c : 08              >            php         ;save flags
084d : c900            >            cmp #0     ;test result
                       >            trap_ne
084f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0851 : 68              >            pla         ;load status
0852 : 48              >            pha
                       >            cmp_flag $ff-minus
0853 : c97f            >            cmp #($ff-minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0855 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0857 : 28              >            plp         ;restore status
                        
                                set_a $fe,0
                       >            load_flag 0
0858 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
085a : 48              >            pha         ;use stack to load status
085b : a9fe            >            lda #$fe     ;precharge accu
085d : 28              >            plp
                        
085e : 68                       pla
                                tst_a 1,0
085f : 08              >            php         ;save flags
0860 : c901            >            cmp #1     ;test result
                       >            trap_ne
0862 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0864 : 68              >            pla         ;load status
0865 : 48              >            pha
                       >            cmp_flag 0
0866 : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0868 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
086a : 28              >            plp         ;restore status
                        
086b : e055                     cpx #$55        ;x & y unchanged?
                                trap_ne
086d : d0fe            >        bne *           ;failed not equal (non zero)
                        
086f : c0aa                     cpy #$aa
                                trap_ne
0871 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0873 : ad0002          >            lda test_case   ;previous test
0876 : c905            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0878 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0006 =                 >test_num = test_num + 1
087a : a906            >            lda #test_num   ;*** next tests' number
087c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; partial pretest EOR #
                                set_a $3c,0
                       >            load_flag 0
087f : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0881 : 48              >            pha         ;use stack to load status
0882 : a93c            >            lda #$3c     ;precharge accu
0884 : 28              >            plp
                        
0885 : 49c3                     eor #$c3
                                tst_a $ff,fn
0887 : 08              >            php         ;save flags
0888 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
088a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
088c : 68              >            pla         ;load status
088d : 48              >            pha
                       >            cmp_flag fn
088e : c9b4            >            cmp #(fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0890 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0892 : 28              >            plp         ;restore status
                        
                                set_a $c3,0
                       >            load_flag 0
0893 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0895 : 48              >            pha         ;use stack to load status
0896 : a9c3            >            lda #$c3     ;precharge accu
0898 : 28              >            plp
                        
0899 : 49c3                     eor #$c3
                                tst_a 0,fz
089b : 08              >            php         ;save flags
089c : c900            >            cmp #0     ;test result
                       >            trap_ne
089e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08a0 : 68              >            pla         ;load status
08a1 : 48              >            pha
                       >            cmp_flag fz
08a2 : c936            >            cmp #(fz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
08a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08a6 : 28              >            plp         ;restore status
                        
                                next_test
08a7 : ad0002          >            lda test_case   ;previous test
08aa : c906            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08ac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0007 =                 >test_num = test_num + 1
08ae : a907            >            lda #test_num   ;*** next tests' number
08b0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
                        ; testing NOP
08b3 : a224                     ldx #$24
08b5 : a042                     ldy #$42
                                set_a $18,0
                       >            load_flag 0
08b7 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
08b9 : 48              >            pha         ;use stack to load status
08ba : a918            >            lda #$18     ;precharge accu
08bc : 28              >            plp
                        
08bd : ea                       nop
                                tst_a $18,0
08be : 08              >            php         ;save flags
08bf : c918            >            cmp #$18     ;test result
                       >            trap_ne
08c1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08c3 : 68              >            pla         ;load status
08c4 : 48              >            pha
                       >            cmp_flag 0
08c5 : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
08c7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08c9 : 28              >            plp         ;restore status
                        
08ca : e024                     cpx #$24
                                trap_ne
08cc : d0fe            >        bne *           ;failed not equal (non zero)
                        
08ce : c042                     cpy #$42
                                trap_ne
08d0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
08d2 : a2db                     ldx #$db
08d4 : a0bd                     ldy #$bd
                                set_a $e7,$ff
                       >            load_flag $ff
08d6 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
08d8 : 48              >            pha         ;use stack to load status
08d9 : a9e7            >            lda #$e7     ;precharge accu
08db : 28              >            plp
                        
08dc : ea                       nop
                                tst_a $e7,$ff
08dd : 08              >            php         ;save flags
08de : c9e7            >            cmp #$e7     ;test result
                       >            trap_ne
08e0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08e2 : 68              >            pla         ;load status
08e3 : 48              >            pha
                       >            cmp_flag $ff
08e4 : c9ff            >            cmp #($ff|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
08e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08e8 : 28              >            plp         ;restore status
                        
08e9 : e0db                     cpx #$db
                                trap_ne
08eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
08ed : c0bd                     cpy #$bd
                                trap_ne
08ef : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
08f1 : ad0002          >            lda test_case   ;previous test
08f4 : c907            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0008 =                 >test_num = test_num + 1
08f8 : a908            >            lda #test_num   ;*** next tests' number
08fa : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump absolute
                                set_stat $0
                       >            load_flag $0
08fd : a904            >            lda #$0|intdis      ;force disable interrupts
                       >
08ff : 48              >            pha         ;use stack to load status
0900 : 28              >            plp
                        
0901 : a946                     lda #'F'
0903 : a241                     ldx #'A'
0905 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
0907 : 4ccb36                   jmp test_far
090a : ea                       nop
090b : ea                       nop
                                trap_ne         ;runover protection
090c : d0fe            >        bne *           ;failed not equal (non zero)
                        
090e : e8                       inx
090f : e8                       inx
0910 :                  far_ret 
                                trap_eq         ;returned flags OK?
0910 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
0912 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0914 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0916 : 50fe            >        bvc *           ;failed overflow clear
                        
0918 : c9ec                     cmp #('F'^$aa)  ;returned registers OK?
                                trap_ne
091a : d0fe            >        bne *           ;failed not equal (non zero)
                        
091c : e042                     cpx #('A'+1)
                                trap_ne
091e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0920 : c04f                     cpy #('R'-3)
                                trap_ne
0922 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0924 : ca                       dex
0925 : c8                       iny
0926 : c8                       iny
0927 : c8                       iny
0928 : 49aa                     eor #$aa        ;N=0, V=1, Z=0, C=1
092a : 4c3309                   jmp test_near
092d : ea                       nop
092e : ea                       nop
                                trap_ne         ;runover protection
092f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0931 : e8                       inx
0932 : e8                       inx
0933 :                  test_near
                                trap_eq         ;passed flags OK?
0933 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_mi
0935 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_cc
0937 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0939 : 50fe            >        bvc *           ;failed overflow clear
                        
093b : c946                     cmp #'F'        ;passed registers OK?
                                trap_ne
093d : d0fe            >        bne *           ;failed not equal (non zero)
                        
093f : e041                     cpx #'A'
                                trap_ne
0941 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0943 : c052                     cpy #'R'
                                trap_ne
0945 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0947 : ad0002          >            lda test_case   ;previous test
094a : c908            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
094c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0009 =                 >test_num = test_num + 1
094e : a909            >            lda #test_num   ;*** next tests' number
0950 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump indirect
                                set_stat 0
                       >            load_flag 0
0953 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0955 : 48              >            pha         ;use stack to load status
0956 : 28              >            plp
                        
0957 : a949                     lda #'I'
0959 : a24e                     ldx #'N'
095b : a044                     ldy #'D'        ;N=0, V=0, Z=0, C=0
095d : 6cfa36                   jmp (ptr_tst_ind)
0960 : ea                       nop
                                trap_ne         ;runover protection
0961 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0963 : 88                       dey
0964 : 88                       dey
0965 :                  ind_ret 
0965 : 08                       php             ;either SP or Y count will fail, if we do not hit
0966 : 88                       dey
0967 : 88                       dey
0968 : 88                       dey
0969 : 28                       plp
                                trap_eq         ;returned flags OK?
096a : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
096c : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
096e : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0970 : 50fe            >        bvc *           ;failed overflow clear
                        
0972 : c9e3                     cmp #('I'^$aa)  ;returned registers OK?
                                trap_ne
0974 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0976 : e04f                     cpx #('N'+1)
                                trap_ne
0978 : d0fe            >        bne *           ;failed not equal (non zero)
                        
097a : c03e                     cpy #('D'-6)
                                trap_ne
097c : d0fe            >        bne *           ;failed not equal (non zero)
                        
097e : ba                       tsx             ;SP check
097f : e0ff                     cpx #$ff
                                trap_ne
0981 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0983 : ad0002          >            lda test_case   ;previous test
0986 : c909            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0988 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000a =                 >test_num = test_num + 1
098a : a90a            >            lda #test_num   ;*** next tests' number
098c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump subroutine & return from subroutine
                                set_stat 0
                       >            load_flag 0
098f : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0991 : 48              >            pha         ;use stack to load status
0992 : 28              >            plp
                        
0993 : a94a                     lda #'J'
0995 : a253                     ldx #'S'
0997 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
0999 : 203937                   jsr test_jsr
099b =                  jsr_ret = *-1           ;last address of jsr = return address
099c : 08                       php             ;either SP or Y count will fail, if we do not hit
099d : 88                       dey
099e : 88                       dey
099f : 88                       dey
09a0 : 28                       plp
                                trap_eq         ;returned flags OK?
09a1 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
09a3 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
09a5 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
09a7 : 50fe            >        bvc *           ;failed overflow clear
                        
09a9 : c9e0                     cmp #('J'^$aa)  ;returned registers OK?
                                trap_ne
09ab : d0fe            >        bne *           ;failed not equal (non zero)
                        
09ad : e054                     cpx #('S'+1)
                                trap_ne
09af : d0fe            >        bne *           ;failed not equal (non zero)
                        
09b1 : c04c                     cpy #('R'-6)
                                trap_ne
09b3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09b5 : ba                       tsx             ;sp?
09b6 : e0ff                     cpx #$ff
                                trap_ne
09b8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
09ba : ad0002          >            lda test_case   ;previous test
09bd : c90a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
09bf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000b =                 >test_num = test_num + 1
09c1 : a90b            >            lda #test_num   ;*** next tests' number
09c3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; break & return from interrupt
                            if ROM_vectors = 1
                                load_flag 0     ;with interrupts enabled if allowed!
09c6 : a904            >            lda #0     |intdis      ;force disable interrupts
                        
09c8 : 48                       pha
09c9 : a942                     lda #'B'
09cb : a252                     ldx #'R'
09cd : a04b                     ldy #'K'
09cf : 28                       plp             ;N=0, V=0, Z=0, C=0
09d0 : 00                       brk
                            else
                                lda #hi brk_ret0 ;emulated break
                                pha
                                lda #lo brk_ret0
                                pha
                                load_flag fao    ;set break & unused on stack
                                pha
                                load_flag intdis ;during interrupt
                                pha
                                lda #'B'
                                ldx #'R'
                                ldy #'K'
                                plp             ;N=0, V=0, Z=0, C=0
                                jmp irq_trap
                            endif
09d1 : 88                       dey             ;should not be executed
09d2 :                  brk_ret0                ;address of break return
09d2 : 08                       php             ;either SP or Y count will fail, if we do not hit
09d3 : 88                       dey
09d4 : 88                       dey
09d5 : 88                       dey
09d6 : c9e8                     cmp #'B'^$aa    ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
09d8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09da : e053                     cpx #'R'+1
                                trap_ne
09dc : d0fe            >        bne *           ;failed not equal (non zero)
                        
09de : c045                     cpy #'K'-6
                                trap_ne
09e0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09e2 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag 0
09e3 : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
09e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09e7 : ba                       tsx             ;sp?
09e8 : e0ff                     cpx #$ff
                                trap_ne
09ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
                            if ROM_vectors = 1
                                load_flag $ff   ;with interrupts disabled if allowed!
09ec : a9ff            >            lda #$ff   |intdis      ;force disable interrupts
                        
09ee : 48                       pha
09ef : a9bd                     lda #$ff-'B'
09f1 : a2ad                     ldx #$ff-'R'
09f3 : a0b4                     ldy #$ff-'K'
09f5 : 28                       plp             ;N=1, V=1, Z=1, C=1
09f6 : 00                       brk
                            else
                                lda #hi brk_ret1 ;emulated break
                                pha
                                lda #lo brk_ret1
                                pha
                                load_flag $ff
                                pha             ;set break & unused on stack
                                pha             ;actual flags
                                lda #$ff-'B'
                                ldx #$ff-'R'
                                ldy #$ff-'K'
                                plp             ;N=1, V=1, Z=1, C=1
                                jmp irq_trap
                            endif
09f7 : 88                       dey             ;should not be executed
09f8 :                  brk_ret1                ;address of break return
09f8 : 08                       php             ;either SP or Y count will fail, if we do not hit
09f9 : 88                       dey
09fa : 88                       dey
09fb : 88                       dey
09fc : c917                     cmp #($ff-'B')^$aa  ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
09fe : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a00 : e0ae                     cpx #$ff-'R'+1
                                trap_ne
0a02 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a04 : c0ae                     cpy #$ff-'K'-6
                                trap_ne
0a06 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a08 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag $ff
0a09 : c9ff            >            cmp #($ff|fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
0a0b : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a0d : ba                       tsx             ;sp?
0a0e : e0ff                     cpx #$ff
                                trap_ne
0a10 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0a12 : ad0002          >            lda test_case   ;previous test
0a15 : c90b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0a17 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000c =                 >test_num = test_num + 1
0a19 : a90c            >            lda #test_num   ;*** next tests' number
0a1b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
                                set_stat $ff
                       >            load_flag $ff
0a1e : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0a20 : 48              >            pha         ;use stack to load status
0a21 : 28              >            plp
                        
0a22 : 18                       clc
                                tst_stat $ff-carry
0a23 : 08              >            php         ;save status
0a24 : 68              >            pla         ;use stack to retrieve status
0a25 : 48              >            pha
                       >            cmp_flag $ff-carry
0a26 : c9fe            >            cmp #($ff-carry|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0a28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a2a : 28              >            plp         ;restore status
                        
0a2b : 38                       sec
                                tst_stat $ff
0a2c : 08              >            php         ;save status
0a2d : 68              >            pla         ;use stack to retrieve status
0a2e : 48              >            pha
                       >            cmp_flag $ff
0a2f : c9ff            >            cmp #($ff|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0a31 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a33 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
                                cli
                                tst_stat $ff-intdis
                                sei
                                tst_stat $ff
                            endif
0a34 : d8                       cld
                                tst_stat $ff-decmode
0a35 : 08              >            php         ;save status
0a36 : 68              >            pla         ;use stack to retrieve status
0a37 : 48              >            pha
                       >            cmp_flag $ff-decmode
0a38 : c9f7            >            cmp #($ff-decmode|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0a3a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a3c : 28              >            plp         ;restore status
                        
0a3d : f8                       sed
                                tst_stat $ff
0a3e : 08              >            php         ;save status
0a3f : 68              >            pla         ;use stack to retrieve status
0a40 : 48              >            pha
                       >            cmp_flag $ff
0a41 : c9ff            >            cmp #($ff|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0a43 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a45 : 28              >            plp         ;restore status
                        
0a46 : b8                       clv
                                tst_stat $ff-overfl
0a47 : 08              >            php         ;save status
0a48 : 68              >            pla         ;use stack to retrieve status
0a49 : 48              >            pha
                       >            cmp_flag $ff-overfl
0a4a : c9bf            >            cmp #($ff-overfl|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0a4c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a4e : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0a4f : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0a51 : 48              >            pha         ;use stack to load status
0a52 : 28              >            plp
                        
                                tst_stat 0
0a53 : 08              >            php         ;save status
0a54 : 68              >            pla         ;use stack to retrieve status
0a55 : 48              >            pha
                       >            cmp_flag 0
0a56 : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0a58 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a5a : 28              >            plp         ;restore status
                        
0a5b : 38                       sec
                                tst_stat carry
0a5c : 08              >            php         ;save status
0a5d : 68              >            pla         ;use stack to retrieve status
0a5e : 48              >            pha
                       >            cmp_flag carry
0a5f : c935            >            cmp #(carry|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0a61 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a63 : 28              >            plp         ;restore status
                        
0a64 : 18                       clc
                                tst_stat 0  
0a65 : 08              >            php         ;save status
0a66 : 68              >            pla         ;use stack to retrieve status
0a67 : 48              >            pha
                       >            cmp_flag 0  
0a68 : c934            >            cmp #(0  |fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0a6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a6c : 28              >            plp         ;restore status
                        
                            if I_flag = 3
                                sei
                                tst_stat intdis
                                cli
                                tst_stat 0
                            endif  
0a6d : f8                       sed
                                tst_stat decmode
0a6e : 08              >            php         ;save status
0a6f : 68              >            pla         ;use stack to retrieve status
0a70 : 48              >            pha
                       >            cmp_flag decmode
0a71 : c93c            >            cmp #(decmode|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0a73 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a75 : 28              >            plp         ;restore status
                        
0a76 : d8                       cld
                                tst_stat 0  
0a77 : 08              >            php         ;save status
0a78 : 68              >            pla         ;use stack to retrieve status
0a79 : 48              >            pha
                       >            cmp_flag 0  
0a7a : c934            >            cmp #(0  |fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0a7c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a7e : 28              >            plp         ;restore status
                        
                                set_stat overfl
                       >            load_flag overfl
0a7f : a944            >            lda #overfl|intdis      ;force disable interrupts
                       >
0a81 : 48              >            pha         ;use stack to load status
0a82 : 28              >            plp
                        
                                tst_stat overfl
0a83 : 08              >            php         ;save status
0a84 : 68              >            pla         ;use stack to retrieve status
0a85 : 48              >            pha
                       >            cmp_flag overfl
0a86 : c974            >            cmp #(overfl|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0a88 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a8a : 28              >            plp         ;restore status
                        
0a8b : b8                       clv
                                tst_stat 0
0a8c : 08              >            php         ;save status
0a8d : 68              >            pla         ;use stack to retrieve status
0a8e : 48              >            pha
                       >            cmp_flag 0
0a8f : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0a91 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a93 : 28              >            plp         ;restore status
                        
                                next_test
0a94 : ad0002          >            lda test_case   ;previous test
0a97 : c90c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0a99 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000d =                 >test_num = test_num + 1
0a9b : a90d            >            lda #test_num   ;*** next tests' number
0a9d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ; testing index register increment/decrement and transfer
                        ; INX INY DEX DEY TAX TXA TAY TYA 
0aa0 : a2fe                     ldx #$fe
                                set_stat $ff
                       >            load_flag $ff
0aa2 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0aa4 : 48              >            pha         ;use stack to load status
0aa5 : 28              >            plp
                        
0aa6 : e8                       inx             ;ff
                                tst_x $ff,$ff-zero
0aa7 : 08              >            php         ;save flags
0aa8 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0aaa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aac : 68              >            pla         ;load status
0aad : 48              >            pha
                       >            cmp_flag $ff-zero
0aae : c9fd            >            cmp #($ff-zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0ab0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ab2 : 28              >            plp         ;restore status
                        
0ab3 : e8                       inx             ;00
                                tst_x 0,$ff-minus
0ab4 : 08              >            php         ;save flags
0ab5 : e000            >            cpx #0     ;test result
                       >            trap_ne
0ab7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ab9 : 68              >            pla         ;load status
0aba : 48              >            pha
                       >            cmp_flag $ff-minus
0abb : c97f            >            cmp #($ff-minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0abd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0abf : 28              >            plp         ;restore status
                        
0ac0 : e8                       inx             ;01
                                tst_x 1,$ff-minus-zero
0ac1 : 08              >            php         ;save flags
0ac2 : e001            >            cpx #1     ;test result
                       >            trap_ne
0ac4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ac6 : 68              >            pla         ;load status
0ac7 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0ac8 : c97d            >            cmp #($ff-minus-zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0aca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0acc : 28              >            plp         ;restore status
                        
0acd : ca                       dex             ;00
                                tst_x 0,$ff-minus
0ace : 08              >            php         ;save flags
0acf : e000            >            cpx #0     ;test result
                       >            trap_ne
0ad1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ad3 : 68              >            pla         ;load status
0ad4 : 48              >            pha
                       >            cmp_flag $ff-minus
0ad5 : c97f            >            cmp #($ff-minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0ad7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ad9 : 28              >            plp         ;restore status
                        
0ada : ca                       dex             ;ff
                                tst_x $ff,$ff-zero
0adb : 08              >            php         ;save flags
0adc : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0ade : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ae0 : 68              >            pla         ;load status
0ae1 : 48              >            pha
                       >            cmp_flag $ff-zero
0ae2 : c9fd            >            cmp #($ff-zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0ae4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ae6 : 28              >            plp         ;restore status
                        
0ae7 : ca                       dex             ;fe
                                set_stat 0
                       >            load_flag 0
0ae8 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0aea : 48              >            pha         ;use stack to load status
0aeb : 28              >            plp
                        
0aec : e8                       inx             ;ff
                                tst_x $ff,minus
0aed : 08              >            php         ;save flags
0aee : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0af0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0af2 : 68              >            pla         ;load status
0af3 : 48              >            pha
                       >            cmp_flag minus
0af4 : c9b4            >            cmp #(minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0af6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0af8 : 28              >            plp         ;restore status
                        
0af9 : e8                       inx             ;00
                                tst_x 0,zero
0afa : 08              >            php         ;save flags
0afb : e000            >            cpx #0     ;test result
                       >            trap_ne
0afd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aff : 68              >            pla         ;load status
0b00 : 48              >            pha
                       >            cmp_flag zero
0b01 : c936            >            cmp #(zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0b03 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b05 : 28              >            plp         ;restore status
                        
0b06 : e8                       inx             ;01
                                tst_x 1,0
0b07 : 08              >            php         ;save flags
0b08 : e001            >            cpx #1     ;test result
                       >            trap_ne
0b0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b0c : 68              >            pla         ;load status
0b0d : 48              >            pha
                       >            cmp_flag 0
0b0e : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0b10 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b12 : 28              >            plp         ;restore status
                        
0b13 : ca                       dex             ;00
                                tst_x 0,zero
0b14 : 08              >            php         ;save flags
0b15 : e000            >            cpx #0     ;test result
                       >            trap_ne
0b17 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b19 : 68              >            pla         ;load status
0b1a : 48              >            pha
                       >            cmp_flag zero
0b1b : c936            >            cmp #(zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0b1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b1f : 28              >            plp         ;restore status
                        
0b20 : ca                       dex             ;ff
                                tst_x $ff,minus
0b21 : 08              >            php         ;save flags
0b22 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0b24 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b26 : 68              >            pla         ;load status
0b27 : 48              >            pha
                       >            cmp_flag minus
0b28 : c9b4            >            cmp #(minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0b2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b2c : 28              >            plp         ;restore status
                        
                        
0b2d : a0fe                     ldy #$fe
                                set_stat $ff
                       >            load_flag $ff
0b2f : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0b31 : 48              >            pha         ;use stack to load status
0b32 : 28              >            plp
                        
0b33 : c8                       iny             ;ff
                                tst_y $ff,$ff-zero
0b34 : 08              >            php         ;save flags
0b35 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b37 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b39 : 68              >            pla         ;load status
0b3a : 48              >            pha
                       >            cmp_flag $ff-zero
0b3b : c9fd            >            cmp #($ff-zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0b3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b3f : 28              >            plp         ;restore status
                        
0b40 : c8                       iny             ;00
                                tst_y 0,$ff-minus
0b41 : 08              >            php         ;save flags
0b42 : c000            >            cpy #0     ;test result
                       >            trap_ne
0b44 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b46 : 68              >            pla         ;load status
0b47 : 48              >            pha
                       >            cmp_flag $ff-minus
0b48 : c97f            >            cmp #($ff-minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0b4a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b4c : 28              >            plp         ;restore status
                        
0b4d : c8                       iny             ;01
                                tst_y 1,$ff-minus-zero
0b4e : 08              >            php         ;save flags
0b4f : c001            >            cpy #1     ;test result
                       >            trap_ne
0b51 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b53 : 68              >            pla         ;load status
0b54 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0b55 : c97d            >            cmp #($ff-minus-zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0b57 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b59 : 28              >            plp         ;restore status
                        
0b5a : 88                       dey             ;00
                                tst_y 0,$ff-minus
0b5b : 08              >            php         ;save flags
0b5c : c000            >            cpy #0     ;test result
                       >            trap_ne
0b5e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b60 : 68              >            pla         ;load status
0b61 : 48              >            pha
                       >            cmp_flag $ff-minus
0b62 : c97f            >            cmp #($ff-minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0b64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b66 : 28              >            plp         ;restore status
                        
0b67 : 88                       dey             ;ff
                                tst_y $ff,$ff-zero
0b68 : 08              >            php         ;save flags
0b69 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b6d : 68              >            pla         ;load status
0b6e : 48              >            pha
                       >            cmp_flag $ff-zero
0b6f : c9fd            >            cmp #($ff-zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0b71 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b73 : 28              >            plp         ;restore status
                        
0b74 : 88                       dey             ;fe
                                set_stat 0
                       >            load_flag 0
0b75 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0b77 : 48              >            pha         ;use stack to load status
0b78 : 28              >            plp
                        
0b79 : c8                       iny             ;ff
                                tst_y $ff,0+minus
0b7a : 08              >            php         ;save flags
0b7b : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b7d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b7f : 68              >            pla         ;load status
0b80 : 48              >            pha
                       >            cmp_flag 0+minus
0b81 : c9b4            >            cmp #(0+minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0b83 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b85 : 28              >            plp         ;restore status
                        
0b86 : c8                       iny             ;00
                                tst_y 0,zero
0b87 : 08              >            php         ;save flags
0b88 : c000            >            cpy #0     ;test result
                       >            trap_ne
0b8a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b8c : 68              >            pla         ;load status
0b8d : 48              >            pha
                       >            cmp_flag zero
0b8e : c936            >            cmp #(zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0b90 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b92 : 28              >            plp         ;restore status
                        
0b93 : c8                       iny             ;01
                                tst_y 1,0
0b94 : 08              >            php         ;save flags
0b95 : c001            >            cpy #1     ;test result
                       >            trap_ne
0b97 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b99 : 68              >            pla         ;load status
0b9a : 48              >            pha
                       >            cmp_flag 0
0b9b : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0b9d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b9f : 28              >            plp         ;restore status
                        
0ba0 : 88                       dey             ;00
                                tst_y 0,zero
0ba1 : 08              >            php         ;save flags
0ba2 : c000            >            cpy #0     ;test result
                       >            trap_ne
0ba4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ba6 : 68              >            pla         ;load status
0ba7 : 48              >            pha
                       >            cmp_flag zero
0ba8 : c936            >            cmp #(zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0baa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bac : 28              >            plp         ;restore status
                        
0bad : 88                       dey             ;ff
                                tst_y $ff,minus
0bae : 08              >            php         ;save flags
0baf : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0bb1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bb3 : 68              >            pla         ;load status
0bb4 : 48              >            pha
                       >            cmp_flag minus
0bb5 : c9b4            >            cmp #(minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0bb7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bb9 : 28              >            plp         ;restore status
                        
                                        
0bba : a2ff                     ldx #$ff
                                set_stat $ff
                       >            load_flag $ff
0bbc : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0bbe : 48              >            pha         ;use stack to load status
0bbf : 28              >            plp
                        
0bc0 : 8a                       txa
                                tst_a $ff,$ff-zero
0bc1 : 08              >            php         ;save flags
0bc2 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0bc4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bc6 : 68              >            pla         ;load status
0bc7 : 48              >            pha
                       >            cmp_flag $ff-zero
0bc8 : c9fd            >            cmp #($ff-zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0bca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bcc : 28              >            plp         ;restore status
                        
0bcd : 08                       php
0bce : e8                       inx             ;00
0bcf : 28                       plp
0bd0 : 8a                       txa
                                tst_a 0,$ff-minus
0bd1 : 08              >            php         ;save flags
0bd2 : c900            >            cmp #0     ;test result
                       >            trap_ne
0bd4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bd6 : 68              >            pla         ;load status
0bd7 : 48              >            pha
                       >            cmp_flag $ff-minus
0bd8 : c97f            >            cmp #($ff-minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0bda : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bdc : 28              >            plp         ;restore status
                        
0bdd : 08                       php
0bde : e8                       inx             ;01
0bdf : 28                       plp
0be0 : 8a                       txa
                                tst_a 1,$ff-minus-zero
0be1 : 08              >            php         ;save flags
0be2 : c901            >            cmp #1     ;test result
                       >            trap_ne
0be4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0be6 : 68              >            pla         ;load status
0be7 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0be8 : c97d            >            cmp #($ff-minus-zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0bea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bec : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0bed : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0bef : 48              >            pha         ;use stack to load status
0bf0 : 28              >            plp
                        
0bf1 : 8a                       txa
                                tst_a 1,0
0bf2 : 08              >            php         ;save flags
0bf3 : c901            >            cmp #1     ;test result
                       >            trap_ne
0bf5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bf7 : 68              >            pla         ;load status
0bf8 : 48              >            pha
                       >            cmp_flag 0
0bf9 : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0bfb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bfd : 28              >            plp         ;restore status
                        
0bfe : 08                       php
0bff : ca                       dex             ;00
0c00 : 28                       plp
0c01 : 8a                       txa
                                tst_a 0,zero
0c02 : 08              >            php         ;save flags
0c03 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c05 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c07 : 68              >            pla         ;load status
0c08 : 48              >            pha
                       >            cmp_flag zero
0c09 : c936            >            cmp #(zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0c0b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c0d : 28              >            plp         ;restore status
                        
0c0e : 08                       php
0c0f : ca                       dex             ;ff
0c10 : 28                       plp
0c11 : 8a                       txa
                                tst_a $ff,minus
0c12 : 08              >            php         ;save flags
0c13 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c15 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c17 : 68              >            pla         ;load status
0c18 : 48              >            pha
                       >            cmp_flag minus
0c19 : c9b4            >            cmp #(minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0c1b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c1d : 28              >            plp         ;restore status
                        
                                                
0c1e : a0ff                     ldy #$ff
                                set_stat $ff
                       >            load_flag $ff
0c20 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0c22 : 48              >            pha         ;use stack to load status
0c23 : 28              >            plp
                        
0c24 : 98                       tya
                                tst_a $ff,$ff-zero
0c25 : 08              >            php         ;save flags
0c26 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c2a : 68              >            pla         ;load status
0c2b : 48              >            pha
                       >            cmp_flag $ff-zero
0c2c : c9fd            >            cmp #($ff-zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0c2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c30 : 28              >            plp         ;restore status
                        
0c31 : 08                       php
0c32 : c8                       iny             ;00
0c33 : 28                       plp
0c34 : 98                       tya
                                tst_a 0,$ff-minus
0c35 : 08              >            php         ;save flags
0c36 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c3a : 68              >            pla         ;load status
0c3b : 48              >            pha
                       >            cmp_flag $ff-minus
0c3c : c97f            >            cmp #($ff-minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0c3e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c40 : 28              >            plp         ;restore status
                        
0c41 : 08                       php
0c42 : c8                       iny             ;01
0c43 : 28                       plp
0c44 : 98                       tya
                                tst_a 1,$ff-minus-zero
0c45 : 08              >            php         ;save flags
0c46 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c48 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c4a : 68              >            pla         ;load status
0c4b : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0c4c : c97d            >            cmp #($ff-minus-zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0c4e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c50 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0c51 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0c53 : 48              >            pha         ;use stack to load status
0c54 : 28              >            plp
                        
0c55 : 98                       tya
                                tst_a 1,0
0c56 : 08              >            php         ;save flags
0c57 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c59 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c5b : 68              >            pla         ;load status
0c5c : 48              >            pha
                       >            cmp_flag 0
0c5d : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0c5f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c61 : 28              >            plp         ;restore status
                        
0c62 : 08                       php
0c63 : 88                       dey             ;00
0c64 : 28                       plp
0c65 : 98                       tya
                                tst_a 0,zero
0c66 : 08              >            php         ;save flags
0c67 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c69 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c6b : 68              >            pla         ;load status
0c6c : 48              >            pha
                       >            cmp_flag zero
0c6d : c936            >            cmp #(zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0c6f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c71 : 28              >            plp         ;restore status
                        
0c72 : 08                       php
0c73 : 88                       dey             ;ff
0c74 : 28                       plp
0c75 : 98                       tya
                                tst_a $ff,minus
0c76 : 08              >            php         ;save flags
0c77 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c79 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c7b : 68              >            pla         ;load status
0c7c : 48              >            pha
                       >            cmp_flag minus
0c7d : c9b4            >            cmp #(minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0c7f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c81 : 28              >            plp         ;restore status
                        
                        
                                load_flag $ff
0c82 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                        
0c84 : 48                       pha
0c85 : a2ff                     ldx #$ff        ;ff
0c87 : 8a                       txa
0c88 : 28                       plp             
0c89 : a8                       tay
                                tst_y $ff,$ff-zero
0c8a : 08              >            php         ;save flags
0c8b : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0c8d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c8f : 68              >            pla         ;load status
0c90 : 48              >            pha
                       >            cmp_flag $ff-zero
0c91 : c9fd            >            cmp #($ff-zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0c93 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c95 : 28              >            plp         ;restore status
                        
0c96 : 08                       php
0c97 : e8                       inx             ;00
0c98 : 8a                       txa
0c99 : 28                       plp
0c9a : a8                       tay
                                tst_y 0,$ff-minus
0c9b : 08              >            php         ;save flags
0c9c : c000            >            cpy #0     ;test result
                       >            trap_ne
0c9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ca0 : 68              >            pla         ;load status
0ca1 : 48              >            pha
                       >            cmp_flag $ff-minus
0ca2 : c97f            >            cmp #($ff-minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0ca4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ca6 : 28              >            plp         ;restore status
                        
0ca7 : 08                       php
0ca8 : e8                       inx             ;01
0ca9 : 8a                       txa
0caa : 28                       plp
0cab : a8                       tay
                                tst_y 1,$ff-minus-zero
0cac : 08              >            php         ;save flags
0cad : c001            >            cpy #1     ;test result
                       >            trap_ne
0caf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cb1 : 68              >            pla         ;load status
0cb2 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0cb3 : c97d            >            cmp #($ff-minus-zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0cb5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cb7 : 28              >            plp         ;restore status
                        
                                load_flag 0
0cb8 : a904            >            lda #0|intdis      ;force disable interrupts
                        
0cba : 48                       pha
0cbb : a900                     lda #0
0cbd : 8a                       txa
0cbe : 28                       plp
0cbf : a8                       tay
                                tst_y 1,0
0cc0 : 08              >            php         ;save flags
0cc1 : c001            >            cpy #1     ;test result
                       >            trap_ne
0cc3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cc5 : 68              >            pla         ;load status
0cc6 : 48              >            pha
                       >            cmp_flag 0
0cc7 : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0cc9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ccb : 28              >            plp         ;restore status
                        
0ccc : 08                       php
0ccd : ca                       dex             ;00
0cce : 8a                       txa
0ccf : 28                       plp
0cd0 : a8                       tay
                                tst_y 0,zero
0cd1 : 08              >            php         ;save flags
0cd2 : c000            >            cpy #0     ;test result
                       >            trap_ne
0cd4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cd6 : 68              >            pla         ;load status
0cd7 : 48              >            pha
                       >            cmp_flag zero
0cd8 : c936            >            cmp #(zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0cda : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cdc : 28              >            plp         ;restore status
                        
0cdd : 08                       php
0cde : ca                       dex             ;ff
0cdf : 8a                       txa
0ce0 : 28                       plp
0ce1 : a8                       tay
                                tst_y $ff,minus
0ce2 : 08              >            php         ;save flags
0ce3 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0ce5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ce7 : 68              >            pla         ;load status
0ce8 : 48              >            pha
                       >            cmp_flag minus
0ce9 : c9b4            >            cmp #(minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0ceb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ced : 28              >            plp         ;restore status
                        
                        
                        
                                load_flag $ff
0cee : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                        
0cf0 : 48                       pha
0cf1 : a0ff                     ldy #$ff        ;ff
0cf3 : 98                       tya
0cf4 : 28                       plp
0cf5 : aa                       tax
                                tst_x $ff,$ff-zero
0cf6 : 08              >            php         ;save flags
0cf7 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0cf9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cfb : 68              >            pla         ;load status
0cfc : 48              >            pha
                       >            cmp_flag $ff-zero
0cfd : c9fd            >            cmp #($ff-zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0cff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d01 : 28              >            plp         ;restore status
                        
0d02 : 08                       php
0d03 : c8                       iny             ;00
0d04 : 98                       tya
0d05 : 28                       plp
0d06 : aa                       tax
                                tst_x 0,$ff-minus
0d07 : 08              >            php         ;save flags
0d08 : e000            >            cpx #0     ;test result
                       >            trap_ne
0d0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d0c : 68              >            pla         ;load status
0d0d : 48              >            pha
                       >            cmp_flag $ff-minus
0d0e : c97f            >            cmp #($ff-minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0d10 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d12 : 28              >            plp         ;restore status
                        
0d13 : 08                       php
0d14 : c8                       iny             ;01
0d15 : 98                       tya
0d16 : 28                       plp
0d17 : aa                       tax
                                tst_x 1,$ff-minus-zero
0d18 : 08              >            php         ;save flags
0d19 : e001            >            cpx #1     ;test result
                       >            trap_ne
0d1b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d1d : 68              >            pla         ;load status
0d1e : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0d1f : c97d            >            cmp #($ff-minus-zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0d21 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d23 : 28              >            plp         ;restore status
                        
                                load_flag 0
0d24 : a904            >            lda #0|intdis      ;force disable interrupts
                        
0d26 : 48                       pha
0d27 : a900                     lda #0          ;preset status
0d29 : 98                       tya
0d2a : 28                       plp
0d2b : aa                       tax
                                tst_x 1,0
0d2c : 08              >            php         ;save flags
0d2d : e001            >            cpx #1     ;test result
                       >            trap_ne
0d2f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d31 : 68              >            pla         ;load status
0d32 : 48              >            pha
                       >            cmp_flag 0
0d33 : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0d35 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d37 : 28              >            plp         ;restore status
                        
0d38 : 08                       php
0d39 : 88                       dey             ;00
0d3a : 98                       tya
0d3b : 28                       plp
0d3c : aa                       tax
                                tst_x 0,zero
0d3d : 08              >            php         ;save flags
0d3e : e000            >            cpx #0     ;test result
                       >            trap_ne
0d40 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d42 : 68              >            pla         ;load status
0d43 : 48              >            pha
                       >            cmp_flag zero
0d44 : c936            >            cmp #(zero|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0d46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d48 : 28              >            plp         ;restore status
                        
0d49 : 08                       php
0d4a : 88                       dey             ;ff
0d4b : 98                       tya
0d4c : 28                       plp
0d4d : aa                       tax
                                tst_x $ff,minus
0d4e : 08              >            php         ;save flags
0d4f : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0d51 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d53 : 68              >            pla         ;load status
0d54 : 48              >            pha
                       >            cmp_flag minus
0d55 : c9b4            >            cmp #(minus|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
0d57 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d59 : 28              >            plp         ;restore status
                        
                                next_test
0d5a : ad0002          >            lda test_case   ;previous test
0d5d : c90d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0d5f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000e =                 >test_num = test_num + 1
0d61 : a90e            >            lda #test_num   ;*** next tests' number
0d63 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                             
                        ;TSX sets NZ - TXS does not
                        ;  This section also tests for proper stack wrap around.
0d66 : a201                     ldx #1          ;01
                                set_stat $ff
                       >            load_flag $ff
0d68 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0d6a : 48              >            pha         ;use stack to load status
0d6b : 28              >            plp
                        
0d6c : 9a                       txs
0d6d : 08                       php
0d6e : ad0101                   lda $101
                                cmp_flag $ff
0d71 : c9ff            >            cmp #($ff|fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
0d73 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0d75 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0d77 : 48              >            pha         ;use stack to load status
0d78 : 28              >            plp
                        
0d79 : 9a                       txs
0d7a : 08                       php
0d7b : ad0101                   lda $101
                                cmp_flag 0
0d7e : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
0d80 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d82 : ca                       dex             ;00
                                set_stat $ff
                       >            load_flag $ff
0d83 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0d85 : 48              >            pha         ;use stack to load status
0d86 : 28              >            plp
                        
0d87 : 9a                       txs
0d88 : 08                       php
0d89 : ad0001                   lda $100
                                cmp_flag $ff
0d8c : c9ff            >            cmp #($ff|fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
0d8e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0d90 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0d92 : 48              >            pha         ;use stack to load status
0d93 : 28              >            plp
                        
0d94 : 9a                       txs
0d95 : 08                       php
0d96 : ad0001                   lda $100
                                cmp_flag 0
0d99 : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
0d9b : d0fe            >        bne *           ;failed not equal (non zero)
                        
0d9d : ca                       dex             ;ff
                                set_stat $ff
                       >            load_flag $ff
0d9e : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0da0 : 48              >            pha         ;use stack to load status
0da1 : 28              >            plp
                        
0da2 : 9a                       txs
0da3 : 08                       php
0da4 : adff01                   lda $1ff
                                cmp_flag $ff
0da7 : c9ff            >            cmp #($ff|fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
0da9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0dab : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0dad : 48              >            pha         ;use stack to load status
0dae : 28              >            plp
                        
0daf : 9a                       txs
0db0 : 08                       php
0db1 : adff01                   lda $1ff
                                cmp_flag 0
0db4 : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                        
                                
0db6 : a201                     ldx #1
0db8 : 9a                       txs             ;sp=01
                                set_stat $ff
                       >            load_flag $ff
0db9 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0dbb : 48              >            pha         ;use stack to load status
0dbc : 28              >            plp
                        
0dbd : ba                       tsx             ;clears Z, N
0dbe : 08                       php             ;sp=00
0dbf : e001                     cpx #1
                                trap_ne
0dc1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dc3 : ad0101                   lda $101
                                cmp_flag $ff-minus-zero
0dc6 : c97d            >            cmp #($ff-minus-zero|fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
0dc8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0dca : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0dcc : 48              >            pha         ;use stack to load status
0dcd : 28              >            plp
                        
0dce : ba                       tsx             ;clears N, sets Z
0dcf : 08                       php             ;sp=ff
0dd0 : e000                     cpx #0
                                trap_ne
0dd2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dd4 : ad0001                   lda $100
                                cmp_flag $ff-minus
0dd7 : c97f            >            cmp #($ff-minus|fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
0dd9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0ddb : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0ddd : 48              >            pha         ;use stack to load status
0dde : 28              >            plp
                        
0ddf : ba                       tsx             ;clears N, sets Z
0de0 : 08                       php             ;sp=fe
0de1 : e0ff                     cpx #$ff
                                trap_ne
0de3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0de5 : adff01                   lda $1ff
                                cmp_flag $ff-zero
0de8 : c9fd            >            cmp #($ff-zero|fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
0dea : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
0dec : a201                     ldx #1
0dee : 9a                       txs             ;sp=01
                                set_stat 0
                       >            load_flag 0
0def : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0df1 : 48              >            pha         ;use stack to load status
0df2 : 28              >            plp
                        
0df3 : ba                       tsx             ;clears Z, N
0df4 : 08                       php             ;sp=00
0df5 : e001                     cpx #1
                                trap_ne
0df7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0df9 : ad0101                   lda $101
                                cmp_flag 0
0dfc : c934            >            cmp #(0|fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
0dfe : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0e00 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0e02 : 48              >            pha         ;use stack to load status
0e03 : 28              >            plp
                        
0e04 : ba                       tsx             ;clears N, sets Z
0e05 : 08                       php             ;sp=ff
0e06 : e000                     cpx #0
                                trap_ne
0e08 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e0a : ad0001                   lda $100
                                cmp_flag zero
0e0d : c936            >            cmp #(zero|fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
0e0f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0e11 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0e13 : 48              >            pha         ;use stack to load status
0e14 : 28              >            plp
                        
0e15 : ba                       tsx             ;clears N, sets Z
0e16 : 08                       php             ;sp=fe
0e17 : e0ff                     cpx #$ff
                                trap_ne
0e19 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e1b : adff01                   lda $1ff
                                cmp_flag minus
0e1e : c9b4            >            cmp #(minus|fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
0e20 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e22 : 68                       pla             ;sp=ff
                                next_test
0e23 : ad0002          >            lda test_case   ;previous test
0e26 : c90e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0e28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000f =                 >test_num = test_num + 1
0e2a : a90f            >            lda #test_num   ;*** next tests' number
0e2c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; testing index register load & store LDY LDX STY STX all addressing modes
                        ; LDX / STX - zp,y / abs,y
0e2f : a003                     ldy #3
0e31 :                  tldx    
                                set_stat 0
                       >            load_flag 0
0e31 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0e33 : 48              >            pha         ;use stack to load status
0e34 : 28              >            plp
                        
0e35 : b609                     ldx zp1,y
0e37 : 08                       php         ;test stores do not alter flags
0e38 : 8a                       txa
0e39 : 49c3                     eor #$c3
0e3b : 28                       plp
0e3c : 990302                   sta abst,y
0e3f : 08                       php         ;flags after load/store sequence
0e40 : 49c3                     eor #$c3
0e42 : d91702                   cmp abs1,y  ;test result
                                trap_ne
0e45 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e47 : 68                       pla         ;load status
                                eor_flag 0
0e48 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
0e4a : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0e4d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e4f : 88                       dey
0e50 : 10df                     bpl tldx                  
                        
0e52 : a003                     ldy #3
0e54 :                  tldx1   
                                set_stat $ff
                       >            load_flag $ff
0e54 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0e56 : 48              >            pha         ;use stack to load status
0e57 : 28              >            plp
                        
0e58 : b609                     ldx zp1,y
0e5a : 08                       php         ;test stores do not alter flags
0e5b : 8a                       txa
0e5c : 49c3                     eor #$c3
0e5e : 28                       plp
0e5f : 990302                   sta abst,y
0e62 : 08                       php         ;flags after load/store sequence
0e63 : 49c3                     eor #$c3
0e65 : d91702                   cmp abs1,y  ;test result
                                trap_ne
0e68 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e6a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0e6b : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
0e6d : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0e70 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e72 : 88                       dey
0e73 : 10df                     bpl tldx1                  
                        
0e75 : a003                     ldy #3
0e77 :                  tldx2   
                                set_stat 0
                       >            load_flag 0
0e77 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0e79 : 48              >            pha         ;use stack to load status
0e7a : 28              >            plp
                        
0e7b : be1702                   ldx abs1,y
0e7e : 08                       php         ;test stores do not alter flags
0e7f : 8a                       txa
0e80 : 49c3                     eor #$c3
0e82 : aa                       tax
0e83 : 28                       plp
0e84 : 9602                     stx zpt,y
0e86 : 08                       php         ;flags after load/store sequence
0e87 : 49c3                     eor #$c3
0e89 : d90900                   cmp zp1,y   ;test result
                                trap_ne
0e8c : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e8e : 68                       pla         ;load status
                                eor_flag 0
0e8f : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
0e91 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0e94 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e96 : 88                       dey
0e97 : 10de                     bpl tldx2                  
                        
0e99 : a003                     ldy #3
0e9b :                  tldx3   
                                set_stat $ff
                       >            load_flag $ff
0e9b : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0e9d : 48              >            pha         ;use stack to load status
0e9e : 28              >            plp
                        
0e9f : be1702                   ldx abs1,y
0ea2 : 08                       php         ;test stores do not alter flags
0ea3 : 8a                       txa
0ea4 : 49c3                     eor #$c3
0ea6 : aa                       tax
0ea7 : 28                       plp
0ea8 : 9602                     stx zpt,y
0eaa : 08                       php         ;flags after load/store sequence
0eab : 49c3                     eor #$c3
0ead : d90900                   cmp zp1,y   ;test result
                                trap_ne
0eb0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0eb2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0eb3 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
0eb5 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0eb8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0eba : 88                       dey
0ebb : 10de                     bpl tldx3
                                
0ebd : a003                     ldy #3      ;testing store result
0ebf : a200                     ldx #0
0ec1 : b90200           tstx    lda zpt,y
0ec4 : 49c3                     eor #$c3
0ec6 : d90900                   cmp zp1,y
                                trap_ne     ;store to zp data
0ec9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ecb : 9602                     stx zpt,y   ;clear                
0ecd : b90302                   lda abst,y
0ed0 : 49c3                     eor #$c3
0ed2 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
0ed5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ed7 : 8a                       txa
0ed8 : 990302                   sta abst,y  ;clear                
0edb : 88                       dey
0edc : 10e3                     bpl tstx
                                next_test
0ede : ad0002          >            lda test_case   ;previous test
0ee1 : c90f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0ee3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0010 =                 >test_num = test_num + 1
0ee5 : a910            >            lda #test_num   ;*** next tests' number
0ee7 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; indexed wraparound test (only zp should wrap)
0eea : a0fd                     ldy #3+$fa
0eec : b60f             tldx4   ldx zp1-$fa&$ff,y   ;wrap on indexed zp
0eee : 8a                       txa
0eef : 990901                   sta abst-$fa,y      ;no STX abs,y!
0ef2 : 88                       dey
0ef3 : c0fa                     cpy #$fa
0ef5 : b0f5                     bcs tldx4                  
0ef7 : a0fd                     ldy #3+$fa
0ef9 : be1d01           tldx5   ldx abs1-$fa,y      ;no wrap on indexed abs
0efc : 9608                     stx zpt-$fa&$ff,y
0efe : 88                       dey
0eff : c0fa                     cpy #$fa
0f01 : b0f6                     bcs tldx5                  
0f03 : a003                     ldy #3      ;testing wraparound result
0f05 : a200                     ldx #0
0f07 : b90200           tstx1   lda zpt,y
0f0a : d90900                   cmp zp1,y
                                trap_ne     ;store to zp data
0f0d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f0f : 9602                     stx zpt,y   ;clear                
0f11 : b90302                   lda abst,y
0f14 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
0f17 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f19 : 8a                       txa
0f1a : 990302                   sta abst,y  ;clear                
0f1d : 88                       dey
0f1e : 10e7                     bpl tstx1
                                next_test
0f20 : ad0002          >            lda test_case   ;previous test
0f23 : c910            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0f25 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0011 =                 >test_num = test_num + 1
0f27 : a911            >            lda #test_num   ;*** next tests' number
0f29 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; LDY / STY - zp,x / abs,x
0f2c : a203                     ldx #3
0f2e :                  tldy    
                                set_stat 0
                       >            load_flag 0
0f2e : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0f30 : 48              >            pha         ;use stack to load status
0f31 : 28              >            plp
                        
0f32 : b409                     ldy zp1,x
0f34 : 08                       php         ;test stores do not alter flags
0f35 : 98                       tya
0f36 : 49c3                     eor #$c3
0f38 : 28                       plp
0f39 : 9d0302                   sta abst,x
0f3c : 08                       php         ;flags after load/store sequence
0f3d : 49c3                     eor #$c3
0f3f : dd1702                   cmp abs1,x  ;test result
                                trap_ne
0f42 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f44 : 68                       pla         ;load status
                                eor_flag 0
0f45 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
0f47 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0f4a : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f4c : ca                       dex
0f4d : 10df                     bpl tldy                  
                        
0f4f : a203                     ldx #3
0f51 :                  tldy1   
                                set_stat $ff
                       >            load_flag $ff
0f51 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0f53 : 48              >            pha         ;use stack to load status
0f54 : 28              >            plp
                        
0f55 : b409                     ldy zp1,x
0f57 : 08                       php         ;test stores do not alter flags
0f58 : 98                       tya
0f59 : 49c3                     eor #$c3
0f5b : 28                       plp
0f5c : 9d0302                   sta abst,x
0f5f : 08                       php         ;flags after load/store sequence
0f60 : 49c3                     eor #$c3
0f62 : dd1702                   cmp abs1,x  ;test result
                                trap_ne
0f65 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f67 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0f68 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
0f6a : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0f6d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f6f : ca                       dex
0f70 : 10df                     bpl tldy1                  
                        
0f72 : a203                     ldx #3
0f74 :                  tldy2   
                                set_stat 0
                       >            load_flag 0
0f74 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
0f76 : 48              >            pha         ;use stack to load status
0f77 : 28              >            plp
                        
0f78 : bc1702                   ldy abs1,x
0f7b : 08                       php         ;test stores do not alter flags
0f7c : 98                       tya
0f7d : 49c3                     eor #$c3
0f7f : a8                       tay
0f80 : 28                       plp
0f81 : 9402                     sty zpt,x
0f83 : 08                       php         ;flags after load/store sequence
0f84 : 49c3                     eor #$c3
0f86 : d509                     cmp zp1,x   ;test result
                                trap_ne
0f88 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f8a : 68                       pla         ;load status
                                eor_flag 0
0f8b : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
0f8d : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0f90 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f92 : ca                       dex
0f93 : 10df                     bpl tldy2                  
                        
0f95 : a203                     ldx #3
0f97 :                  tldy3
                                set_stat $ff
                       >            load_flag $ff
0f97 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
0f99 : 48              >            pha         ;use stack to load status
0f9a : 28              >            plp
                        
0f9b : bc1702                   ldy abs1,x
0f9e : 08                       php         ;test stores do not alter flags
0f9f : 98                       tya
0fa0 : 49c3                     eor #$c3
0fa2 : a8                       tay
0fa3 : 28                       plp
0fa4 : 9402                     sty zpt,x
0fa6 : 08                       php         ;flags after load/store sequence
0fa7 : 49c3                     eor #$c3
0fa9 : d509                     cmp zp1,x   ;test result
                                trap_ne
0fab : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fad : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0fae : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
0fb0 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0fb3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fb5 : ca                       dex
0fb6 : 10df                     bpl tldy3
                        
0fb8 : a203                     ldx #3      ;testing store result
0fba : a000                     ldy #0
0fbc : b502             tsty    lda zpt,x
0fbe : 49c3                     eor #$c3
0fc0 : d509                     cmp zp1,x
                                trap_ne     ;store to zp,x data
0fc2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fc4 : 9402                     sty zpt,x   ;clear                
0fc6 : bd0302                   lda abst,x
0fc9 : 49c3                     eor #$c3
0fcb : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
0fce : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fd0 : 8a                       txa
0fd1 : 9d0302                   sta abst,x  ;clear                
0fd4 : ca                       dex
0fd5 : 10e5                     bpl tsty
                                next_test
0fd7 : ad0002          >            lda test_case   ;previous test
0fda : c911            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0fdc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0012 =                 >test_num = test_num + 1
0fde : a912            >            lda #test_num   ;*** next tests' number
0fe0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
0fe3 : a2fd                     ldx #3+$fa
0fe5 : b40f             tldy4   ldy zp1-$fa&$ff,x   ;wrap on indexed zp
0fe7 : 98                       tya
0fe8 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
0feb : ca                       dex
0fec : e0fa                     cpx #$fa
0fee : b0f5                     bcs tldy4                  
0ff0 : a2fd                     ldx #3+$fa
0ff2 : bc1d01           tldy5   ldy abs1-$fa,x      ;no wrap on indexed abs
0ff5 : 9408                     sty zpt-$fa&$ff,x
0ff7 : ca                       dex
0ff8 : e0fa                     cpx #$fa
0ffa : b0f6                     bcs tldy5                  
0ffc : a203                     ldx #3      ;testing wraparound result
0ffe : a000                     ldy #0
1000 : b502             tsty1   lda zpt,x
1002 : d509                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1004 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1006 : 9402                     sty zpt,x   ;clear                
1008 : bd0302                   lda abst,x
100b : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
100e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1010 : 8a                       txa
1011 : 9d0302                   sta abst,x  ;clear                
1014 : ca                       dex
1015 : 10e9                     bpl tsty1
                                next_test
1017 : ad0002          >            lda test_case   ;previous test
101a : c912            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
101c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0013 =                 >test_num = test_num + 1
101e : a913            >            lda #test_num   ;*** next tests' number
1020 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDX / STX - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
1023 : a904            >            lda #0  |intdis      ;force disable interrupts
                       >
1025 : 48              >            pha         ;use stack to load status
1026 : 28              >            plp
                        
1027 : a609                     ldx zp1
1029 : 08                       php         ;test stores do not alter flags
102a : 8a                       txa
102b : 49c3                     eor #$c3
102d : aa                       tax
102e : 28                       plp
102f : 8e0302                   stx abst
1032 : 08                       php         ;flags after load/store sequence
1033 : 49c3                     eor #$c3
1035 : aa                       tax
1036 : e0c3                     cpx #$c3    ;test result
                                trap_ne
1038 : d0fe            >        bne *           ;failed not equal (non zero)
                        
103a : 68                       pla         ;load status
                                eor_flag 0
103b : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
103d : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1040 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1042 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1044 : 48              >            pha         ;use stack to load status
1045 : 28              >            plp
                        
1046 : a60a                     ldx zp1+1
1048 : 08                       php         ;test stores do not alter flags
1049 : 8a                       txa
104a : 49c3                     eor #$c3
104c : aa                       tax
104d : 28                       plp
104e : 8e0402                   stx abst+1
1051 : 08                       php         ;flags after load/store sequence
1052 : 49c3                     eor #$c3
1054 : aa                       tax
1055 : e082                     cpx #$82    ;test result
                                trap_ne
1057 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1059 : 68                       pla         ;load status
                                eor_flag 0
105a : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
105c : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
105f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1061 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1063 : 48              >            pha         ;use stack to load status
1064 : 28              >            plp
                        
1065 : a60b                     ldx zp1+2
1067 : 08                       php         ;test stores do not alter flags
1068 : 8a                       txa
1069 : 49c3                     eor #$c3
106b : aa                       tax
106c : 28                       plp
106d : 8e0502                   stx abst+2
1070 : 08                       php         ;flags after load/store sequence
1071 : 49c3                     eor #$c3
1073 : aa                       tax
1074 : e041                     cpx #$41    ;test result
                                trap_ne
1076 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1078 : 68                       pla         ;load status
                                eor_flag 0
1079 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
107b : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
107e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1080 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1082 : 48              >            pha         ;use stack to load status
1083 : 28              >            plp
                        
1084 : a60c                     ldx zp1+3
1086 : 08                       php         ;test stores do not alter flags
1087 : 8a                       txa
1088 : 49c3                     eor #$c3
108a : aa                       tax
108b : 28                       plp
108c : 8e0602                   stx abst+3
108f : 08                       php         ;flags after load/store sequence
1090 : 49c3                     eor #$c3
1092 : aa                       tax
1093 : e000                     cpx #0      ;test result
                                trap_ne
1095 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1097 : 68                       pla         ;load status
                                eor_flag 0
1098 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
109a : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
109d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
109f : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
10a1 : 48              >            pha         ;use stack to load status
10a2 : 28              >            plp
                        
10a3 : a609                     ldx zp1  
10a5 : 08                       php         ;test stores do not alter flags
10a6 : 8a                       txa
10a7 : 49c3                     eor #$c3
10a9 : aa                       tax
10aa : 28                       plp
10ab : 8e0302                   stx abst  
10ae : 08                       php         ;flags after load/store sequence
10af : 49c3                     eor #$c3
10b1 : aa                       tax
10b2 : e0c3                     cpx #$c3    ;test result
                                trap_ne     ;
10b4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10b6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10b7 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
10b9 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
10bc : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10be : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
10c0 : 48              >            pha         ;use stack to load status
10c1 : 28              >            plp
                        
10c2 : a60a                     ldx zp1+1
10c4 : 08                       php         ;test stores do not alter flags
10c5 : 8a                       txa
10c6 : 49c3                     eor #$c3
10c8 : aa                       tax
10c9 : 28                       plp
10ca : 8e0402                   stx abst+1
10cd : 08                       php         ;flags after load/store sequence
10ce : 49c3                     eor #$c3
10d0 : aa                       tax
10d1 : e082                     cpx #$82    ;test result
                                trap_ne
10d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10d5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10d6 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
10d8 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
10db : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10dd : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
10df : 48              >            pha         ;use stack to load status
10e0 : 28              >            plp
                        
10e1 : a60b                     ldx zp1+2
10e3 : 08                       php         ;test stores do not alter flags
10e4 : 8a                       txa
10e5 : 49c3                     eor #$c3
10e7 : aa                       tax
10e8 : 28                       plp
10e9 : 8e0502                   stx abst+2
10ec : 08                       php         ;flags after load/store sequence
10ed : 49c3                     eor #$c3
10ef : aa                       tax
10f0 : e041                     cpx #$41    ;test result
                                trap_ne     ;
10f2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10f4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10f5 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
10f7 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
10fa : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
10fc : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
10fe : 48              >            pha         ;use stack to load status
10ff : 28              >            plp
                        
1100 : a60c                     ldx zp1+3
1102 : 08                       php         ;test stores do not alter flags
1103 : 8a                       txa
1104 : 49c3                     eor #$c3
1106 : aa                       tax
1107 : 28                       plp
1108 : 8e0602                   stx abst+3
110b : 08                       php         ;flags after load/store sequence
110c : 49c3                     eor #$c3
110e : aa                       tax
110f : e000                     cpx #0      ;test result
                                trap_ne
1111 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1113 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1114 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1116 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1119 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
111b : a904            >            lda #0|intdis      ;force disable interrupts
                       >
111d : 48              >            pha         ;use stack to load status
111e : 28              >            plp
                        
111f : ae1702                   ldx abs1  
1122 : 08                       php         ;test stores do not alter flags
1123 : 8a                       txa
1124 : 49c3                     eor #$c3
1126 : aa                       tax
1127 : 28                       plp
1128 : 8602                     stx zpt  
112a : 08                       php         ;flags after load/store sequence
112b : 49c3                     eor #$c3
112d : c509                     cmp zp1     ;test result
                                trap_ne
112f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1131 : 68                       pla         ;load status
                                eor_flag 0
1132 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1134 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1137 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1139 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
113b : 48              >            pha         ;use stack to load status
113c : 28              >            plp
                        
113d : ae1802                   ldx abs1+1
1140 : 08                       php         ;test stores do not alter flags
1141 : 8a                       txa
1142 : 49c3                     eor #$c3
1144 : aa                       tax
1145 : 28                       plp
1146 : 8603                     stx zpt+1
1148 : 08                       php         ;flags after load/store sequence
1149 : 49c3                     eor #$c3
114b : c50a                     cmp zp1+1   ;test result
                                trap_ne
114d : d0fe            >        bne *           ;failed not equal (non zero)
                        
114f : 68                       pla         ;load status
                                eor_flag 0
1150 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1152 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1155 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1157 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1159 : 48              >            pha         ;use stack to load status
115a : 28              >            plp
                        
115b : ae1902                   ldx abs1+2
115e : 08                       php         ;test stores do not alter flags
115f : 8a                       txa
1160 : 49c3                     eor #$c3
1162 : aa                       tax
1163 : 28                       plp
1164 : 8604                     stx zpt+2
1166 : 08                       php         ;flags after load/store sequence
1167 : 49c3                     eor #$c3
1169 : c50b                     cmp zp1+2   ;test result
                                trap_ne
116b : d0fe            >        bne *           ;failed not equal (non zero)
                        
116d : 68                       pla         ;load status
                                eor_flag 0
116e : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1170 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1173 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1175 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1177 : 48              >            pha         ;use stack to load status
1178 : 28              >            plp
                        
1179 : ae1a02                   ldx abs1+3
117c : 08                       php         ;test stores do not alter flags
117d : 8a                       txa
117e : 49c3                     eor #$c3
1180 : aa                       tax
1181 : 28                       plp
1182 : 8605                     stx zpt+3
1184 : 08                       php         ;flags after load/store sequence
1185 : 49c3                     eor #$c3
1187 : c50c                     cmp zp1+3   ;test result
                                trap_ne
1189 : d0fe            >        bne *           ;failed not equal (non zero)
                        
118b : 68                       pla         ;load status
                                eor_flag 0
118c : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
118e : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1191 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1193 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1195 : 48              >            pha         ;use stack to load status
1196 : 28              >            plp
                        
1197 : ae1702                   ldx abs1  
119a : 08                       php         ;test stores do not alter flags
119b : 8a                       txa
119c : 49c3                     eor #$c3
119e : aa                       tax
119f : 28                       plp
11a0 : 8602                     stx zpt  
11a2 : 08                       php         ;flags after load/store sequence
11a3 : 49c3                     eor #$c3
11a5 : aa                       tax
11a6 : e409                     cpx zp1     ;test result
                                trap_ne
11a8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11aa : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11ab : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
11ad : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
11b0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11b2 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
11b4 : 48              >            pha         ;use stack to load status
11b5 : 28              >            plp
                        
11b6 : ae1802                   ldx abs1+1
11b9 : 08                       php         ;test stores do not alter flags
11ba : 8a                       txa
11bb : 49c3                     eor #$c3
11bd : aa                       tax
11be : 28                       plp
11bf : 8603                     stx zpt+1
11c1 : 08                       php         ;flags after load/store sequence
11c2 : 49c3                     eor #$c3
11c4 : aa                       tax
11c5 : e40a                     cpx zp1+1   ;test result
                                trap_ne
11c7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11c9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11ca : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
11cc : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
11cf : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11d1 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
11d3 : 48              >            pha         ;use stack to load status
11d4 : 28              >            plp
                        
11d5 : ae1902                   ldx abs1+2
11d8 : 08                       php         ;test stores do not alter flags
11d9 : 8a                       txa
11da : 49c3                     eor #$c3
11dc : aa                       tax
11dd : 28                       plp
11de : 8604                     stx zpt+2
11e0 : 08                       php         ;flags after load/store sequence
11e1 : 49c3                     eor #$c3
11e3 : aa                       tax
11e4 : e40b                     cpx zp1+2   ;test result
                                trap_ne
11e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11e8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11e9 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
11eb : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
11ee : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11f0 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
11f2 : 48              >            pha         ;use stack to load status
11f3 : 28              >            plp
                        
11f4 : ae1a02                   ldx abs1+3
11f7 : 08                       php         ;test stores do not alter flags
11f8 : 8a                       txa
11f9 : 49c3                     eor #$c3
11fb : aa                       tax
11fc : 28                       plp
11fd : 8605                     stx zpt+3
11ff : 08                       php         ;flags after load/store sequence
1200 : 49c3                     eor #$c3
1202 : aa                       tax
1203 : e40c                     cpx zp1+3   ;test result
                                trap_ne
1205 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1207 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1208 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
120a : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
120d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0  
                       >            load_flag 0  
120f : a904            >            lda #0  |intdis      ;force disable interrupts
                       >
1211 : 48              >            pha         ;use stack to load status
1212 : 28              >            plp
                        
1213 : a2c3                     ldx #$c3
1215 : 08                       php
1216 : ec1702                   cpx abs1    ;test result
                                trap_ne
1219 : d0fe            >        bne *           ;failed not equal (non zero)
                        
121b : 68                       pla         ;load status
                                eor_flag 0
121c : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
121e : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1221 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1223 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1225 : 48              >            pha         ;use stack to load status
1226 : 28              >            plp
                        
1227 : a282                     ldx #$82
1229 : 08                       php
122a : ec1802                   cpx abs1+1  ;test result
                                trap_ne
122d : d0fe            >        bne *           ;failed not equal (non zero)
                        
122f : 68                       pla         ;load status
                                eor_flag 0
1230 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1232 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1235 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1237 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1239 : 48              >            pha         ;use stack to load status
123a : 28              >            plp
                        
123b : a241                     ldx #$41
123d : 08                       php
123e : ec1902                   cpx abs1+2  ;test result
                                trap_ne
1241 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1243 : 68                       pla         ;load status
                                eor_flag 0
1244 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1246 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1249 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
124b : a904            >            lda #0|intdis      ;force disable interrupts
                       >
124d : 48              >            pha         ;use stack to load status
124e : 28              >            plp
                        
124f : a200                     ldx #0
1251 : 08                       php
1252 : ec1a02                   cpx abs1+3  ;test result
                                trap_ne
1255 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1257 : 68                       pla         ;load status
                                eor_flag 0
1258 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
125a : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
125d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
125f : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1261 : 48              >            pha         ;use stack to load status
1262 : 28              >            plp
                        
1263 : a2c3                     ldx #$c3  
1265 : 08                       php
1266 : ec1702                   cpx abs1    ;test result
                                trap_ne
1269 : d0fe            >        bne *           ;failed not equal (non zero)
                        
126b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
126c : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
126e : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1271 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1273 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1275 : 48              >            pha         ;use stack to load status
1276 : 28              >            plp
                        
1277 : a282                     ldx #$82
1279 : 08                       php
127a : ec1802                   cpx abs1+1  ;test result
                                trap_ne
127d : d0fe            >        bne *           ;failed not equal (non zero)
                        
127f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1280 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1282 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1285 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1287 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1289 : 48              >            pha         ;use stack to load status
128a : 28              >            plp
                        
128b : a241                     ldx #$41
128d : 08                       php
128e : ec1902                   cpx abs1+2  ;test result
                                trap_ne
1291 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1293 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1294 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1296 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1299 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
129b : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
129d : 48              >            pha         ;use stack to load status
129e : 28              >            plp
                        
129f : a200                     ldx #0
12a1 : 08                       php
12a2 : ec1a02                   cpx abs1+3  ;test result
                                trap_ne
12a5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12a7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12a8 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
12aa : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
12ad : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
12af : a200                     ldx #0
12b1 : a502                     lda zpt  
12b3 : 49c3                     eor #$c3
12b5 : c509                     cmp zp1  
                                trap_ne     ;store to zp data
12b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12b9 : 8602                     stx zpt     ;clear                
12bb : ad0302                   lda abst  
12be : 49c3                     eor #$c3
12c0 : cd1702                   cmp abs1  
                                trap_ne     ;store to abs data
12c3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12c5 : 8e0302                   stx abst    ;clear                
12c8 : a503                     lda zpt+1
12ca : 49c3                     eor #$c3
12cc : c50a                     cmp zp1+1
                                trap_ne     ;store to zp data
12ce : d0fe            >        bne *           ;failed not equal (non zero)
                        
12d0 : 8603                     stx zpt+1   ;clear                
12d2 : ad0402                   lda abst+1
12d5 : 49c3                     eor #$c3
12d7 : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs data
12da : d0fe            >        bne *           ;failed not equal (non zero)
                        
12dc : 8e0402                   stx abst+1  ;clear                
12df : a504                     lda zpt+2
12e1 : 49c3                     eor #$c3
12e3 : c50b                     cmp zp1+2
                                trap_ne     ;store to zp data
12e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12e7 : 8604                     stx zpt+2   ;clear                
12e9 : ad0502                   lda abst+2
12ec : 49c3                     eor #$c3
12ee : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs data
12f1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12f3 : 8e0502                   stx abst+2  ;clear                
12f6 : a505                     lda zpt+3
12f8 : 49c3                     eor #$c3
12fa : c50c                     cmp zp1+3
                                trap_ne     ;store to zp data
12fc : d0fe            >        bne *           ;failed not equal (non zero)
                        
12fe : 8605                     stx zpt+3   ;clear                
1300 : ad0602                   lda abst+3
1303 : 49c3                     eor #$c3
1305 : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs data
1308 : d0fe            >        bne *           ;failed not equal (non zero)
                        
130a : 8e0602                   stx abst+3  ;clear                
                                next_test
130d : ad0002          >            lda test_case   ;previous test
1310 : c913            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1312 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0014 =                 >test_num = test_num + 1
1314 : a914            >            lda #test_num   ;*** next tests' number
1316 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp / abs / #
                                set_stat 0
                       >            load_flag 0
1319 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
131b : 48              >            pha         ;use stack to load status
131c : 28              >            plp
                        
131d : a409                     ldy zp1  
131f : 08                       php         ;test stores do not alter flags
1320 : 98                       tya
1321 : 49c3                     eor #$c3
1323 : a8                       tay
1324 : 28                       plp
1325 : 8c0302                   sty abst  
1328 : 08                       php         ;flags after load/store sequence
1329 : 49c3                     eor #$c3
132b : a8                       tay
132c : c0c3                     cpy #$c3    ;test result
                                trap_ne
132e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1330 : 68                       pla         ;load status
                                eor_flag 0
1331 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1333 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1336 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1338 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
133a : 48              >            pha         ;use stack to load status
133b : 28              >            plp
                        
133c : a40a                     ldy zp1+1
133e : 08                       php         ;test stores do not alter flags
133f : 98                       tya
1340 : 49c3                     eor #$c3
1342 : a8                       tay
1343 : 28                       plp
1344 : 8c0402                   sty abst+1
1347 : 08                       php         ;flags after load/store sequence
1348 : 49c3                     eor #$c3
134a : a8                       tay
134b : c082                     cpy #$82    ;test result
                                trap_ne
134d : d0fe            >        bne *           ;failed not equal (non zero)
                        
134f : 68                       pla         ;load status
                                eor_flag 0
1350 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1352 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1355 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1357 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1359 : 48              >            pha         ;use stack to load status
135a : 28              >            plp
                        
135b : a40b                     ldy zp1+2
135d : 08                       php         ;test stores do not alter flags
135e : 98                       tya
135f : 49c3                     eor #$c3
1361 : a8                       tay
1362 : 28                       plp
1363 : 8c0502                   sty abst+2
1366 : 08                       php         ;flags after load/store sequence
1367 : 49c3                     eor #$c3
1369 : a8                       tay
136a : c041                     cpy #$41    ;test result
                                trap_ne
136c : d0fe            >        bne *           ;failed not equal (non zero)
                        
136e : 68                       pla         ;load status
                                eor_flag 0
136f : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1371 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1374 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1376 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1378 : 48              >            pha         ;use stack to load status
1379 : 28              >            plp
                        
137a : a40c                     ldy zp1+3
137c : 08                       php         ;test stores do not alter flags
137d : 98                       tya
137e : 49c3                     eor #$c3
1380 : a8                       tay
1381 : 28                       plp
1382 : 8c0602                   sty abst+3
1385 : 08                       php         ;flags after load/store sequence
1386 : 49c3                     eor #$c3
1388 : a8                       tay
1389 : c000                     cpy #0      ;test result
                                trap_ne
138b : d0fe            >        bne *           ;failed not equal (non zero)
                        
138d : 68                       pla         ;load status
                                eor_flag 0
138e : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1390 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1393 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1395 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1397 : 48              >            pha         ;use stack to load status
1398 : 28              >            plp
                        
1399 : a409                     ldy zp1  
139b : 08                       php         ;test stores do not alter flags
139c : 98                       tya
139d : 49c3                     eor #$c3
139f : a8                       tay
13a0 : 28                       plp
13a1 : 8c0302                   sty abst  
13a4 : 08                       php         ;flags after load/store sequence
13a5 : 49c3                     eor #$c3
13a7 : a8                       tay
13a8 : c0c3                     cpy #$c3    ;test result
                                trap_ne
13aa : d0fe            >        bne *           ;failed not equal (non zero)
                        
13ac : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13ad : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
13af : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
13b2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13b4 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
13b6 : 48              >            pha         ;use stack to load status
13b7 : 28              >            plp
                        
13b8 : a40a                     ldy zp1+1
13ba : 08                       php         ;test stores do not alter flags
13bb : 98                       tya
13bc : 49c3                     eor #$c3
13be : a8                       tay
13bf : 28                       plp
13c0 : 8c0402                   sty abst+1
13c3 : 08                       php         ;flags after load/store sequence
13c4 : 49c3                     eor #$c3
13c6 : a8                       tay
13c7 : c082                     cpy #$82   ;test result
                                trap_ne
13c9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13cb : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13cc : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
13ce : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
13d1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13d3 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
13d5 : 48              >            pha         ;use stack to load status
13d6 : 28              >            plp
                        
13d7 : a40b                     ldy zp1+2
13d9 : 08                       php         ;test stores do not alter flags
13da : 98                       tya
13db : 49c3                     eor #$c3
13dd : a8                       tay
13de : 28                       plp
13df : 8c0502                   sty abst+2
13e2 : 08                       php         ;flags after load/store sequence
13e3 : 49c3                     eor #$c3
13e5 : a8                       tay
13e6 : c041                     cpy #$41    ;test result
                                trap_ne
13e8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13ea : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13eb : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
13ed : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
13f0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13f2 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
13f4 : 48              >            pha         ;use stack to load status
13f5 : 28              >            plp
                        
13f6 : a40c                     ldy zp1+3
13f8 : 08                       php         ;test stores do not alter flags
13f9 : 98                       tya
13fa : 49c3                     eor #$c3
13fc : a8                       tay
13fd : 28                       plp
13fe : 8c0602                   sty abst+3
1401 : 08                       php         ;flags after load/store sequence
1402 : 49c3                     eor #$c3
1404 : a8                       tay
1405 : c000                     cpy #0      ;test result
                                trap_ne
1407 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1409 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
140a : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
140c : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
140f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
                                set_stat 0
                       >            load_flag 0
1411 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1413 : 48              >            pha         ;use stack to load status
1414 : 28              >            plp
                        
1415 : ac1702                   ldy abs1  
1418 : 08                       php         ;test stores do not alter flags
1419 : 98                       tya
141a : 49c3                     eor #$c3
141c : a8                       tay
141d : 28                       plp
141e : 8402                     sty zpt  
1420 : 08                       php         ;flags after load/store sequence
1421 : 49c3                     eor #$c3
1423 : a8                       tay
1424 : c409                     cpy zp1     ;test result
                                trap_ne
1426 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1428 : 68                       pla         ;load status
                                eor_flag 0
1429 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
142b : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
142e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1430 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1432 : 48              >            pha         ;use stack to load status
1433 : 28              >            plp
                        
1434 : ac1802                   ldy abs1+1
1437 : 08                       php         ;test stores do not alter flags
1438 : 98                       tya
1439 : 49c3                     eor #$c3
143b : a8                       tay
143c : 28                       plp
143d : 8403                     sty zpt+1
143f : 08                       php         ;flags after load/store sequence
1440 : 49c3                     eor #$c3
1442 : a8                       tay
1443 : c40a                     cpy zp1+1   ;test result
                                trap_ne
1445 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1447 : 68                       pla         ;load status
                                eor_flag 0
1448 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
144a : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
144d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
144f : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1451 : 48              >            pha         ;use stack to load status
1452 : 28              >            plp
                        
1453 : ac1902                   ldy abs1+2
1456 : 08                       php         ;test stores do not alter flags
1457 : 98                       tya
1458 : 49c3                     eor #$c3
145a : a8                       tay
145b : 28                       plp
145c : 8404                     sty zpt+2
145e : 08                       php         ;flags after load/store sequence
145f : 49c3                     eor #$c3
1461 : a8                       tay
1462 : c40b                     cpy zp1+2   ;test result
                                trap_ne
1464 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1466 : 68                       pla         ;load status
                                eor_flag 0
1467 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1469 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
146c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
146e : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1470 : 48              >            pha         ;use stack to load status
1471 : 28              >            plp
                        
1472 : ac1a02                   ldy abs1+3
1475 : 08                       php         ;test stores do not alter flags
1476 : 98                       tya
1477 : 49c3                     eor #$c3
1479 : a8                       tay
147a : 28                       plp
147b : 8405                     sty zpt+3
147d : 08                       php         ;flags after load/store sequence
147e : 49c3                     eor #$c3
1480 : a8                       tay
1481 : c40c                     cpy zp1+3   ;test result
                                trap_ne
1483 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1485 : 68                       pla         ;load status
                                eor_flag 0
1486 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1488 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
148b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
148d : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
148f : 48              >            pha         ;use stack to load status
1490 : 28              >            plp
                        
1491 : ac1702                   ldy abs1  
1494 : 08                       php         ;test stores do not alter flags
1495 : 98                       tya
1496 : 49c3                     eor #$c3
1498 : a8                       tay
1499 : 28                       plp
149a : 8402                     sty zpt  
149c : 08                       php         ;flags after load/store sequence
149d : 49c3                     eor #$c3
149f : a8                       tay
14a0 : c509                     cmp zp1     ;test result
                                trap_ne
14a2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14a4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14a5 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
14a7 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
14aa : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
14ac : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
14ae : 48              >            pha         ;use stack to load status
14af : 28              >            plp
                        
14b0 : ac1802                   ldy abs1+1
14b3 : 08                       php         ;test stores do not alter flags
14b4 : 98                       tya
14b5 : 49c3                     eor #$c3
14b7 : a8                       tay
14b8 : 28                       plp
14b9 : 8403                     sty zpt+1
14bb : 08                       php         ;flags after load/store sequence
14bc : 49c3                     eor #$c3
14be : a8                       tay
14bf : c50a                     cmp zp1+1   ;test result
                                trap_ne
14c1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14c3 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14c4 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
14c6 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
14c9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
14cb : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
14cd : 48              >            pha         ;use stack to load status
14ce : 28              >            plp
                        
14cf : ac1902                   ldy abs1+2
14d2 : 08                       php         ;test stores do not alter flags
14d3 : 98                       tya
14d4 : 49c3                     eor #$c3
14d6 : a8                       tay
14d7 : 28                       plp
14d8 : 8404                     sty zpt+2
14da : 08                       php         ;flags after load/store sequence
14db : 49c3                     eor #$c3
14dd : a8                       tay
14de : c50b                     cmp zp1+2   ;test result
                                trap_ne
14e0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14e2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14e3 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
14e5 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
14e8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
14ea : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
14ec : 48              >            pha         ;use stack to load status
14ed : 28              >            plp
                        
14ee : ac1a02                   ldy abs1+3
14f1 : 08                       php         ;test stores do not alter flags
14f2 : 98                       tya
14f3 : 49c3                     eor #$c3
14f5 : a8                       tay
14f6 : 28                       plp
14f7 : 8405                     sty zpt+3
14f9 : 08                       php         ;flags after load/store sequence
14fa : 49c3                     eor #$c3
14fc : a8                       tay
14fd : c50c                     cmp zp1+3   ;test result
                                trap_ne
14ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
1501 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1502 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1504 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1507 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                        
                                set_stat 0
                       >            load_flag 0
1509 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
150b : 48              >            pha         ;use stack to load status
150c : 28              >            plp
                        
150d : a0c3                     ldy #$c3  
150f : 08                       php
1510 : cc1702                   cpy abs1    ;test result
                                trap_ne
1513 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1515 : 68                       pla         ;load status
                                eor_flag 0
1516 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1518 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
151b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
151d : a904            >            lda #0|intdis      ;force disable interrupts
                       >
151f : 48              >            pha         ;use stack to load status
1520 : 28              >            plp
                        
1521 : a082                     ldy #$82
1523 : 08                       php
1524 : cc1802                   cpy abs1+1  ;test result
                                trap_ne
1527 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1529 : 68                       pla         ;load status
                                eor_flag 0
152a : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
152c : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
152f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1531 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1533 : 48              >            pha         ;use stack to load status
1534 : 28              >            plp
                        
1535 : a041                     ldy #$41
1537 : 08                       php
1538 : cc1902                   cpy abs1+2  ;test result
                                trap_ne
153b : d0fe            >        bne *           ;failed not equal (non zero)
                        
153d : 68                       pla         ;load status
                                eor_flag 0
153e : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1540 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1543 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1545 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1547 : 48              >            pha         ;use stack to load status
1548 : 28              >            plp
                        
1549 : a000                     ldy #0
154b : 08                       php
154c : cc1a02                   cpy abs1+3  ;test result
                                trap_ne
154f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1551 : 68                       pla         ;load status
                                eor_flag 0
1552 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1554 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1557 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1559 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
155b : 48              >            pha         ;use stack to load status
155c : 28              >            plp
                        
155d : a0c3                     ldy #$c3  
155f : 08                       php
1560 : cc1702                   cpy abs1    ;test result
                                trap_ne
1563 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1565 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1566 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1568 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
156b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
156d : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
156f : 48              >            pha         ;use stack to load status
1570 : 28              >            plp
                        
1571 : a082                     ldy #$82
1573 : 08                       php
1574 : cc1802                   cpy abs1+1  ;test result
                                trap_ne
1577 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1579 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
157a : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
157c : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
157f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1581 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1583 : 48              >            pha         ;use stack to load status
1584 : 28              >            plp
                        
1585 : a041                     ldy #$41
1587 : 08                       php
1588 : cc1902                   cpy abs1+2   ;test result
                                trap_ne
158b : d0fe            >        bne *           ;failed not equal (non zero)
                        
158d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
158e : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1590 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1593 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1595 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1597 : 48              >            pha         ;use stack to load status
1598 : 28              >            plp
                        
1599 : a000                     ldy #0
159b : 08                       php
159c : cc1a02                   cpy abs1+3  ;test result
                                trap_ne
159f : d0fe            >        bne *           ;failed not equal (non zero)
                        
15a1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15a2 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
15a4 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
15a7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
15a9 : a000                     ldy #0
15ab : a502                     lda zpt  
15ad : 49c3                     eor #$c3
15af : c509                     cmp zp1  
                                trap_ne     ;store to zp   data
15b1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15b3 : 8402                     sty zpt     ;clear                
15b5 : ad0302                   lda abst  
15b8 : 49c3                     eor #$c3
15ba : cd1702                   cmp abs1  
                                trap_ne     ;store to abs   data
15bd : d0fe            >        bne *           ;failed not equal (non zero)
                        
15bf : 8c0302                   sty abst    ;clear                
15c2 : a503                     lda zpt+1
15c4 : 49c3                     eor #$c3
15c6 : c50a                     cmp zp1+1
                                trap_ne     ;store to zp+1 data
15c8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15ca : 8403                     sty zpt+1   ;clear                
15cc : ad0402                   lda abst+1
15cf : 49c3                     eor #$c3
15d1 : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs+1 data
15d4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15d6 : 8c0402                   sty abst+1  ;clear                
15d9 : a504                     lda zpt+2
15db : 49c3                     eor #$c3
15dd : c50b                     cmp zp1+2
                                trap_ne     ;store to zp+2 data
15df : d0fe            >        bne *           ;failed not equal (non zero)
                        
15e1 : 8404                     sty zpt+2   ;clear                
15e3 : ad0502                   lda abst+2
15e6 : 49c3                     eor #$c3
15e8 : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs+2 data
15eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
15ed : 8c0502                   sty abst+2  ;clear                
15f0 : a505                     lda zpt+3
15f2 : 49c3                     eor #$c3
15f4 : c50c                     cmp zp1+3
                                trap_ne     ;store to zp+3 data
15f6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15f8 : 8405                     sty zpt+3   ;clear                
15fa : ad0602                   lda abst+3
15fd : 49c3                     eor #$c3
15ff : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs+3 data
1602 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1604 : 8c0602                   sty abst+3  ;clear                
                                next_test
1607 : ad0002          >            lda test_case   ;previous test
160a : c914            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
160c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0015 =                 >test_num = test_num + 1
160e : a915            >            lda #test_num   ;*** next tests' number
1610 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing load / store accumulator LDA / STA all addressing modes
                        ; LDA / STA - zp,x / abs,x
1613 : a203                     ldx #3
1615 :                  tldax    
                                set_stat 0
                       >            load_flag 0
1615 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1617 : 48              >            pha         ;use stack to load status
1618 : 28              >            plp
                        
1619 : b509                     lda zp1,x
161b : 08                       php         ;test stores do not alter flags
161c : 49c3                     eor #$c3
161e : 28                       plp
161f : 9d0302                   sta abst,x
1622 : 08                       php         ;flags after load/store sequence
1623 : 49c3                     eor #$c3
1625 : dd1702                   cmp abs1,x  ;test result
                                trap_ne
1628 : d0fe            >        bne *           ;failed not equal (non zero)
                        
162a : 68                       pla         ;load status
                                eor_flag 0
162b : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
162d : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1630 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1632 : ca                       dex
1633 : 10e0                     bpl tldax                  
                        
1635 : a203                     ldx #3
1637 :                  tldax1   
                                set_stat $ff
                       >            load_flag $ff
1637 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1639 : 48              >            pha         ;use stack to load status
163a : 28              >            plp
                        
163b : b509                     lda zp1,x
163d : 08                       php         ;test stores do not alter flags
163e : 49c3                     eor #$c3
1640 : 28                       plp
1641 : 9d0302                   sta abst,x
1644 : 08                       php         ;flags after load/store sequence
1645 : 49c3                     eor #$c3
1647 : dd1702                   cmp abs1,x   ;test result
                                trap_ne
164a : d0fe            >        bne *           ;failed not equal (non zero)
                        
164c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
164d : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
164f : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1652 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1654 : ca                       dex
1655 : 10e0                     bpl tldax1                  
                        
1657 : a203                     ldx #3
1659 :                  tldax2   
                                set_stat 0
                       >            load_flag 0
1659 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
165b : 48              >            pha         ;use stack to load status
165c : 28              >            plp
                        
165d : bd1702                   lda abs1,x
1660 : 08                       php         ;test stores do not alter flags
1661 : 49c3                     eor #$c3
1663 : 28                       plp
1664 : 9502                     sta zpt,x
1666 : 08                       php         ;flags after load/store sequence
1667 : 49c3                     eor #$c3
1669 : d509                     cmp zp1,x   ;test result
                                trap_ne
166b : d0fe            >        bne *           ;failed not equal (non zero)
                        
166d : 68                       pla         ;load status
                                eor_flag 0
166e : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1670 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1673 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1675 : ca                       dex
1676 : 10e1                     bpl tldax2                  
                        
1678 : a203                     ldx #3
167a :                  tldax3
                                set_stat $ff
                       >            load_flag $ff
167a : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
167c : 48              >            pha         ;use stack to load status
167d : 28              >            plp
                        
167e : bd1702                   lda abs1,x
1681 : 08                       php         ;test stores do not alter flags
1682 : 49c3                     eor #$c3
1684 : 28                       plp
1685 : 9502                     sta zpt,x
1687 : 08                       php         ;flags after load/store sequence
1688 : 49c3                     eor #$c3
168a : d509                     cmp zp1,x   ;test result
                                trap_ne
168c : d0fe            >        bne *           ;failed not equal (non zero)
                        
168e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
168f : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1691 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1694 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1696 : ca                       dex
1697 : 10e1                     bpl tldax3
                        
1699 : a203                     ldx #3      ;testing store result
169b : a000                     ldy #0
169d : b502             tstax   lda zpt,x
169f : 49c3                     eor #$c3
16a1 : d509                     cmp zp1,x
                                trap_ne     ;store to zp,x data
16a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16a5 : 9402                     sty zpt,x   ;clear                
16a7 : bd0302                   lda abst,x
16aa : 49c3                     eor #$c3
16ac : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
16af : d0fe            >        bne *           ;failed not equal (non zero)
                        
16b1 : 8a                       txa
16b2 : 9d0302                   sta abst,x  ;clear                
16b5 : ca                       dex
16b6 : 10e5                     bpl tstax
                                next_test
16b8 : ad0002          >            lda test_case   ;previous test
16bb : c915            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
16bd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0016 =                 >test_num = test_num + 1
16bf : a916            >            lda #test_num   ;*** next tests' number
16c1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - (zp),y / abs,y / (zp,x)
16c4 : a003                     ldy #3
16c6 :                  tlday    
                                set_stat 0
                       >            load_flag 0
16c6 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
16c8 : 48              >            pha         ;use stack to load status
16c9 : 28              >            plp
                        
16ca : b11a                     lda (ind1),y
16cc : 08                       php         ;test stores do not alter flags
16cd : 49c3                     eor #$c3
16cf : 28                       plp
16d0 : 990302                   sta abst,y
16d3 : 08                       php         ;flags after load/store sequence
16d4 : 49c3                     eor #$c3
16d6 : d91702                   cmp abs1,y  ;test result
                                trap_ne
16d9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16db : 68                       pla         ;load status
                                eor_flag 0
16dc : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
16de : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
16e1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16e3 : 88                       dey
16e4 : 10e0                     bpl tlday                  
                        
16e6 : a003                     ldy #3
16e8 :                  tlday1   
                                set_stat $ff
                       >            load_flag $ff
16e8 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
16ea : 48              >            pha         ;use stack to load status
16eb : 28              >            plp
                        
16ec : b11a                     lda (ind1),y
16ee : 08                       php         ;test stores do not alter flags
16ef : 49c3                     eor #$c3
16f1 : 28                       plp
16f2 : 990302                   sta abst,y
16f5 : 08                       php         ;flags after load/store sequence
16f6 : 49c3                     eor #$c3
16f8 : d91702                   cmp abs1,y  ;test result
                                trap_ne
16fb : d0fe            >        bne *           ;failed not equal (non zero)
                        
16fd : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
16fe : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1700 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1703 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1705 : 88                       dey
1706 : 10e0                     bpl tlday1                  
                        
1708 : a003                     ldy #3      ;testing store result
170a : a200                     ldx #0
170c : b90302           tstay   lda abst,y
170f : 49c3                     eor #$c3
1711 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1714 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1716 : 8a                       txa
1717 : 990302                   sta abst,y  ;clear                
171a : 88                       dey
171b : 10ef                     bpl tstay
                        
171d : a003                     ldy #3
171f :                  tlday2   
                                set_stat 0
                       >            load_flag 0
171f : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1721 : 48              >            pha         ;use stack to load status
1722 : 28              >            plp
                        
1723 : b91702                   lda abs1,y
1726 : 08                       php         ;test stores do not alter flags
1727 : 49c3                     eor #$c3
1729 : 28                       plp
172a : 9126                     sta (indt),y
172c : 08                       php         ;flags after load/store sequence
172d : 49c3                     eor #$c3
172f : d11a                     cmp (ind1),y    ;test result
                                trap_ne
1731 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1733 : 68                       pla         ;load status
                                eor_flag 0
1734 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1736 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1739 : d0fe            >        bne *           ;failed not equal (non zero)
                        
173b : 88                       dey
173c : 10e1                     bpl tlday2                  
                        
173e : a003                     ldy #3
1740 :                  tlday3   
                                set_stat $ff
                       >            load_flag $ff
1740 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1742 : 48              >            pha         ;use stack to load status
1743 : 28              >            plp
                        
1744 : b91702                   lda abs1,y
1747 : 08                       php         ;test stores do not alter flags
1748 : 49c3                     eor #$c3
174a : 28                       plp
174b : 9126                     sta (indt),y
174d : 08                       php         ;flags after load/store sequence
174e : 49c3                     eor #$c3
1750 : d11a                     cmp (ind1),y   ;test result
                                trap_ne
1752 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1754 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1755 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1757 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
175a : d0fe            >        bne *           ;failed not equal (non zero)
                        
175c : 88                       dey
175d : 10e1                     bpl tlday3
                                
175f : a003                     ldy #3      ;testing store result
1761 : a200                     ldx #0
1763 : b90302           tstay1  lda abst,y
1766 : 49c3                     eor #$c3
1768 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
176b : d0fe            >        bne *           ;failed not equal (non zero)
                        
176d : 8a                       txa
176e : 990302                   sta abst,y  ;clear                
1771 : 88                       dey
1772 : 10ef                     bpl tstay1
                                
1774 : a206                     ldx #6
1776 : a003                     ldy #3
1778 :                  tldax4   
                                set_stat 0
                       >            load_flag 0
1778 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
177a : 48              >            pha         ;use stack to load status
177b : 28              >            plp
                        
177c : a11a                     lda (ind1,x)
177e : 08                       php         ;test stores do not alter flags
177f : 49c3                     eor #$c3
1781 : 28                       plp
1782 : 8126                     sta (indt,x)
1784 : 08                       php         ;flags after load/store sequence
1785 : 49c3                     eor #$c3
1787 : d91702                   cmp abs1,y  ;test result
                                trap_ne
178a : d0fe            >        bne *           ;failed not equal (non zero)
                        
178c : 68                       pla         ;load status
                                eor_flag 0
178d : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
178f : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1792 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1794 : ca                       dex
1795 : ca                       dex
1796 : 88                       dey
1797 : 10df                     bpl tldax4                  
                        
1799 : a206                     ldx #6
179b : a003                     ldy #3
179d :                  tldax5
                                set_stat $ff
                       >            load_flag $ff
179d : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
179f : 48              >            pha         ;use stack to load status
17a0 : 28              >            plp
                        
17a1 : a11a                     lda (ind1,x)
17a3 : 08                       php         ;test stores do not alter flags
17a4 : 49c3                     eor #$c3
17a6 : 28                       plp
17a7 : 8126                     sta (indt,x)
17a9 : 08                       php         ;flags after load/store sequence
17aa : 49c3                     eor #$c3
17ac : d91702                   cmp abs1,y  ;test result
                                trap_ne
17af : d0fe            >        bne *           ;failed not equal (non zero)
                        
17b1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
17b2 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
17b4 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
17b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17b9 : ca                       dex
17ba : ca                       dex
17bb : 88                       dey
17bc : 10df                     bpl tldax5
                        
17be : a003                     ldy #3      ;testing store result
17c0 : a200                     ldx #0
17c2 : b90302           tstay2  lda abst,y
17c5 : 49c3                     eor #$c3
17c7 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
17ca : d0fe            >        bne *           ;failed not equal (non zero)
                        
17cc : 8a                       txa
17cd : 990302                   sta abst,y  ;clear                
17d0 : 88                       dey
17d1 : 10ef                     bpl tstay2
                                next_test
17d3 : ad0002          >            lda test_case   ;previous test
17d6 : c916            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
17d8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0017 =                 >test_num = test_num + 1
17da : a917            >            lda #test_num   ;*** next tests' number
17dc : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
17df : a2fd                     ldx #3+$fa
17e1 : b50f             tldax6  lda zp1-$fa&$ff,x   ;wrap on indexed zp
17e3 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
17e6 : ca                       dex
17e7 : e0fa                     cpx #$fa
17e9 : b0f6                     bcs tldax6                  
17eb : a2fd                     ldx #3+$fa
17ed : bd1d01           tldax7  lda abs1-$fa,x      ;no wrap on indexed abs
17f0 : 9508                     sta zpt-$fa&$ff,x
17f2 : ca                       dex
17f3 : e0fa                     cpx #$fa
17f5 : b0f6                     bcs tldax7
                                                  
17f7 : a203                     ldx #3      ;testing wraparound result
17f9 : a000                     ldy #0
17fb : b502             tstax1  lda zpt,x
17fd : d509                     cmp zp1,x
                                trap_ne     ;store to zp,x data
17ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
1801 : 9402                     sty zpt,x   ;clear                
1803 : bd0302                   lda abst,x
1806 : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
1809 : d0fe            >        bne *           ;failed not equal (non zero)
                        
180b : 8a                       txa
180c : 9d0302                   sta abst,x  ;clear                
180f : ca                       dex
1810 : 10e9                     bpl tstax1
                        
1812 : a0fb                     ldy #3+$f8
1814 : a2fe                     ldx #6+$f8
1816 : a122             tlday4  lda (ind1-$f8&$ff,x) ;wrap on indexed zp indirect
1818 : 990b01                   sta abst-$f8,y
181b : ca                       dex
181c : ca                       dex
181d : 88                       dey
181e : c0f8                     cpy #$f8
1820 : b0f4                     bcs tlday4
1822 : a003                     ldy #3      ;testing wraparound result
1824 : a200                     ldx #0
1826 : b90302           tstay4  lda abst,y
1829 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
182c : d0fe            >        bne *           ;failed not equal (non zero)
                        
182e : 8a                       txa
182f : 990302                   sta abst,y  ;clear                
1832 : 88                       dey
1833 : 10f1                     bpl tstay4
                                
1835 : a0fb                     ldy #3+$f8
1837 : b91f01           tlday5  lda abs1-$f8,y  ;no wrap on indexed abs
183a : 912e                     sta (inwt),y
183c : 88                       dey
183d : c0f8                     cpy #$f8
183f : b0f6                     bcs tlday5                  
1841 : a003                     ldy #3      ;testing wraparound result
1843 : a200                     ldx #0
1845 : b90302           tstay5  lda abst,y
1848 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
184b : d0fe            >        bne *           ;failed not equal (non zero)
                        
184d : 8a                       txa
184e : 990302                   sta abst,y  ;clear                
1851 : 88                       dey
1852 : 10f1                     bpl tstay5
                        
1854 : a0fb                     ldy #3+$f8
1856 : a2fe                     ldx #6+$f8
1858 : b124             tlday6  lda (inw1),y    ;no wrap on zp indirect indexed 
185a : 812e                     sta (indt-$f8&$ff,x)
185c : ca                       dex
185d : ca                       dex
185e : 88                       dey
185f : c0f8                     cpy #$f8
1861 : b0f5                     bcs tlday6
1863 : a003                     ldy #3      ;testing wraparound result
1865 : a200                     ldx #0
1867 : b90302           tstay6  lda abst,y
186a : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
186d : d0fe            >        bne *           ;failed not equal (non zero)
                        
186f : 8a                       txa
1870 : 990302                   sta abst,y  ;clear                
1873 : 88                       dey
1874 : 10f1                     bpl tstay6
                                next_test
1876 : ad0002          >            lda test_case   ;previous test
1879 : c917            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
187b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0018 =                 >test_num = test_num + 1
187d : a918            >            lda #test_num   ;*** next tests' number
187f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
1882 : a904            >            lda #0  |intdis      ;force disable interrupts
                       >
1884 : 48              >            pha         ;use stack to load status
1885 : 28              >            plp
                        
1886 : a509                     lda zp1
1888 : 08                       php         ;test stores do not alter flags
1889 : 49c3                     eor #$c3
188b : 28                       plp
188c : 8d0302                   sta abst
188f : 08                       php         ;flags after load/store sequence
1890 : 49c3                     eor #$c3
1892 : c9c3                     cmp #$c3    ;test result
                                trap_ne
1894 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1896 : 68                       pla         ;load status
                                eor_flag 0
1897 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1899 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
189c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
189e : a904            >            lda #0|intdis      ;force disable interrupts
                       >
18a0 : 48              >            pha         ;use stack to load status
18a1 : 28              >            plp
                        
18a2 : a50a                     lda zp1+1
18a4 : 08                       php         ;test stores do not alter flags
18a5 : 49c3                     eor #$c3
18a7 : 28                       plp
18a8 : 8d0402                   sta abst+1
18ab : 08                       php         ;flags after load/store sequence
18ac : 49c3                     eor #$c3
18ae : c982                     cmp #$82    ;test result
                                trap_ne
18b0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18b2 : 68                       pla         ;load status
                                eor_flag 0
18b3 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
18b5 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
18b8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
18ba : a904            >            lda #0|intdis      ;force disable interrupts
                       >
18bc : 48              >            pha         ;use stack to load status
18bd : 28              >            plp
                        
18be : a50b                     lda zp1+2
18c0 : 08                       php         ;test stores do not alter flags
18c1 : 49c3                     eor #$c3
18c3 : 28                       plp
18c4 : 8d0502                   sta abst+2
18c7 : 08                       php         ;flags after load/store sequence
18c8 : 49c3                     eor #$c3
18ca : c941                     cmp #$41    ;test result
                                trap_ne
18cc : d0fe            >        bne *           ;failed not equal (non zero)
                        
18ce : 68                       pla         ;load status
                                eor_flag 0
18cf : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
18d1 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
18d4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
18d6 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
18d8 : 48              >            pha         ;use stack to load status
18d9 : 28              >            plp
                        
18da : a50c                     lda zp1+3
18dc : 08                       php         ;test stores do not alter flags
18dd : 49c3                     eor #$c3
18df : 28                       plp
18e0 : 8d0602                   sta abst+3
18e3 : 08                       php         ;flags after load/store sequence
18e4 : 49c3                     eor #$c3
18e6 : c900                     cmp #0      ;test result
                                trap_ne
18e8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18ea : 68                       pla         ;load status
                                eor_flag 0
18eb : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
18ed : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
18f0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
18f2 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
18f4 : 48              >            pha         ;use stack to load status
18f5 : 28              >            plp
                        
18f6 : a509                     lda zp1  
18f8 : 08                       php         ;test stores do not alter flags
18f9 : 49c3                     eor #$c3
18fb : 28                       plp
18fc : 8d0302                   sta abst  
18ff : 08                       php         ;flags after load/store sequence
1900 : 49c3                     eor #$c3
1902 : c9c3                     cmp #$c3    ;test result
                                trap_ne
1904 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1906 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1907 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1909 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
190c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
190e : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1910 : 48              >            pha         ;use stack to load status
1911 : 28              >            plp
                        
1912 : a50a                     lda zp1+1
1914 : 08                       php         ;test stores do not alter flags
1915 : 49c3                     eor #$c3
1917 : 28                       plp
1918 : 8d0402                   sta abst+1
191b : 08                       php         ;flags after load/store sequence
191c : 49c3                     eor #$c3
191e : c982                     cmp #$82    ;test result
                                trap_ne
1920 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1922 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1923 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1925 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1928 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
192a : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
192c : 48              >            pha         ;use stack to load status
192d : 28              >            plp
                        
192e : a50b                     lda zp1+2
1930 : 08                       php         ;test stores do not alter flags
1931 : 49c3                     eor #$c3
1933 : 28                       plp
1934 : 8d0502                   sta abst+2
1937 : 08                       php         ;flags after load/store sequence
1938 : 49c3                     eor #$c3
193a : c941                     cmp #$41    ;test result
                                trap_ne
193c : d0fe            >        bne *           ;failed not equal (non zero)
                        
193e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
193f : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1941 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1944 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1946 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1948 : 48              >            pha         ;use stack to load status
1949 : 28              >            plp
                        
194a : a50c                     lda zp1+3
194c : 08                       php         ;test stores do not alter flags
194d : 49c3                     eor #$c3
194f : 28                       plp
1950 : 8d0602                   sta abst+3
1953 : 08                       php         ;flags after load/store sequence
1954 : 49c3                     eor #$c3
1956 : c900                     cmp #0      ;test result
                                trap_ne
1958 : d0fe            >        bne *           ;failed not equal (non zero)
                        
195a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
195b : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
195d : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1960 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1962 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1964 : 48              >            pha         ;use stack to load status
1965 : 28              >            plp
                        
1966 : ad1702                   lda abs1  
1969 : 08                       php         ;test stores do not alter flags
196a : 49c3                     eor #$c3
196c : 28                       plp
196d : 8502                     sta zpt  
196f : 08                       php         ;flags after load/store sequence
1970 : 49c3                     eor #$c3
1972 : c509                     cmp zp1     ;test result
                                trap_ne
1974 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1976 : 68                       pla         ;load status
                                eor_flag 0
1977 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1979 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
197c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
197e : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1980 : 48              >            pha         ;use stack to load status
1981 : 28              >            plp
                        
1982 : ad1802                   lda abs1+1
1985 : 08                       php         ;test stores do not alter flags
1986 : 49c3                     eor #$c3
1988 : 28                       plp
1989 : 8503                     sta zpt+1
198b : 08                       php         ;flags after load/store sequence
198c : 49c3                     eor #$c3
198e : c50a                     cmp zp1+1   ;test result
                                trap_ne
1990 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1992 : 68                       pla         ;load status
                                eor_flag 0
1993 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1995 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1998 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
199a : a904            >            lda #0|intdis      ;force disable interrupts
                       >
199c : 48              >            pha         ;use stack to load status
199d : 28              >            plp
                        
199e : ad1902                   lda abs1+2
19a1 : 08                       php         ;test stores do not alter flags
19a2 : 49c3                     eor #$c3
19a4 : 28                       plp
19a5 : 8504                     sta zpt+2
19a7 : 08                       php         ;flags after load/store sequence
19a8 : 49c3                     eor #$c3
19aa : c50b                     cmp zp1+2   ;test result
                                trap_ne
19ac : d0fe            >        bne *           ;failed not equal (non zero)
                        
19ae : 68                       pla         ;load status
                                eor_flag 0
19af : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
19b1 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
19b4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
19b6 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
19b8 : 48              >            pha         ;use stack to load status
19b9 : 28              >            plp
                        
19ba : ad1a02                   lda abs1+3
19bd : 08                       php         ;test stores do not alter flags
19be : 49c3                     eor #$c3
19c0 : 28                       plp
19c1 : 8505                     sta zpt+3
19c3 : 08                       php         ;flags after load/store sequence
19c4 : 49c3                     eor #$c3
19c6 : c50c                     cmp zp1+3   ;test result
                                trap_ne
19c8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19ca : 68                       pla         ;load status
                                eor_flag 0
19cb : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
19cd : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
19d0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19d2 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
19d4 : 48              >            pha         ;use stack to load status
19d5 : 28              >            plp
                        
19d6 : ad1702                   lda abs1  
19d9 : 08                       php         ;test stores do not alter flags
19da : 49c3                     eor #$c3
19dc : 28                       plp
19dd : 8502                     sta zpt  
19df : 08                       php         ;flags after load/store sequence
19e0 : 49c3                     eor #$c3
19e2 : c509                     cmp zp1     ;test result
                                trap_ne
19e4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19e6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
19e7 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
19e9 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
19ec : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
19ee : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
19f0 : 48              >            pha         ;use stack to load status
19f1 : 28              >            plp
                        
19f2 : ad1802                   lda abs1+1
19f5 : 08                       php         ;test stores do not alter flags
19f6 : 49c3                     eor #$c3
19f8 : 28                       plp
19f9 : 8503                     sta zpt+1
19fb : 08                       php         ;flags after load/store sequence
19fc : 49c3                     eor #$c3
19fe : c50a                     cmp zp1+1   ;test result
                                trap_ne
1a00 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a02 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a03 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1a05 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1a08 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a0a : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1a0c : 48              >            pha         ;use stack to load status
1a0d : 28              >            plp
                        
1a0e : ad1902                   lda abs1+2
1a11 : 08                       php         ;test stores do not alter flags
1a12 : 49c3                     eor #$c3
1a14 : 28                       plp
1a15 : 8504                     sta zpt+2
1a17 : 08                       php         ;flags after load/store sequence
1a18 : 49c3                     eor #$c3
1a1a : c50b                     cmp zp1+2   ;test result
                                trap_ne
1a1c : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a1e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a1f : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1a21 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1a24 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a26 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1a28 : 48              >            pha         ;use stack to load status
1a29 : 28              >            plp
                        
1a2a : ad1a02                   lda abs1+3
1a2d : 08                       php         ;test stores do not alter flags
1a2e : 49c3                     eor #$c3
1a30 : 28                       plp
1a31 : 8505                     sta zpt+3
1a33 : 08                       php         ;flags after load/store sequence
1a34 : 49c3                     eor #$c3
1a36 : c50c                     cmp zp1+3   ;test result
                                trap_ne
1a38 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a3a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a3b : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1a3d : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1a40 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0  
                       >            load_flag 0  
1a42 : a904            >            lda #0  |intdis      ;force disable interrupts
                       >
1a44 : 48              >            pha         ;use stack to load status
1a45 : 28              >            plp
                        
1a46 : a9c3                     lda #$c3
1a48 : 08                       php
1a49 : cd1702                   cmp abs1    ;test result
                                trap_ne
1a4c : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a4e : 68                       pla         ;load status
                                eor_flag 0
1a4f : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1a51 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1a54 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a56 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1a58 : 48              >            pha         ;use stack to load status
1a59 : 28              >            plp
                        
1a5a : a982                     lda #$82
1a5c : 08                       php
1a5d : cd1802                   cmp abs1+1  ;test result
                                trap_ne
1a60 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a62 : 68                       pla         ;load status
                                eor_flag 0
1a63 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1a65 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1a68 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a6a : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1a6c : 48              >            pha         ;use stack to load status
1a6d : 28              >            plp
                        
1a6e : a941                     lda #$41
1a70 : 08                       php
1a71 : cd1902                   cmp abs1+2  ;test result
                                trap_ne
1a74 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a76 : 68                       pla         ;load status
                                eor_flag 0
1a77 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1a79 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1a7c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a7e : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1a80 : 48              >            pha         ;use stack to load status
1a81 : 28              >            plp
                        
1a82 : a900                     lda #0
1a84 : 08                       php
1a85 : cd1a02                   cmp abs1+3  ;test result
                                trap_ne
1a88 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a8a : 68                       pla         ;load status
                                eor_flag 0
1a8b : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                        
1a8d : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1a90 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1a92 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1a94 : 48              >            pha         ;use stack to load status
1a95 : 28              >            plp
                        
1a96 : a9c3                     lda #$c3  
1a98 : 08                       php
1a99 : cd1702                   cmp abs1    ;test result
                                trap_ne
1a9c : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a9e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a9f : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1aa1 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1aa4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1aa6 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1aa8 : 48              >            pha         ;use stack to load status
1aa9 : 28              >            plp
                        
1aaa : a982                     lda #$82
1aac : 08                       php
1aad : cd1802                   cmp abs1+1  ;test result
                                trap_ne
1ab0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ab2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1ab3 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1ab5 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1ab8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1aba : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1abc : 48              >            pha         ;use stack to load status
1abd : 28              >            plp
                        
1abe : a941                     lda #$41
1ac0 : 08                       php
1ac1 : cd1902                   cmp abs1+2  ;test result
                                trap_ne
1ac4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ac6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1ac7 : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1ac9 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1acc : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1ace : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1ad0 : 48              >            pha         ;use stack to load status
1ad1 : 28              >            plp
                        
1ad2 : a900                     lda #0
1ad4 : 08                       php
1ad5 : cd1a02                   cmp abs1+3  ;test result
                                trap_ne
1ad8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ada : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1adb : 497d            >            eor #(lo~fnz |fai)       ;invert expected flags + always on bits + I
                        
1add : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1ae0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
1ae2 : a200                     ldx #0
1ae4 : a502                     lda zpt  
1ae6 : 49c3                     eor #$c3
1ae8 : c509                     cmp zp1  
                                trap_ne     ;store to zp data
1aea : d0fe            >        bne *           ;failed not equal (non zero)
                        
1aec : 8602                     stx zpt     ;clear                
1aee : ad0302                   lda abst  
1af1 : 49c3                     eor #$c3
1af3 : cd1702                   cmp abs1  
                                trap_ne     ;store to abs data
1af6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1af8 : 8e0302                   stx abst    ;clear                
1afb : a503                     lda zpt+1
1afd : 49c3                     eor #$c3
1aff : c50a                     cmp zp1+1
                                trap_ne     ;store to zp data
1b01 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b03 : 8603                     stx zpt+1   ;clear                
1b05 : ad0402                   lda abst+1
1b08 : 49c3                     eor #$c3
1b0a : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs data
1b0d : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b0f : 8e0402                   stx abst+1  ;clear                
1b12 : a504                     lda zpt+2
1b14 : 49c3                     eor #$c3
1b16 : c50b                     cmp zp1+2
                                trap_ne     ;store to zp data
1b18 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b1a : 8604                     stx zpt+2   ;clear                
1b1c : ad0502                   lda abst+2
1b1f : 49c3                     eor #$c3
1b21 : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs data
1b24 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b26 : 8e0502                   stx abst+2  ;clear                
1b29 : a505                     lda zpt+3
1b2b : 49c3                     eor #$c3
1b2d : c50c                     cmp zp1+3
                                trap_ne     ;store to zp data
1b2f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b31 : 8605                     stx zpt+3   ;clear                
1b33 : ad0602                   lda abst+3
1b36 : 49c3                     eor #$c3
1b38 : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs data
1b3b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b3d : 8e0602                   stx abst+3  ;clear                
                                next_test
1b40 : ad0002          >            lda test_case   ;previous test
1b43 : c918            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1b45 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0019 =                 >test_num = test_num + 1
1b47 : a919            >            lda #test_num   ;*** next tests' number
1b49 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing bit test & compares BIT CPX CPY CMP all addressing modes
                        ; BIT - zp / abs
                                set_a $ff,0
                       >            load_flag 0
1b4c : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1b4e : 48              >            pha         ;use stack to load status
1b4f : a9ff            >            lda #$ff     ;precharge accu
1b51 : 28              >            plp
                        
1b52 : 240c                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1b54 : 08              >            php         ;save flags
1b55 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1b57 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b59 : 68              >            pla         ;load status
1b5a : 48              >            pha
                       >            cmp_flag fz 
1b5b : c936            >            cmp #(fz |fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1b5d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b5f : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b60 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1b62 : 48              >            pha         ;use stack to load status
1b63 : a901            >            lda #1     ;precharge accu
1b65 : 28              >            plp
                        
1b66 : 240b                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1b68 : 08              >            php         ;save flags
1b69 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b6d : 68              >            pla         ;load status
1b6e : 48              >            pha
                       >            cmp_flag fv
1b6f : c974            >            cmp #(fv|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1b71 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b73 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b74 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1b76 : 48              >            pha         ;use stack to load status
1b77 : a901            >            lda #1     ;precharge accu
1b79 : 28              >            plp
                        
1b7a : 240a                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1b7c : 08              >            php         ;save flags
1b7d : c901            >            cmp #1     ;test result
                       >            trap_ne
1b7f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b81 : 68              >            pla         ;load status
1b82 : 48              >            pha
                       >            cmp_flag fnz
1b83 : c9b6            >            cmp #(fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1b85 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b87 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1b88 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1b8a : 48              >            pha         ;use stack to load status
1b8b : a901            >            lda #1     ;precharge accu
1b8d : 28              >            plp
                        
1b8e : 2409                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1b90 : 08              >            php         ;save flags
1b91 : c901            >            cmp #1     ;test result
                       >            trap_ne
1b93 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b95 : 68              >            pla         ;load status
1b96 : 48              >            pha
                       >            cmp_flag fnv
1b97 : c9f4            >            cmp #(fnv|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1b99 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b9b : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1b9c : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1b9e : 48              >            pha         ;use stack to load status
1b9f : a9ff            >            lda #$ff     ;precharge accu
1ba1 : 28              >            plp
                        
1ba2 : 240c                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1ba4 : 08              >            php         ;save flags
1ba5 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1ba7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ba9 : 68              >            pla         ;load status
1baa : 48              >            pha
                       >            cmp_flag ~fnv 
1bab : c93f            >            cmp #(~fnv |fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1bad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1baf : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1bb0 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1bb2 : 48              >            pha         ;use stack to load status
1bb3 : a901            >            lda #1     ;precharge accu
1bb5 : 28              >            plp
                        
1bb6 : 240b                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1bb8 : 08              >            php         ;save flags
1bb9 : c901            >            cmp #1     ;test result
                       >            trap_ne
1bbb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bbd : 68              >            pla         ;load status
1bbe : 48              >            pha
                       >            cmp_flag ~fnz
1bbf : c97d            >            cmp #(~fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1bc1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bc3 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1bc4 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1bc6 : 48              >            pha         ;use stack to load status
1bc7 : a901            >            lda #1     ;precharge accu
1bc9 : 28              >            plp
                        
1bca : 240a                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1bcc : 08              >            php         ;save flags
1bcd : c901            >            cmp #1     ;test result
                       >            trap_ne
1bcf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bd1 : 68              >            pla         ;load status
1bd2 : 48              >            pha
                       >            cmp_flag ~fv
1bd3 : c9bf            >            cmp #(~fv|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1bd5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bd7 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1bd8 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1bda : 48              >            pha         ;use stack to load status
1bdb : a901            >            lda #1     ;precharge accu
1bdd : 28              >            plp
                        
1bde : 2409                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1be0 : 08              >            php         ;save flags
1be1 : c901            >            cmp #1     ;test result
                       >            trap_ne
1be3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1be5 : 68              >            pla         ;load status
1be6 : 48              >            pha
                       >            cmp_flag ~fz
1be7 : c9fd            >            cmp #(~fz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1be9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1beb : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,0
                       >            load_flag 0
1bec : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1bee : 48              >            pha         ;use stack to load status
1bef : a9ff            >            lda #$ff     ;precharge accu
1bf1 : 28              >            plp
                        
1bf2 : 2c1a02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1bf5 : 08              >            php         ;save flags
1bf6 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1bf8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bfa : 68              >            pla         ;load status
1bfb : 48              >            pha
                       >            cmp_flag fz 
1bfc : c936            >            cmp #(fz |fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1bfe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c00 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1c01 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1c03 : 48              >            pha         ;use stack to load status
1c04 : a901            >            lda #1     ;precharge accu
1c06 : 28              >            plp
                        
1c07 : 2c1902                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1c0a : 08              >            php         ;save flags
1c0b : c901            >            cmp #1     ;test result
                       >            trap_ne
1c0d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c0f : 68              >            pla         ;load status
1c10 : 48              >            pha
                       >            cmp_flag fv
1c11 : c974            >            cmp #(fv|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1c13 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c15 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1c16 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1c18 : 48              >            pha         ;use stack to load status
1c19 : a901            >            lda #1     ;precharge accu
1c1b : 28              >            plp
                        
1c1c : 2c1802                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1c1f : 08              >            php         ;save flags
1c20 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c22 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c24 : 68              >            pla         ;load status
1c25 : 48              >            pha
                       >            cmp_flag fnz
1c26 : c9b6            >            cmp #(fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1c28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c2a : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1c2b : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1c2d : 48              >            pha         ;use stack to load status
1c2e : a901            >            lda #1     ;precharge accu
1c30 : 28              >            plp
                        
1c31 : 2c1702                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1c34 : 08              >            php         ;save flags
1c35 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c37 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c39 : 68              >            pla         ;load status
1c3a : 48              >            pha
                       >            cmp_flag fnv
1c3b : c9f4            >            cmp #(fnv|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1c3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c3f : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1c40 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1c42 : 48              >            pha         ;use stack to load status
1c43 : a9ff            >            lda #$ff     ;precharge accu
1c45 : 28              >            plp
                        
1c46 : 2c1a02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1c49 : 08              >            php         ;save flags
1c4a : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1c4c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c4e : 68              >            pla         ;load status
1c4f : 48              >            pha
                       >            cmp_flag ~fnv 
1c50 : c93f            >            cmp #(~fnv |fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1c52 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c54 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c55 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1c57 : 48              >            pha         ;use stack to load status
1c58 : a901            >            lda #1     ;precharge accu
1c5a : 28              >            plp
                        
1c5b : 2c1902                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1c5e : 08              >            php         ;save flags
1c5f : c901            >            cmp #1     ;test result
                       >            trap_ne
1c61 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c63 : 68              >            pla         ;load status
1c64 : 48              >            pha
                       >            cmp_flag ~fnz
1c65 : c97d            >            cmp #(~fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1c67 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c69 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c6a : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1c6c : 48              >            pha         ;use stack to load status
1c6d : a901            >            lda #1     ;precharge accu
1c6f : 28              >            plp
                        
1c70 : 2c1802                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1c73 : 08              >            php         ;save flags
1c74 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c76 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c78 : 68              >            pla         ;load status
1c79 : 48              >            pha
                       >            cmp_flag ~fv
1c7a : c9bf            >            cmp #(~fv|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1c7c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c7e : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c7f : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1c81 : 48              >            pha         ;use stack to load status
1c82 : a901            >            lda #1     ;precharge accu
1c84 : 28              >            plp
                        
1c85 : 2c1702                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1c88 : 08              >            php         ;save flags
1c89 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c8b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c8d : 68              >            pla         ;load status
1c8e : 48              >            pha
                       >            cmp_flag ~fz
1c8f : c9fd            >            cmp #(~fz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1c91 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c93 : 28              >            plp         ;restore status
                        
                                next_test
1c94 : ad0002          >            lda test_case   ;previous test
1c97 : c919            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1c99 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001a =                 >test_num = test_num + 1
1c9b : a91a            >            lda #test_num   ;*** next tests' number
1c9d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; CPX - zp / abs / #         
                                set_x $80,0
                       >            load_flag 0
1ca0 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1ca2 : 48              >            pha         ;use stack to load status
1ca3 : a280            >            ldx #$80     ;precharge index x
1ca5 : 28              >            plp
                        
1ca6 : e40d                     cpx zp7f
                                tst_stat fc
1ca8 : 08              >            php         ;save status
1ca9 : 68              >            pla         ;use stack to retrieve status
1caa : 48              >            pha
                       >            cmp_flag fc
1cab : c935            >            cmp #(fc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1cad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1caf : 28              >            plp         ;restore status
                        
1cb0 : ca                       dex
1cb1 : e40d                     cpx zp7f
                                tst_stat fzc
1cb3 : 08              >            php         ;save status
1cb4 : 68              >            pla         ;use stack to retrieve status
1cb5 : 48              >            pha
                       >            cmp_flag fzc
1cb6 : c937            >            cmp #(fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1cb8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cba : 28              >            plp         ;restore status
                        
1cbb : ca                       dex
1cbc : e40d                     cpx zp7f
                                tst_x $7e,fn
1cbe : 08              >            php         ;save flags
1cbf : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1cc1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cc3 : 68              >            pla         ;load status
1cc4 : 48              >            pha
                       >            cmp_flag fn
1cc5 : c9b4            >            cmp #(fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1cc7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cc9 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1cca : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1ccc : 48              >            pha         ;use stack to load status
1ccd : a280            >            ldx #$80     ;precharge index x
1ccf : 28              >            plp
                        
1cd0 : e40d                     cpx zp7f
                                tst_stat ~fnz
1cd2 : 08              >            php         ;save status
1cd3 : 68              >            pla         ;use stack to retrieve status
1cd4 : 48              >            pha
                       >            cmp_flag ~fnz
1cd5 : c97d            >            cmp #(~fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1cd7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cd9 : 28              >            plp         ;restore status
                        
1cda : ca                       dex
1cdb : e40d                     cpx zp7f
                                tst_stat ~fn
1cdd : 08              >            php         ;save status
1cde : 68              >            pla         ;use stack to retrieve status
1cdf : 48              >            pha
                       >            cmp_flag ~fn
1ce0 : c97f            >            cmp #(~fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1ce2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ce4 : 28              >            plp         ;restore status
                        
1ce5 : ca                       dex
1ce6 : e40d                     cpx zp7f
                                tst_x $7e,~fzc
1ce8 : 08              >            php         ;save flags
1ce9 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1ceb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ced : 68              >            pla         ;load status
1cee : 48              >            pha
                       >            cmp_flag ~fzc
1cef : c9fc            >            cmp #(~fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1cf1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cf3 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1cf4 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1cf6 : 48              >            pha         ;use stack to load status
1cf7 : a280            >            ldx #$80     ;precharge index x
1cf9 : 28              >            plp
                        
1cfa : ec1b02                   cpx abs7f
                                tst_stat fc
1cfd : 08              >            php         ;save status
1cfe : 68              >            pla         ;use stack to retrieve status
1cff : 48              >            pha
                       >            cmp_flag fc
1d00 : c935            >            cmp #(fc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1d02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d04 : 28              >            plp         ;restore status
                        
1d05 : ca                       dex
1d06 : ec1b02                   cpx abs7f
                                tst_stat fzc
1d09 : 08              >            php         ;save status
1d0a : 68              >            pla         ;use stack to retrieve status
1d0b : 48              >            pha
                       >            cmp_flag fzc
1d0c : c937            >            cmp #(fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1d0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d10 : 28              >            plp         ;restore status
                        
1d11 : ca                       dex
1d12 : ec1b02                   cpx abs7f
                                tst_x $7e,fn
1d15 : 08              >            php         ;save flags
1d16 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d18 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d1a : 68              >            pla         ;load status
1d1b : 48              >            pha
                       >            cmp_flag fn
1d1c : c9b4            >            cmp #(fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1d1e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d20 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1d21 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1d23 : 48              >            pha         ;use stack to load status
1d24 : a280            >            ldx #$80     ;precharge index x
1d26 : 28              >            plp
                        
1d27 : ec1b02                   cpx abs7f
                                tst_stat ~fnz
1d2a : 08              >            php         ;save status
1d2b : 68              >            pla         ;use stack to retrieve status
1d2c : 48              >            pha
                       >            cmp_flag ~fnz
1d2d : c97d            >            cmp #(~fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1d2f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d31 : 28              >            plp         ;restore status
                        
1d32 : ca                       dex
1d33 : ec1b02                   cpx abs7f
                                tst_stat ~fn
1d36 : 08              >            php         ;save status
1d37 : 68              >            pla         ;use stack to retrieve status
1d38 : 48              >            pha
                       >            cmp_flag ~fn
1d39 : c97f            >            cmp #(~fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1d3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d3d : 28              >            plp         ;restore status
                        
1d3e : ca                       dex
1d3f : ec1b02                   cpx abs7f
                                tst_x $7e,~fzc
1d42 : 08              >            php         ;save flags
1d43 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d45 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d47 : 68              >            pla         ;load status
1d48 : 48              >            pha
                       >            cmp_flag ~fzc
1d49 : c9fc            >            cmp #(~fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1d4b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d4d : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1d4e : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1d50 : 48              >            pha         ;use stack to load status
1d51 : a280            >            ldx #$80     ;precharge index x
1d53 : 28              >            plp
                        
1d54 : e07f                     cpx #$7f
                                tst_stat fc
1d56 : 08              >            php         ;save status
1d57 : 68              >            pla         ;use stack to retrieve status
1d58 : 48              >            pha
                       >            cmp_flag fc
1d59 : c935            >            cmp #(fc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1d5b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d5d : 28              >            plp         ;restore status
                        
1d5e : ca                       dex
1d5f : e07f                     cpx #$7f
                                tst_stat fzc
1d61 : 08              >            php         ;save status
1d62 : 68              >            pla         ;use stack to retrieve status
1d63 : 48              >            pha
                       >            cmp_flag fzc
1d64 : c937            >            cmp #(fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1d66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d68 : 28              >            plp         ;restore status
                        
1d69 : ca                       dex
1d6a : e07f                     cpx #$7f
                                tst_x $7e,fn
1d6c : 08              >            php         ;save flags
1d6d : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d6f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d71 : 68              >            pla         ;load status
1d72 : 48              >            pha
                       >            cmp_flag fn
1d73 : c9b4            >            cmp #(fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1d75 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d77 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1d78 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1d7a : 48              >            pha         ;use stack to load status
1d7b : a280            >            ldx #$80     ;precharge index x
1d7d : 28              >            plp
                        
1d7e : e07f                     cpx #$7f
                                tst_stat ~fnz
1d80 : 08              >            php         ;save status
1d81 : 68              >            pla         ;use stack to retrieve status
1d82 : 48              >            pha
                       >            cmp_flag ~fnz
1d83 : c97d            >            cmp #(~fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1d85 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d87 : 28              >            plp         ;restore status
                        
1d88 : ca                       dex
1d89 : e07f                     cpx #$7f
                                tst_stat ~fn
1d8b : 08              >            php         ;save status
1d8c : 68              >            pla         ;use stack to retrieve status
1d8d : 48              >            pha
                       >            cmp_flag ~fn
1d8e : c97f            >            cmp #(~fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1d90 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d92 : 28              >            plp         ;restore status
                        
1d93 : ca                       dex
1d94 : e07f                     cpx #$7f
                                tst_x $7e,~fzc
1d96 : 08              >            php         ;save flags
1d97 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d99 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d9b : 68              >            pla         ;load status
1d9c : 48              >            pha
                       >            cmp_flag ~fzc
1d9d : c9fc            >            cmp #(~fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1d9f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1da1 : 28              >            plp         ;restore status
                        
                                next_test
1da2 : ad0002          >            lda test_case   ;previous test
1da5 : c91a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1da7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001b =                 >test_num = test_num + 1
1da9 : a91b            >            lda #test_num   ;*** next tests' number
1dab : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPY - zp / abs / #         
                                set_y $80,0
                       >            load_flag 0
1dae : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1db0 : 48              >            pha         ;use stack to load status
1db1 : a080            >            ldy #$80     ;precharge index y
1db3 : 28              >            plp
                        
1db4 : c40d                     cpy zp7f
                                tst_stat fc
1db6 : 08              >            php         ;save status
1db7 : 68              >            pla         ;use stack to retrieve status
1db8 : 48              >            pha
                       >            cmp_flag fc
1db9 : c935            >            cmp #(fc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1dbb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dbd : 28              >            plp         ;restore status
                        
1dbe : 88                       dey
1dbf : c40d                     cpy zp7f
                                tst_stat fzc
1dc1 : 08              >            php         ;save status
1dc2 : 68              >            pla         ;use stack to retrieve status
1dc3 : 48              >            pha
                       >            cmp_flag fzc
1dc4 : c937            >            cmp #(fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1dc6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dc8 : 28              >            plp         ;restore status
                        
1dc9 : 88                       dey
1dca : c40d                     cpy zp7f
                                tst_y $7e,fn
1dcc : 08              >            php         ;save flags
1dcd : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1dcf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dd1 : 68              >            pla         ;load status
1dd2 : 48              >            pha
                       >            cmp_flag fn
1dd3 : c9b4            >            cmp #(fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1dd5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dd7 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1dd8 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1dda : 48              >            pha         ;use stack to load status
1ddb : a080            >            ldy #$80     ;precharge index y
1ddd : 28              >            plp
                        
1dde : c40d                     cpy zp7f
                                tst_stat ~fnz
1de0 : 08              >            php         ;save status
1de1 : 68              >            pla         ;use stack to retrieve status
1de2 : 48              >            pha
                       >            cmp_flag ~fnz
1de3 : c97d            >            cmp #(~fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1de5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1de7 : 28              >            plp         ;restore status
                        
1de8 : 88                       dey
1de9 : c40d                     cpy zp7f
                                tst_stat ~fn
1deb : 08              >            php         ;save status
1dec : 68              >            pla         ;use stack to retrieve status
1ded : 48              >            pha
                       >            cmp_flag ~fn
1dee : c97f            >            cmp #(~fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1df0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1df2 : 28              >            plp         ;restore status
                        
1df3 : 88                       dey
1df4 : c40d                     cpy zp7f
                                tst_y $7e,~fzc
1df6 : 08              >            php         ;save flags
1df7 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1df9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dfb : 68              >            pla         ;load status
1dfc : 48              >            pha
                       >            cmp_flag ~fzc
1dfd : c9fc            >            cmp #(~fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1dff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e01 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1e02 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1e04 : 48              >            pha         ;use stack to load status
1e05 : a080            >            ldy #$80     ;precharge index y
1e07 : 28              >            plp
                        
1e08 : cc1b02                   cpy abs7f
                                tst_stat fc
1e0b : 08              >            php         ;save status
1e0c : 68              >            pla         ;use stack to retrieve status
1e0d : 48              >            pha
                       >            cmp_flag fc
1e0e : c935            >            cmp #(fc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1e10 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e12 : 28              >            plp         ;restore status
                        
1e13 : 88                       dey
1e14 : cc1b02                   cpy abs7f
                                tst_stat fzc
1e17 : 08              >            php         ;save status
1e18 : 68              >            pla         ;use stack to retrieve status
1e19 : 48              >            pha
                       >            cmp_flag fzc
1e1a : c937            >            cmp #(fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1e1c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e1e : 28              >            plp         ;restore status
                        
1e1f : 88                       dey
1e20 : cc1b02                   cpy abs7f
                                tst_y $7e,fn
1e23 : 08              >            php         ;save flags
1e24 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e26 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e28 : 68              >            pla         ;load status
1e29 : 48              >            pha
                       >            cmp_flag fn
1e2a : c9b4            >            cmp #(fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1e2c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e2e : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1e2f : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1e31 : 48              >            pha         ;use stack to load status
1e32 : a080            >            ldy #$80     ;precharge index y
1e34 : 28              >            plp
                        
1e35 : cc1b02                   cpy abs7f
                                tst_stat ~fnz
1e38 : 08              >            php         ;save status
1e39 : 68              >            pla         ;use stack to retrieve status
1e3a : 48              >            pha
                       >            cmp_flag ~fnz
1e3b : c97d            >            cmp #(~fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1e3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e3f : 28              >            plp         ;restore status
                        
1e40 : 88                       dey
1e41 : cc1b02                   cpy abs7f
                                tst_stat ~fn
1e44 : 08              >            php         ;save status
1e45 : 68              >            pla         ;use stack to retrieve status
1e46 : 48              >            pha
                       >            cmp_flag ~fn
1e47 : c97f            >            cmp #(~fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1e49 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e4b : 28              >            plp         ;restore status
                        
1e4c : 88                       dey
1e4d : cc1b02                   cpy abs7f
                                tst_y $7e,~fzc
1e50 : 08              >            php         ;save flags
1e51 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e53 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e55 : 68              >            pla         ;load status
1e56 : 48              >            pha
                       >            cmp_flag ~fzc
1e57 : c9fc            >            cmp #(~fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1e59 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e5b : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1e5c : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1e5e : 48              >            pha         ;use stack to load status
1e5f : a080            >            ldy #$80     ;precharge index y
1e61 : 28              >            plp
                        
1e62 : c07f                     cpy #$7f
                                tst_stat fc
1e64 : 08              >            php         ;save status
1e65 : 68              >            pla         ;use stack to retrieve status
1e66 : 48              >            pha
                       >            cmp_flag fc
1e67 : c935            >            cmp #(fc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1e69 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e6b : 28              >            plp         ;restore status
                        
1e6c : 88                       dey
1e6d : c07f                     cpy #$7f
                                tst_stat fzc
1e6f : 08              >            php         ;save status
1e70 : 68              >            pla         ;use stack to retrieve status
1e71 : 48              >            pha
                       >            cmp_flag fzc
1e72 : c937            >            cmp #(fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1e74 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e76 : 28              >            plp         ;restore status
                        
1e77 : 88                       dey
1e78 : c07f                     cpy #$7f
                                tst_y $7e,fn
1e7a : 08              >            php         ;save flags
1e7b : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e7d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e7f : 68              >            pla         ;load status
1e80 : 48              >            pha
                       >            cmp_flag fn
1e81 : c9b4            >            cmp #(fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1e83 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e85 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1e86 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1e88 : 48              >            pha         ;use stack to load status
1e89 : a080            >            ldy #$80     ;precharge index y
1e8b : 28              >            plp
                        
1e8c : c07f                     cpy #$7f
                                tst_stat ~fnz
1e8e : 08              >            php         ;save status
1e8f : 68              >            pla         ;use stack to retrieve status
1e90 : 48              >            pha
                       >            cmp_flag ~fnz
1e91 : c97d            >            cmp #(~fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1e93 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e95 : 28              >            plp         ;restore status
                        
1e96 : 88                       dey
1e97 : c07f                     cpy #$7f
                                tst_stat ~fn
1e99 : 08              >            php         ;save status
1e9a : 68              >            pla         ;use stack to retrieve status
1e9b : 48              >            pha
                       >            cmp_flag ~fn
1e9c : c97f            >            cmp #(~fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1e9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ea0 : 28              >            plp         ;restore status
                        
1ea1 : 88                       dey
1ea2 : c07f                     cpy #$7f
                                tst_y $7e,~fzc
1ea4 : 08              >            php         ;save flags
1ea5 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1ea7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ea9 : 68              >            pla         ;load status
1eaa : 48              >            pha
                       >            cmp_flag ~fzc
1eab : c9fc            >            cmp #(~fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1ead : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eaf : 28              >            plp         ;restore status
                        
                                next_test
1eb0 : ad0002          >            lda test_case   ;previous test
1eb3 : c91b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1eb5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001c =                 >test_num = test_num + 1
1eb7 : a91c            >            lda #test_num   ;*** next tests' number
1eb9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CMP - zp / abs / #         
                                set_a $80,0
                       >            load_flag 0
1ebc : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1ebe : 48              >            pha         ;use stack to load status
1ebf : a980            >            lda #$80     ;precharge accu
1ec1 : 28              >            plp
                        
1ec2 : c50d                     cmp zp7f
                                tst_a $80,fc
1ec4 : 08              >            php         ;save flags
1ec5 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1ec7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ec9 : 68              >            pla         ;load status
1eca : 48              >            pha
                       >            cmp_flag fc
1ecb : c935            >            cmp #(fc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1ecd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ecf : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1ed0 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1ed2 : 48              >            pha         ;use stack to load status
1ed3 : a97f            >            lda #$7f     ;precharge accu
1ed5 : 28              >            plp
                        
1ed6 : c50d                     cmp zp7f
                                tst_a $7f,fzc
1ed8 : 08              >            php         ;save flags
1ed9 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1edb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1edd : 68              >            pla         ;load status
1ede : 48              >            pha
                       >            cmp_flag fzc
1edf : c937            >            cmp #(fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1ee1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ee3 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1ee4 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1ee6 : 48              >            pha         ;use stack to load status
1ee7 : a97e            >            lda #$7e     ;precharge accu
1ee9 : 28              >            plp
                        
1eea : c50d                     cmp zp7f
                                tst_a $7e,fn
1eec : 08              >            php         ;save flags
1eed : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1eef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ef1 : 68              >            pla         ;load status
1ef2 : 48              >            pha
                       >            cmp_flag fn
1ef3 : c9b4            >            cmp #(fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1ef5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ef7 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1ef8 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1efa : 48              >            pha         ;use stack to load status
1efb : a980            >            lda #$80     ;precharge accu
1efd : 28              >            plp
                        
1efe : c50d                     cmp zp7f
                                tst_a $80,~fnz
1f00 : 08              >            php         ;save flags
1f01 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f03 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f05 : 68              >            pla         ;load status
1f06 : 48              >            pha
                       >            cmp_flag ~fnz
1f07 : c97d            >            cmp #(~fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1f09 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f0b : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1f0c : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1f0e : 48              >            pha         ;use stack to load status
1f0f : a97f            >            lda #$7f     ;precharge accu
1f11 : 28              >            plp
                        
1f12 : c50d                     cmp zp7f
                                tst_a $7f,~fn
1f14 : 08              >            php         ;save flags
1f15 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f17 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f19 : 68              >            pla         ;load status
1f1a : 48              >            pha
                       >            cmp_flag ~fn
1f1b : c97f            >            cmp #(~fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1f1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f1f : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1f20 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1f22 : 48              >            pha         ;use stack to load status
1f23 : a97e            >            lda #$7e     ;precharge accu
1f25 : 28              >            plp
                        
1f26 : c50d                     cmp zp7f
                                tst_a $7e,~fzc
1f28 : 08              >            php         ;save flags
1f29 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f2b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f2d : 68              >            pla         ;load status
1f2e : 48              >            pha
                       >            cmp_flag ~fzc
1f2f : c9fc            >            cmp #(~fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1f31 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f33 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1f34 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1f36 : 48              >            pha         ;use stack to load status
1f37 : a980            >            lda #$80     ;precharge accu
1f39 : 28              >            plp
                        
1f3a : cd1b02                   cmp abs7f
                                tst_a $80,fc
1f3d : 08              >            php         ;save flags
1f3e : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f40 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f42 : 68              >            pla         ;load status
1f43 : 48              >            pha
                       >            cmp_flag fc
1f44 : c935            >            cmp #(fc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1f46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f48 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1f49 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1f4b : 48              >            pha         ;use stack to load status
1f4c : a97f            >            lda #$7f     ;precharge accu
1f4e : 28              >            plp
                        
1f4f : cd1b02                   cmp abs7f
                                tst_a $7f,fzc
1f52 : 08              >            php         ;save flags
1f53 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f55 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f57 : 68              >            pla         ;load status
1f58 : 48              >            pha
                       >            cmp_flag fzc
1f59 : c937            >            cmp #(fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1f5b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f5d : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1f5e : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1f60 : 48              >            pha         ;use stack to load status
1f61 : a97e            >            lda #$7e     ;precharge accu
1f63 : 28              >            plp
                        
1f64 : cd1b02                   cmp abs7f
                                tst_a $7e,fn
1f67 : 08              >            php         ;save flags
1f68 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f6c : 68              >            pla         ;load status
1f6d : 48              >            pha
                       >            cmp_flag fn
1f6e : c9b4            >            cmp #(fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1f70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f72 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1f73 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1f75 : 48              >            pha         ;use stack to load status
1f76 : a980            >            lda #$80     ;precharge accu
1f78 : 28              >            plp
                        
1f79 : cd1b02                   cmp abs7f
                                tst_a $80,~fnz
1f7c : 08              >            php         ;save flags
1f7d : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f7f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f81 : 68              >            pla         ;load status
1f82 : 48              >            pha
                       >            cmp_flag ~fnz
1f83 : c97d            >            cmp #(~fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1f85 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f87 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1f88 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1f8a : 48              >            pha         ;use stack to load status
1f8b : a97f            >            lda #$7f     ;precharge accu
1f8d : 28              >            plp
                        
1f8e : cd1b02                   cmp abs7f
                                tst_a $7f,~fn
1f91 : 08              >            php         ;save flags
1f92 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f96 : 68              >            pla         ;load status
1f97 : 48              >            pha
                       >            cmp_flag ~fn
1f98 : c97f            >            cmp #(~fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1f9a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f9c : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1f9d : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1f9f : 48              >            pha         ;use stack to load status
1fa0 : a97e            >            lda #$7e     ;precharge accu
1fa2 : 28              >            plp
                        
1fa3 : cd1b02                   cmp abs7f
                                tst_a $7e,~fzc
1fa6 : 08              >            php         ;save flags
1fa7 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1fa9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fab : 68              >            pla         ;load status
1fac : 48              >            pha
                       >            cmp_flag ~fzc
1fad : c9fc            >            cmp #(~fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1faf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fb1 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1fb2 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1fb4 : 48              >            pha         ;use stack to load status
1fb5 : a980            >            lda #$80     ;precharge accu
1fb7 : 28              >            plp
                        
1fb8 : c97f                     cmp #$7f
                                tst_a $80,fc
1fba : 08              >            php         ;save flags
1fbb : c980            >            cmp #$80     ;test result
                       >            trap_ne
1fbd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fbf : 68              >            pla         ;load status
1fc0 : 48              >            pha
                       >            cmp_flag fc
1fc1 : c935            >            cmp #(fc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1fc3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fc5 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1fc6 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1fc8 : 48              >            pha         ;use stack to load status
1fc9 : a97f            >            lda #$7f     ;precharge accu
1fcb : 28              >            plp
                        
1fcc : c97f                     cmp #$7f
                                tst_a $7f,fzc
1fce : 08              >            php         ;save flags
1fcf : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1fd1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fd3 : 68              >            pla         ;load status
1fd4 : 48              >            pha
                       >            cmp_flag fzc
1fd5 : c937            >            cmp #(fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1fd7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fd9 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1fda : a904            >            lda #0|intdis      ;force disable interrupts
                       >
1fdc : 48              >            pha         ;use stack to load status
1fdd : a97e            >            lda #$7e     ;precharge accu
1fdf : 28              >            plp
                        
1fe0 : c97f                     cmp #$7f
                                tst_a $7e,fn
1fe2 : 08              >            php         ;save flags
1fe3 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1fe5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fe7 : 68              >            pla         ;load status
1fe8 : 48              >            pha
                       >            cmp_flag fn
1fe9 : c9b4            >            cmp #(fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1feb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fed : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1fee : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
1ff0 : 48              >            pha         ;use stack to load status
1ff1 : a980            >            lda #$80     ;precharge accu
1ff3 : 28              >            plp
                        
1ff4 : c97f                     cmp #$7f
                                tst_a $80,~fnz
1ff6 : 08              >            php         ;save flags
1ff7 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1ff9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ffb : 68              >            pla         ;load status
1ffc : 48              >            pha
                       >            cmp_flag ~fnz
1ffd : c97d            >            cmp #(~fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
1fff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2001 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2002 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2004 : 48              >            pha         ;use stack to load status
2005 : a97f            >            lda #$7f     ;precharge accu
2007 : 28              >            plp
                        
2008 : c97f                     cmp #$7f
                                tst_a $7f,~fn
200a : 08              >            php         ;save flags
200b : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
200d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
200f : 68              >            pla         ;load status
2010 : 48              >            pha
                       >            cmp_flag ~fn
2011 : c97f            >            cmp #(~fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
2013 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2015 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2016 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2018 : 48              >            pha         ;use stack to load status
2019 : a97e            >            lda #$7e     ;precharge accu
201b : 28              >            plp
                        
201c : c97f                     cmp #$7f
                                tst_a $7e,~fzc
201e : 08              >            php         ;save flags
201f : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2021 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2023 : 68              >            pla         ;load status
2024 : 48              >            pha
                       >            cmp_flag ~fzc
2025 : c9fc            >            cmp #(~fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
2027 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2029 : 28              >            plp         ;restore status
                        
                        
202a : a204                     ldx #4          ;with indexing by X
                                set_a $80,0
                       >            load_flag 0
202c : a904            >            lda #0|intdis      ;force disable interrupts
                       >
202e : 48              >            pha         ;use stack to load status
202f : a980            >            lda #$80     ;precharge accu
2031 : 28              >            plp
                        
2032 : d509                     cmp zp1,x
                                tst_a $80,fc
2034 : 08              >            php         ;save flags
2035 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2037 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2039 : 68              >            pla         ;load status
203a : 48              >            pha
                       >            cmp_flag fc
203b : c935            >            cmp #(fc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
203d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
203f : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2040 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2042 : 48              >            pha         ;use stack to load status
2043 : a97f            >            lda #$7f     ;precharge accu
2045 : 28              >            plp
                        
2046 : d509                     cmp zp1,x
                                tst_a $7f,fzc
2048 : 08              >            php         ;save flags
2049 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
204b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
204d : 68              >            pla         ;load status
204e : 48              >            pha
                       >            cmp_flag fzc
204f : c937            >            cmp #(fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
2051 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2053 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2054 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2056 : 48              >            pha         ;use stack to load status
2057 : a97e            >            lda #$7e     ;precharge accu
2059 : 28              >            plp
                        
205a : d509                     cmp zp1,x
                                tst_a $7e,fn
205c : 08              >            php         ;save flags
205d : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
205f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2061 : 68              >            pla         ;load status
2062 : 48              >            pha
                       >            cmp_flag fn
2063 : c9b4            >            cmp #(fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
2065 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2067 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2068 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
206a : 48              >            pha         ;use stack to load status
206b : a980            >            lda #$80     ;precharge accu
206d : 28              >            plp
                        
206e : d509                     cmp zp1,x
                                tst_a $80,~fnz
2070 : 08              >            php         ;save flags
2071 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2073 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2075 : 68              >            pla         ;load status
2076 : 48              >            pha
                       >            cmp_flag ~fnz
2077 : c97d            >            cmp #(~fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
2079 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
207b : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
207c : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
207e : 48              >            pha         ;use stack to load status
207f : a97f            >            lda #$7f     ;precharge accu
2081 : 28              >            plp
                        
2082 : d509                     cmp zp1,x
                                tst_a $7f,~fn
2084 : 08              >            php         ;save flags
2085 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2087 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2089 : 68              >            pla         ;load status
208a : 48              >            pha
                       >            cmp_flag ~fn
208b : c97f            >            cmp #(~fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
208d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
208f : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2090 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2092 : 48              >            pha         ;use stack to load status
2093 : a97e            >            lda #$7e     ;precharge accu
2095 : 28              >            plp
                        
2096 : d509                     cmp zp1,x
                                tst_a $7e,~fzc
2098 : 08              >            php         ;save flags
2099 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
209b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
209d : 68              >            pla         ;load status
209e : 48              >            pha
                       >            cmp_flag ~fzc
209f : c9fc            >            cmp #(~fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
20a1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20a3 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
20a4 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
20a6 : 48              >            pha         ;use stack to load status
20a7 : a980            >            lda #$80     ;precharge accu
20a9 : 28              >            plp
                        
20aa : dd1702                   cmp abs1,x
                                tst_a $80,fc
20ad : 08              >            php         ;save flags
20ae : c980            >            cmp #$80     ;test result
                       >            trap_ne
20b0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20b2 : 68              >            pla         ;load status
20b3 : 48              >            pha
                       >            cmp_flag fc
20b4 : c935            >            cmp #(fc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
20b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20b8 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
20b9 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
20bb : 48              >            pha         ;use stack to load status
20bc : a97f            >            lda #$7f     ;precharge accu
20be : 28              >            plp
                        
20bf : dd1702                   cmp abs1,x
                                tst_a $7f,fzc
20c2 : 08              >            php         ;save flags
20c3 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
20c5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20c7 : 68              >            pla         ;load status
20c8 : 48              >            pha
                       >            cmp_flag fzc
20c9 : c937            >            cmp #(fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
20cb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20cd : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
20ce : a904            >            lda #0|intdis      ;force disable interrupts
                       >
20d0 : 48              >            pha         ;use stack to load status
20d1 : a97e            >            lda #$7e     ;precharge accu
20d3 : 28              >            plp
                        
20d4 : dd1702                   cmp abs1,x
                                tst_a $7e,fn
20d7 : 08              >            php         ;save flags
20d8 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20dc : 68              >            pla         ;load status
20dd : 48              >            pha
                       >            cmp_flag fn
20de : c9b4            >            cmp #(fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
20e0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20e2 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
20e3 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
20e5 : 48              >            pha         ;use stack to load status
20e6 : a980            >            lda #$80     ;precharge accu
20e8 : 28              >            plp
                        
20e9 : dd1702                   cmp abs1,x
                                tst_a $80,~fnz
20ec : 08              >            php         ;save flags
20ed : c980            >            cmp #$80     ;test result
                       >            trap_ne
20ef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20f1 : 68              >            pla         ;load status
20f2 : 48              >            pha
                       >            cmp_flag ~fnz
20f3 : c97d            >            cmp #(~fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
20f5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20f7 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
20f8 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
20fa : 48              >            pha         ;use stack to load status
20fb : a97f            >            lda #$7f     ;precharge accu
20fd : 28              >            plp
                        
20fe : dd1702                   cmp abs1,x
                                tst_a $7f,~fn
2101 : 08              >            php         ;save flags
2102 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2104 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2106 : 68              >            pla         ;load status
2107 : 48              >            pha
                       >            cmp_flag ~fn
2108 : c97f            >            cmp #(~fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
210a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
210c : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
210d : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
210f : 48              >            pha         ;use stack to load status
2110 : a97e            >            lda #$7e     ;precharge accu
2112 : 28              >            plp
                        
2113 : dd1702                   cmp abs1,x
                                tst_a $7e,~fzc
2116 : 08              >            php         ;save flags
2117 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2119 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
211b : 68              >            pla         ;load status
211c : 48              >            pha
                       >            cmp_flag ~fzc
211d : c9fc            >            cmp #(~fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
211f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2121 : 28              >            plp         ;restore status
                        
                        
2122 : a004                     ldy #4          ;with indexing by Y
2124 : a208                     ldx #8          ;with indexed indirect
                                set_a $80,0
                       >            load_flag 0
2126 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2128 : 48              >            pha         ;use stack to load status
2129 : a980            >            lda #$80     ;precharge accu
212b : 28              >            plp
                        
212c : d91702                   cmp abs1,y
                                tst_a $80,fc
212f : 08              >            php         ;save flags
2130 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2132 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2134 : 68              >            pla         ;load status
2135 : 48              >            pha
                       >            cmp_flag fc
2136 : c935            >            cmp #(fc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
2138 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
213a : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
213b : a904            >            lda #0|intdis      ;force disable interrupts
                       >
213d : 48              >            pha         ;use stack to load status
213e : a97f            >            lda #$7f     ;precharge accu
2140 : 28              >            plp
                        
2141 : d91702                   cmp abs1,y
                                tst_a $7f,fzc
2144 : 08              >            php         ;save flags
2145 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2147 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2149 : 68              >            pla         ;load status
214a : 48              >            pha
                       >            cmp_flag fzc
214b : c937            >            cmp #(fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
214d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
214f : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2150 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2152 : 48              >            pha         ;use stack to load status
2153 : a97e            >            lda #$7e     ;precharge accu
2155 : 28              >            plp
                        
2156 : d91702                   cmp abs1,y
                                tst_a $7e,fn
2159 : 08              >            php         ;save flags
215a : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
215c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
215e : 68              >            pla         ;load status
215f : 48              >            pha
                       >            cmp_flag fn
2160 : c9b4            >            cmp #(fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
2162 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2164 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2165 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2167 : 48              >            pha         ;use stack to load status
2168 : a980            >            lda #$80     ;precharge accu
216a : 28              >            plp
                        
216b : d91702                   cmp abs1,y
                                tst_a $80,~fnz
216e : 08              >            php         ;save flags
216f : c980            >            cmp #$80     ;test result
                       >            trap_ne
2171 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2173 : 68              >            pla         ;load status
2174 : 48              >            pha
                       >            cmp_flag ~fnz
2175 : c97d            >            cmp #(~fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
2177 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2179 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
217a : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
217c : 48              >            pha         ;use stack to load status
217d : a97f            >            lda #$7f     ;precharge accu
217f : 28              >            plp
                        
2180 : d91702                   cmp abs1,y
                                tst_a $7f,~fn
2183 : 08              >            php         ;save flags
2184 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2186 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2188 : 68              >            pla         ;load status
2189 : 48              >            pha
                       >            cmp_flag ~fn
218a : c97f            >            cmp #(~fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
218c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
218e : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
218f : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2191 : 48              >            pha         ;use stack to load status
2192 : a97e            >            lda #$7e     ;precharge accu
2194 : 28              >            plp
                        
2195 : d91702                   cmp abs1,y
                                tst_a $7e,~fzc
2198 : 08              >            php         ;save flags
2199 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
219b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
219d : 68              >            pla         ;load status
219e : 48              >            pha
                       >            cmp_flag ~fzc
219f : c9fc            >            cmp #(~fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
21a1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21a3 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
21a4 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
21a6 : 48              >            pha         ;use stack to load status
21a7 : a980            >            lda #$80     ;precharge accu
21a9 : 28              >            plp
                        
21aa : c11a                     cmp (ind1,x)
                                tst_a $80,fc
21ac : 08              >            php         ;save flags
21ad : c980            >            cmp #$80     ;test result
                       >            trap_ne
21af : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21b1 : 68              >            pla         ;load status
21b2 : 48              >            pha
                       >            cmp_flag fc
21b3 : c935            >            cmp #(fc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
21b5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21b7 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
21b8 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
21ba : 48              >            pha         ;use stack to load status
21bb : a97f            >            lda #$7f     ;precharge accu
21bd : 28              >            plp
                        
21be : c11a                     cmp (ind1,x)
                                tst_a $7f,fzc
21c0 : 08              >            php         ;save flags
21c1 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
21c3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21c5 : 68              >            pla         ;load status
21c6 : 48              >            pha
                       >            cmp_flag fzc
21c7 : c937            >            cmp #(fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
21c9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21cb : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
21cc : a904            >            lda #0|intdis      ;force disable interrupts
                       >
21ce : 48              >            pha         ;use stack to load status
21cf : a97e            >            lda #$7e     ;precharge accu
21d1 : 28              >            plp
                        
21d2 : c11a                     cmp (ind1,x)
                                tst_a $7e,fn
21d4 : 08              >            php         ;save flags
21d5 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
21d7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21d9 : 68              >            pla         ;load status
21da : 48              >            pha
                       >            cmp_flag fn
21db : c9b4            >            cmp #(fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
21dd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21df : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
21e0 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
21e2 : 48              >            pha         ;use stack to load status
21e3 : a980            >            lda #$80     ;precharge accu
21e5 : 28              >            plp
                        
21e6 : c11a                     cmp (ind1,x)
                                tst_a $80,~fnz
21e8 : 08              >            php         ;save flags
21e9 : c980            >            cmp #$80     ;test result
                       >            trap_ne
21eb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21ed : 68              >            pla         ;load status
21ee : 48              >            pha
                       >            cmp_flag ~fnz
21ef : c97d            >            cmp #(~fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
21f1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21f3 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
21f4 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
21f6 : 48              >            pha         ;use stack to load status
21f7 : a97f            >            lda #$7f     ;precharge accu
21f9 : 28              >            plp
                        
21fa : c11a                     cmp (ind1,x)
                                tst_a $7f,~fn
21fc : 08              >            php         ;save flags
21fd : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
21ff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2201 : 68              >            pla         ;load status
2202 : 48              >            pha
                       >            cmp_flag ~fn
2203 : c97f            >            cmp #(~fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
2205 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2207 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2208 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
220a : 48              >            pha         ;use stack to load status
220b : a97e            >            lda #$7e     ;precharge accu
220d : 28              >            plp
                        
220e : c11a                     cmp (ind1,x)
                                tst_a $7e,~fzc
2210 : 08              >            php         ;save flags
2211 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2213 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2215 : 68              >            pla         ;load status
2216 : 48              >            pha
                       >            cmp_flag ~fzc
2217 : c9fc            >            cmp #(~fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
2219 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
221b : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
221c : a904            >            lda #0|intdis      ;force disable interrupts
                       >
221e : 48              >            pha         ;use stack to load status
221f : a980            >            lda #$80     ;precharge accu
2221 : 28              >            plp
                        
2222 : d11a                     cmp (ind1),y
                                tst_a $80,fc
2224 : 08              >            php         ;save flags
2225 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2227 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2229 : 68              >            pla         ;load status
222a : 48              >            pha
                       >            cmp_flag fc
222b : c935            >            cmp #(fc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
222d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
222f : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2230 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2232 : 48              >            pha         ;use stack to load status
2233 : a97f            >            lda #$7f     ;precharge accu
2235 : 28              >            plp
                        
2236 : d11a                     cmp (ind1),y
                                tst_a $7f,fzc
2238 : 08              >            php         ;save flags
2239 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
223b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
223d : 68              >            pla         ;load status
223e : 48              >            pha
                       >            cmp_flag fzc
223f : c937            >            cmp #(fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
2241 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2243 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2244 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2246 : 48              >            pha         ;use stack to load status
2247 : a97e            >            lda #$7e     ;precharge accu
2249 : 28              >            plp
                        
224a : d11a                     cmp (ind1),y
                                tst_a $7e,fn
224c : 08              >            php         ;save flags
224d : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
224f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2251 : 68              >            pla         ;load status
2252 : 48              >            pha
                       >            cmp_flag fn
2253 : c9b4            >            cmp #(fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
2255 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2257 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2258 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
225a : 48              >            pha         ;use stack to load status
225b : a980            >            lda #$80     ;precharge accu
225d : 28              >            plp
                        
225e : d11a                     cmp (ind1),y
                                tst_a $80,~fnz
2260 : 08              >            php         ;save flags
2261 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2263 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2265 : 68              >            pla         ;load status
2266 : 48              >            pha
                       >            cmp_flag ~fnz
2267 : c97d            >            cmp #(~fnz|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
2269 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
226b : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
226c : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
226e : 48              >            pha         ;use stack to load status
226f : a97f            >            lda #$7f     ;precharge accu
2271 : 28              >            plp
                        
2272 : d11a                     cmp (ind1),y
                                tst_a $7f,~fn
2274 : 08              >            php         ;save flags
2275 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2277 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2279 : 68              >            pla         ;load status
227a : 48              >            pha
                       >            cmp_flag ~fn
227b : c97f            >            cmp #(~fn|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
227d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
227f : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2280 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2282 : 48              >            pha         ;use stack to load status
2283 : a97e            >            lda #$7e     ;precharge accu
2285 : 28              >            plp
                        
2286 : d11a                     cmp (ind1),y
                                tst_a $7e,~fzc
2288 : 08              >            php         ;save flags
2289 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
228b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
228d : 68              >            pla         ;load status
228e : 48              >            pha
                       >            cmp_flag ~fzc
228f : c9fc            >            cmp #(~fzc|fai)&m8    ;I_flag is always disabled + always on bits
                       >
                       >            trap_ne
2291 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2293 : 28              >            plp         ;restore status
                        
                                next_test
2294 : ad0002          >            lda test_case   ;previous test
2297 : c91c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2299 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001d =                 >test_num = test_num + 1
229b : a91d            >            lda #test_num   ;*** next tests' number
229d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing shifts - ASL LSR ROL ROR all addressing modes
                        ; shifts - accumulator
22a0 : a203                     ldx #3
22a2 :                  tasl
                                set_ax zp1,0
                       >            load_flag 0
22a2 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
22a4 : 48              >            pha         ;use stack to load status
22a5 : b509            >            lda zp1,x    ;precharge accu
22a7 : 28              >            plp
                        
22a8 : 0a                       asl a
                                tst_ax rASL,fASL,0
22a9 : 08              >            php         ;save flags
22aa : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
22ad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22af : 68              >            pla         ;load status
                       >            eor_flag 0
22b0 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
22b2 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
22b5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22b7 : ca                       dex
22b8 : 10e8                     bpl tasl
22ba : a203                     ldx #3
22bc :                  tasl1
                                set_ax zp1,$ff
                       >            load_flag $ff
22bc : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
22be : 48              >            pha         ;use stack to load status
22bf : b509            >            lda zp1,x    ;precharge accu
22c1 : 28              >            plp
                        
22c2 : 0a                       asl a
                                tst_ax rASL,fASL,$ff-fnzc
22c3 : 08              >            php         ;save flags
22c4 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
22c7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22c9 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
22ca : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
22cc : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
22cf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22d1 : ca                       dex
22d2 : 10e8                     bpl tasl1
                        
22d4 : a203                     ldx #3
22d6 :                  tlsr
                                set_ax zp1,0
                       >            load_flag 0
22d6 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
22d8 : 48              >            pha         ;use stack to load status
22d9 : b509            >            lda zp1,x    ;precharge accu
22db : 28              >            plp
                        
22dc : 4a                       lsr a
                                tst_ax rLSR,fLSR,0
22dd : 08              >            php         ;save flags
22de : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
22e1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22e3 : 68              >            pla         ;load status
                       >            eor_flag 0
22e4 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
22e6 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
22e9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22eb : ca                       dex
22ec : 10e8                     bpl tlsr
22ee : a203                     ldx #3
22f0 :                  tlsr1
                                set_ax zp1,$ff
                       >            load_flag $ff
22f0 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
22f2 : 48              >            pha         ;use stack to load status
22f3 : b509            >            lda zp1,x    ;precharge accu
22f5 : 28              >            plp
                        
22f6 : 4a                       lsr a
                                tst_ax rLSR,fLSR,$ff-fnzc
22f7 : 08              >            php         ;save flags
22f8 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
22fb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22fd : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
22fe : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
2300 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
2303 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2305 : ca                       dex
2306 : 10e8                     bpl tlsr1
                        
2308 : a203                     ldx #3
230a :                  trol
                                set_ax zp1,0
                       >            load_flag 0
230a : a904            >            lda #0|intdis      ;force disable interrupts
                       >
230c : 48              >            pha         ;use stack to load status
230d : b509            >            lda zp1,x    ;precharge accu
230f : 28              >            plp
                        
2310 : 2a                       rol a
                                tst_ax rROL,fROL,0
2311 : 08              >            php         ;save flags
2312 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2315 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2317 : 68              >            pla         ;load status
                       >            eor_flag 0
2318 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
231a : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
231d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
231f : ca                       dex
2320 : 10e8                     bpl trol
2322 : a203                     ldx #3
2324 :                  trol1
                                set_ax zp1,$ff-fc
                       >            load_flag $ff-fc
2324 : a9fe            >            lda #$ff-fc|intdis      ;force disable interrupts
                       >
2326 : 48              >            pha         ;use stack to load status
2327 : b509            >            lda zp1,x    ;precharge accu
2329 : 28              >            plp
                        
232a : 2a                       rol a
                                tst_ax rROL,fROL,$ff-fnzc
232b : 08              >            php         ;save flags
232c : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
232f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2331 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2332 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
2334 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
2337 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2339 : ca                       dex
233a : 10e8                     bpl trol1
                        
233c : a203                     ldx #3
233e :                  trolc
                                set_ax zp1,fc
                       >            load_flag fc
233e : a905            >            lda #fc|intdis      ;force disable interrupts
                       >
2340 : 48              >            pha         ;use stack to load status
2341 : b509            >            lda zp1,x    ;precharge accu
2343 : 28              >            plp
                        
2344 : 2a                       rol a
                                tst_ax rROLc,fROLc,0
2345 : 08              >            php         ;save flags
2346 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2349 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
234b : 68              >            pla         ;load status
                       >            eor_flag 0
234c : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
234e : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
2351 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2353 : ca                       dex
2354 : 10e8                     bpl trolc
2356 : a203                     ldx #3
2358 :                  trolc1
                                set_ax zp1,$ff
                       >            load_flag $ff
2358 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
235a : 48              >            pha         ;use stack to load status
235b : b509            >            lda zp1,x    ;precharge accu
235d : 28              >            plp
                        
235e : 2a                       rol a
                                tst_ax rROLc,fROLc,$ff-fnzc
235f : 08              >            php         ;save flags
2360 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2363 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2365 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2366 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
2368 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
236b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
236d : ca                       dex
236e : 10e8                     bpl trolc1
                        
2370 : a203                     ldx #3
2372 :                  tror
                                set_ax zp1,0
                       >            load_flag 0
2372 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2374 : 48              >            pha         ;use stack to load status
2375 : b509            >            lda zp1,x    ;precharge accu
2377 : 28              >            plp
                        
2378 : 6a                       ror a
                                tst_ax rROR,fROR,0
2379 : 08              >            php         ;save flags
237a : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
237d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
237f : 68              >            pla         ;load status
                       >            eor_flag 0
2380 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2382 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
2385 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2387 : ca                       dex
2388 : 10e8                     bpl tror
238a : a203                     ldx #3
238c :                  tror1
                                set_ax zp1,$ff-fc
                       >            load_flag $ff-fc
238c : a9fe            >            lda #$ff-fc|intdis      ;force disable interrupts
                       >
238e : 48              >            pha         ;use stack to load status
238f : b509            >            lda zp1,x    ;precharge accu
2391 : 28              >            plp
                        
2392 : 6a                       ror a
                                tst_ax rROR,fROR,$ff-fnzc
2393 : 08              >            php         ;save flags
2394 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2397 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2399 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
239a : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
239c : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
239f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23a1 : ca                       dex
23a2 : 10e8                     bpl tror1
                        
23a4 : a203                     ldx #3
23a6 :                  trorc
                                set_ax zp1,fc
                       >            load_flag fc
23a6 : a905            >            lda #fc|intdis      ;force disable interrupts
                       >
23a8 : 48              >            pha         ;use stack to load status
23a9 : b509            >            lda zp1,x    ;precharge accu
23ab : 28              >            plp
                        
23ac : 6a                       ror a
                                tst_ax rRORc,fRORc,0
23ad : 08              >            php         ;save flags
23ae : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
23b1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23b3 : 68              >            pla         ;load status
                       >            eor_flag 0
23b4 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
23b6 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
23b9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23bb : ca                       dex
23bc : 10e8                     bpl trorc
23be : a203                     ldx #3
23c0 :                  trorc1
                                set_ax zp1,$ff
                       >            load_flag $ff
23c0 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
23c2 : 48              >            pha         ;use stack to load status
23c3 : b509            >            lda zp1,x    ;precharge accu
23c5 : 28              >            plp
                        
23c6 : 6a                       ror a
                                tst_ax rRORc,fRORc,$ff-fnzc
23c7 : 08              >            php         ;save flags
23c8 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
23cb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23cd : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
23ce : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
23d0 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
23d3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23d5 : ca                       dex
23d6 : 10e8                     bpl trorc1
                                next_test
23d8 : ad0002          >            lda test_case   ;previous test
23db : c91d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
23dd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001e =                 >test_num = test_num + 1
23df : a91e            >            lda #test_num   ;*** next tests' number
23e1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zeropage
23e4 : a203                     ldx #3
23e6 :                  tasl2
                                set_z zp1,0
                       >            load_flag 0
23e6 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
23e8 : 48              >            pha         ;use stack to load status
23e9 : b509            >            lda zp1,x    ;load to zeropage
23eb : 8502            >            sta zpt
23ed : 28              >            plp
                        
23ee : 0602                     asl zpt
                                tst_z rASL,fASL,0
23f0 : 08              >            php         ;save flags
23f1 : a502            >            lda zpt
23f3 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
23f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23f8 : 68              >            pla         ;load status
                       >            eor_flag 0
23f9 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
23fb : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
23fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2400 : ca                       dex
2401 : 10e3                     bpl tasl2
2403 : a203                     ldx #3
2405 :                  tasl3
                                set_z zp1,$ff
                       >            load_flag $ff
2405 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2407 : 48              >            pha         ;use stack to load status
2408 : b509            >            lda zp1,x    ;load to zeropage
240a : 8502            >            sta zpt
240c : 28              >            plp
                        
240d : 0602                     asl zpt
                                tst_z rASL,fASL,$ff-fnzc
240f : 08              >            php         ;save flags
2410 : a502            >            lda zpt
2412 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2415 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2417 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2418 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
241a : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
241d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
241f : ca                       dex
2420 : 10e3                     bpl tasl3
                        
2422 : a203                     ldx #3
2424 :                  tlsr2
                                set_z zp1,0
                       >            load_flag 0
2424 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2426 : 48              >            pha         ;use stack to load status
2427 : b509            >            lda zp1,x    ;load to zeropage
2429 : 8502            >            sta zpt
242b : 28              >            plp
                        
242c : 4602                     lsr zpt
                                tst_z rLSR,fLSR,0
242e : 08              >            php         ;save flags
242f : a502            >            lda zpt
2431 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2434 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2436 : 68              >            pla         ;load status
                       >            eor_flag 0
2437 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2439 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
243c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
243e : ca                       dex
243f : 10e3                     bpl tlsr2
2441 : a203                     ldx #3
2443 :                  tlsr3
                                set_z zp1,$ff
                       >            load_flag $ff
2443 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2445 : 48              >            pha         ;use stack to load status
2446 : b509            >            lda zp1,x    ;load to zeropage
2448 : 8502            >            sta zpt
244a : 28              >            plp
                        
244b : 4602                     lsr zpt
                                tst_z rLSR,fLSR,$ff-fnzc
244d : 08              >            php         ;save flags
244e : a502            >            lda zpt
2450 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2453 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2455 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2456 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
2458 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
245b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
245d : ca                       dex
245e : 10e3                     bpl tlsr3
                        
2460 : a203                     ldx #3
2462 :                  trol2
                                set_z zp1,0
                       >            load_flag 0
2462 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2464 : 48              >            pha         ;use stack to load status
2465 : b509            >            lda zp1,x    ;load to zeropage
2467 : 8502            >            sta zpt
2469 : 28              >            plp
                        
246a : 2602                     rol zpt
                                tst_z rROL,fROL,0
246c : 08              >            php         ;save flags
246d : a502            >            lda zpt
246f : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2472 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2474 : 68              >            pla         ;load status
                       >            eor_flag 0
2475 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2477 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
247a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
247c : ca                       dex
247d : 10e3                     bpl trol2
247f : a203                     ldx #3
2481 :                  trol3
                                set_z zp1,$ff-fc
                       >            load_flag $ff-fc
2481 : a9fe            >            lda #$ff-fc|intdis      ;force disable interrupts
                       >
2483 : 48              >            pha         ;use stack to load status
2484 : b509            >            lda zp1,x    ;load to zeropage
2486 : 8502            >            sta zpt
2488 : 28              >            plp
                        
2489 : 2602                     rol zpt
                                tst_z rROL,fROL,$ff-fnzc
248b : 08              >            php         ;save flags
248c : a502            >            lda zpt
248e : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2491 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2493 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2494 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
2496 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2499 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
249b : ca                       dex
249c : 10e3                     bpl trol3
                        
249e : a203                     ldx #3
24a0 :                  trolc2
                                set_z zp1,fc
                       >            load_flag fc
24a0 : a905            >            lda #fc|intdis      ;force disable interrupts
                       >
24a2 : 48              >            pha         ;use stack to load status
24a3 : b509            >            lda zp1,x    ;load to zeropage
24a5 : 8502            >            sta zpt
24a7 : 28              >            plp
                        
24a8 : 2602                     rol zpt
                                tst_z rROLc,fROLc,0
24aa : 08              >            php         ;save flags
24ab : a502            >            lda zpt
24ad : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
24b0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24b2 : 68              >            pla         ;load status
                       >            eor_flag 0
24b3 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
24b5 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
24b8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24ba : ca                       dex
24bb : 10e3                     bpl trolc2
24bd : a203                     ldx #3
24bf :                  trolc3
                                set_z zp1,$ff
                       >            load_flag $ff
24bf : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
24c1 : 48              >            pha         ;use stack to load status
24c2 : b509            >            lda zp1,x    ;load to zeropage
24c4 : 8502            >            sta zpt
24c6 : 28              >            plp
                        
24c7 : 2602                     rol zpt
                                tst_z rROLc,fROLc,$ff-fnzc
24c9 : 08              >            php         ;save flags
24ca : a502            >            lda zpt
24cc : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
24cf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24d1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
24d2 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
24d4 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
24d7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24d9 : ca                       dex
24da : 10e3                     bpl trolc3
                        
24dc : a203                     ldx #3
24de :                  tror2
                                set_z zp1,0
                       >            load_flag 0
24de : a904            >            lda #0|intdis      ;force disable interrupts
                       >
24e0 : 48              >            pha         ;use stack to load status
24e1 : b509            >            lda zp1,x    ;load to zeropage
24e3 : 8502            >            sta zpt
24e5 : 28              >            plp
                        
24e6 : 6602                     ror zpt
                                tst_z rROR,fROR,0
24e8 : 08              >            php         ;save flags
24e9 : a502            >            lda zpt
24eb : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
24ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24f0 : 68              >            pla         ;load status
                       >            eor_flag 0
24f1 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
24f3 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
24f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24f8 : ca                       dex
24f9 : 10e3                     bpl tror2
24fb : a203                     ldx #3
24fd :                  tror3
                                set_z zp1,$ff-fc
                       >            load_flag $ff-fc
24fd : a9fe            >            lda #$ff-fc|intdis      ;force disable interrupts
                       >
24ff : 48              >            pha         ;use stack to load status
2500 : b509            >            lda zp1,x    ;load to zeropage
2502 : 8502            >            sta zpt
2504 : 28              >            plp
                        
2505 : 6602                     ror zpt
                                tst_z rROR,fROR,$ff-fnzc
2507 : 08              >            php         ;save flags
2508 : a502            >            lda zpt
250a : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
250d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
250f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2510 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
2512 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2515 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2517 : ca                       dex
2518 : 10e3                     bpl tror3
                        
251a : a203                     ldx #3
251c :                  trorc2
                                set_z zp1,fc
                       >            load_flag fc
251c : a905            >            lda #fc|intdis      ;force disable interrupts
                       >
251e : 48              >            pha         ;use stack to load status
251f : b509            >            lda zp1,x    ;load to zeropage
2521 : 8502            >            sta zpt
2523 : 28              >            plp
                        
2524 : 6602                     ror zpt
                                tst_z rRORc,fRORc,0
2526 : 08              >            php         ;save flags
2527 : a502            >            lda zpt
2529 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
252c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
252e : 68              >            pla         ;load status
                       >            eor_flag 0
252f : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2531 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2534 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2536 : ca                       dex
2537 : 10e3                     bpl trorc2
2539 : a203                     ldx #3
253b :                  trorc3
                                set_z zp1,$ff
                       >            load_flag $ff
253b : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
253d : 48              >            pha         ;use stack to load status
253e : b509            >            lda zp1,x    ;load to zeropage
2540 : 8502            >            sta zpt
2542 : 28              >            plp
                        
2543 : 6602                     ror zpt
                                tst_z rRORc,fRORc,$ff-fnzc
2545 : 08              >            php         ;save flags
2546 : a502            >            lda zpt
2548 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
254b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
254d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
254e : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
2550 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2553 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2555 : ca                       dex
2556 : 10e3                     bpl trorc3
                                next_test
2558 : ad0002          >            lda test_case   ;previous test
255b : c91e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
255d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001f =                 >test_num = test_num + 1
255f : a91f            >            lda #test_num   ;*** next tests' number
2561 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - absolute
2564 : a203                     ldx #3
2566 :                  tasl4
                                set_abs zp1,0
                       >            load_flag 0
2566 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2568 : 48              >            pha         ;use stack to load status
2569 : b509            >            lda zp1,x    ;load to memory
256b : 8d0302          >            sta abst
256e : 28              >            plp
                        
256f : 0e0302                   asl abst
                                tst_abs rASL,fASL,0
2572 : 08              >            php         ;save flags
2573 : ad0302          >            lda abst
2576 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2579 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
257b : 68              >            pla         ;load status
                       >            eor_flag 0
257c : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
257e : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2581 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2583 : ca                       dex
2584 : 10e0                     bpl tasl4
2586 : a203                     ldx #3
2588 :                  tasl5
                                set_abs zp1,$ff
                       >            load_flag $ff
2588 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
258a : 48              >            pha         ;use stack to load status
258b : b509            >            lda zp1,x    ;load to memory
258d : 8d0302          >            sta abst
2590 : 28              >            plp
                        
2591 : 0e0302                   asl abst
                                tst_abs rASL,fASL,$ff-fnzc
2594 : 08              >            php         ;save flags
2595 : ad0302          >            lda abst
2598 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
259b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
259d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
259e : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
25a0 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
25a3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25a5 : ca                       dex
25a6 : 10e0                     bpl tasl5
                        
25a8 : a203                     ldx #3
25aa :                  tlsr4
                                set_abs zp1,0
                       >            load_flag 0
25aa : a904            >            lda #0|intdis      ;force disable interrupts
                       >
25ac : 48              >            pha         ;use stack to load status
25ad : b509            >            lda zp1,x    ;load to memory
25af : 8d0302          >            sta abst
25b2 : 28              >            plp
                        
25b3 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,0
25b6 : 08              >            php         ;save flags
25b7 : ad0302          >            lda abst
25ba : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
25bd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25bf : 68              >            pla         ;load status
                       >            eor_flag 0
25c0 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
25c2 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
25c5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25c7 : ca                       dex
25c8 : 10e0                     bpl tlsr4
25ca : a203                     ldx #3
25cc :                  tlsr5
                                set_abs zp1,$ff
                       >            load_flag $ff
25cc : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
25ce : 48              >            pha         ;use stack to load status
25cf : b509            >            lda zp1,x    ;load to memory
25d1 : 8d0302          >            sta abst
25d4 : 28              >            plp
                        
25d5 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,$ff-fnzc
25d8 : 08              >            php         ;save flags
25d9 : ad0302          >            lda abst
25dc : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
25df : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25e1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25e2 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
25e4 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
25e7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25e9 : ca                       dex
25ea : 10e0                     bpl tlsr5
                        
25ec : a203                     ldx #3
25ee :                  trol4
                                set_abs zp1,0
                       >            load_flag 0
25ee : a904            >            lda #0|intdis      ;force disable interrupts
                       >
25f0 : 48              >            pha         ;use stack to load status
25f1 : b509            >            lda zp1,x    ;load to memory
25f3 : 8d0302          >            sta abst
25f6 : 28              >            plp
                        
25f7 : 2e0302                   rol abst
                                tst_abs rROL,fROL,0
25fa : 08              >            php         ;save flags
25fb : ad0302          >            lda abst
25fe : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2601 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2603 : 68              >            pla         ;load status
                       >            eor_flag 0
2604 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2606 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2609 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
260b : ca                       dex
260c : 10e0                     bpl trol4
260e : a203                     ldx #3
2610 :                  trol5
                                set_abs zp1,$ff-fc
                       >            load_flag $ff-fc
2610 : a9fe            >            lda #$ff-fc|intdis      ;force disable interrupts
                       >
2612 : 48              >            pha         ;use stack to load status
2613 : b509            >            lda zp1,x    ;load to memory
2615 : 8d0302          >            sta abst
2618 : 28              >            plp
                        
2619 : 2e0302                   rol abst
                                tst_abs rROL,fROL,$ff-fnzc
261c : 08              >            php         ;save flags
261d : ad0302          >            lda abst
2620 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2623 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2625 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2626 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
2628 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
262b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
262d : ca                       dex
262e : 10e0                     bpl trol5
                        
2630 : a203                     ldx #3
2632 :                  trolc4
                                set_abs zp1,fc
                       >            load_flag fc
2632 : a905            >            lda #fc|intdis      ;force disable interrupts
                       >
2634 : 48              >            pha         ;use stack to load status
2635 : b509            >            lda zp1,x    ;load to memory
2637 : 8d0302          >            sta abst
263a : 28              >            plp
                        
263b : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,0
263e : 08              >            php         ;save flags
263f : ad0302          >            lda abst
2642 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2645 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2647 : 68              >            pla         ;load status
                       >            eor_flag 0
2648 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
264a : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
264d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
264f : ca                       dex
2650 : 10e0                     bpl trolc4
2652 : a203                     ldx #3
2654 :                  trolc5
                                set_abs zp1,$ff
                       >            load_flag $ff
2654 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2656 : 48              >            pha         ;use stack to load status
2657 : b509            >            lda zp1,x    ;load to memory
2659 : 8d0302          >            sta abst
265c : 28              >            plp
                        
265d : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,$ff-fnzc
2660 : 08              >            php         ;save flags
2661 : ad0302          >            lda abst
2664 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2667 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2669 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
266a : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
266c : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
266f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2671 : ca                       dex
2672 : 10e0                     bpl trolc5
                        
2674 : a203                     ldx #3
2676 :                  tror4
                                set_abs zp1,0
                       >            load_flag 0
2676 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2678 : 48              >            pha         ;use stack to load status
2679 : b509            >            lda zp1,x    ;load to memory
267b : 8d0302          >            sta abst
267e : 28              >            plp
                        
267f : 6e0302                   ror abst
                                tst_abs rROR,fROR,0
2682 : 08              >            php         ;save flags
2683 : ad0302          >            lda abst
2686 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2689 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
268b : 68              >            pla         ;load status
                       >            eor_flag 0
268c : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
268e : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2691 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2693 : ca                       dex
2694 : 10e0                     bpl tror4
2696 : a203                     ldx #3
2698 :                  tror5
                                set_abs zp1,$ff-fc
                       >            load_flag $ff-fc
2698 : a9fe            >            lda #$ff-fc|intdis      ;force disable interrupts
                       >
269a : 48              >            pha         ;use stack to load status
269b : b509            >            lda zp1,x    ;load to memory
269d : 8d0302          >            sta abst
26a0 : 28              >            plp
                        
26a1 : 6e0302                   ror abst
                                tst_abs rROR,fROR,$ff-fnzc
26a4 : 08              >            php         ;save flags
26a5 : ad0302          >            lda abst
26a8 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
26ab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26ad : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26ae : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
26b0 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
26b3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26b5 : ca                       dex
26b6 : 10e0                     bpl tror5
                        
26b8 : a203                     ldx #3
26ba :                  trorc4
                                set_abs zp1,fc
                       >            load_flag fc
26ba : a905            >            lda #fc|intdis      ;force disable interrupts
                       >
26bc : 48              >            pha         ;use stack to load status
26bd : b509            >            lda zp1,x    ;load to memory
26bf : 8d0302          >            sta abst
26c2 : 28              >            plp
                        
26c3 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,0
26c6 : 08              >            php         ;save flags
26c7 : ad0302          >            lda abst
26ca : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
26cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26cf : 68              >            pla         ;load status
                       >            eor_flag 0
26d0 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
26d2 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
26d5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26d7 : ca                       dex
26d8 : 10e0                     bpl trorc4
26da : a203                     ldx #3
26dc :                  trorc5
                                set_abs zp1,$ff
                       >            load_flag $ff
26dc : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
26de : 48              >            pha         ;use stack to load status
26df : b509            >            lda zp1,x    ;load to memory
26e1 : 8d0302          >            sta abst
26e4 : 28              >            plp
                        
26e5 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,$ff-fnzc
26e8 : 08              >            php         ;save flags
26e9 : ad0302          >            lda abst
26ec : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
26ef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26f1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26f2 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
26f4 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
26f7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26f9 : ca                       dex
26fa : 10e0                     bpl trorc5
                                next_test
26fc : ad0002          >            lda test_case   ;previous test
26ff : c91f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2701 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0020 =                 >test_num = test_num + 1
2703 : a920            >            lda #test_num   ;*** next tests' number
2705 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zp indexed
2708 : a203                     ldx #3
270a :                  tasl6
                                set_zx zp1,0
                       >            load_flag 0
270a : a904            >            lda #0|intdis      ;force disable interrupts
                       >
270c : 48              >            pha         ;use stack to load status
270d : b509            >            lda zp1,x    ;load to indexed zeropage
270f : 9502            >            sta zpt,x
2711 : 28              >            plp
                        
2712 : 1602                     asl zpt,x
                                tst_zx rASL,fASL,0
2714 : 08              >            php         ;save flags
2715 : b502            >            lda zpt,x
2717 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
271a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
271c : 68              >            pla         ;load status
                       >            eor_flag 0
271d : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
271f : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2722 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2724 : ca                       dex
2725 : 10e3                     bpl tasl6
2727 : a203                     ldx #3
2729 :                  tasl7
                                set_zx zp1,$ff
                       >            load_flag $ff
2729 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
272b : 48              >            pha         ;use stack to load status
272c : b509            >            lda zp1,x    ;load to indexed zeropage
272e : 9502            >            sta zpt,x
2730 : 28              >            plp
                        
2731 : 1602                     asl zpt,x
                                tst_zx rASL,fASL,$ff-fnzc
2733 : 08              >            php         ;save flags
2734 : b502            >            lda zpt,x
2736 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2739 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
273b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
273c : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
273e : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2741 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2743 : ca                       dex
2744 : 10e3                     bpl tasl7
                        
2746 : a203                     ldx #3
2748 :                  tlsr6
                                set_zx zp1,0
                       >            load_flag 0
2748 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
274a : 48              >            pha         ;use stack to load status
274b : b509            >            lda zp1,x    ;load to indexed zeropage
274d : 9502            >            sta zpt,x
274f : 28              >            plp
                        
2750 : 5602                     lsr zpt,x
                                tst_zx rLSR,fLSR,0
2752 : 08              >            php         ;save flags
2753 : b502            >            lda zpt,x
2755 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2758 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
275a : 68              >            pla         ;load status
                       >            eor_flag 0
275b : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
275d : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2760 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2762 : ca                       dex
2763 : 10e3                     bpl tlsr6
2765 : a203                     ldx #3
2767 :                  tlsr7
                                set_zx zp1,$ff
                       >            load_flag $ff
2767 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2769 : 48              >            pha         ;use stack to load status
276a : b509            >            lda zp1,x    ;load to indexed zeropage
276c : 9502            >            sta zpt,x
276e : 28              >            plp
                        
276f : 5602                     lsr zpt,x
                                tst_zx rLSR,fLSR,$ff-fnzc
2771 : 08              >            php         ;save flags
2772 : b502            >            lda zpt,x
2774 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2777 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2779 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
277a : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
277c : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
277f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2781 : ca                       dex
2782 : 10e3                     bpl tlsr7
                        
2784 : a203                     ldx #3
2786 :                  trol6
                                set_zx zp1,0
                       >            load_flag 0
2786 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2788 : 48              >            pha         ;use stack to load status
2789 : b509            >            lda zp1,x    ;load to indexed zeropage
278b : 9502            >            sta zpt,x
278d : 28              >            plp
                        
278e : 3602                     rol zpt,x
                                tst_zx rROL,fROL,0
2790 : 08              >            php         ;save flags
2791 : b502            >            lda zpt,x
2793 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2796 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2798 : 68              >            pla         ;load status
                       >            eor_flag 0
2799 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
279b : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
279e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27a0 : ca                       dex
27a1 : 10e3                     bpl trol6
27a3 : a203                     ldx #3
27a5 :                  trol7
                                set_zx zp1,$ff-fc
                       >            load_flag $ff-fc
27a5 : a9fe            >            lda #$ff-fc|intdis      ;force disable interrupts
                       >
27a7 : 48              >            pha         ;use stack to load status
27a8 : b509            >            lda zp1,x    ;load to indexed zeropage
27aa : 9502            >            sta zpt,x
27ac : 28              >            plp
                        
27ad : 3602                     rol zpt,x
                                tst_zx rROL,fROL,$ff-fnzc
27af : 08              >            php         ;save flags
27b0 : b502            >            lda zpt,x
27b2 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
27b5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27b7 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27b8 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
27ba : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
27bd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27bf : ca                       dex
27c0 : 10e3                     bpl trol7
                        
27c2 : a203                     ldx #3
27c4 :                  trolc6
                                set_zx zp1,fc
                       >            load_flag fc
27c4 : a905            >            lda #fc|intdis      ;force disable interrupts
                       >
27c6 : 48              >            pha         ;use stack to load status
27c7 : b509            >            lda zp1,x    ;load to indexed zeropage
27c9 : 9502            >            sta zpt,x
27cb : 28              >            plp
                        
27cc : 3602                     rol zpt,x
                                tst_zx rROLc,fROLc,0
27ce : 08              >            php         ;save flags
27cf : b502            >            lda zpt,x
27d1 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
27d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27d6 : 68              >            pla         ;load status
                       >            eor_flag 0
27d7 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
27d9 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
27dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27de : ca                       dex
27df : 10e3                     bpl trolc6
27e1 : a203                     ldx #3
27e3 :                  trolc7
                                set_zx zp1,$ff
                       >            load_flag $ff
27e3 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
27e5 : 48              >            pha         ;use stack to load status
27e6 : b509            >            lda zp1,x    ;load to indexed zeropage
27e8 : 9502            >            sta zpt,x
27ea : 28              >            plp
                        
27eb : 3602                     rol zpt,x
                                tst_zx rROLc,fROLc,$ff-fnzc
27ed : 08              >            php         ;save flags
27ee : b502            >            lda zpt,x
27f0 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
27f3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27f5 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27f6 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
27f8 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
27fb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27fd : ca                       dex
27fe : 10e3                     bpl trolc7
                        
2800 : a203                     ldx #3
2802 :                  tror6
                                set_zx zp1,0
                       >            load_flag 0
2802 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2804 : 48              >            pha         ;use stack to load status
2805 : b509            >            lda zp1,x    ;load to indexed zeropage
2807 : 9502            >            sta zpt,x
2809 : 28              >            plp
                        
280a : 7602                     ror zpt,x
                                tst_zx rROR,fROR,0
280c : 08              >            php         ;save flags
280d : b502            >            lda zpt,x
280f : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2812 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2814 : 68              >            pla         ;load status
                       >            eor_flag 0
2815 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2817 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
281a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
281c : ca                       dex
281d : 10e3                     bpl tror6
281f : a203                     ldx #3
2821 :                  tror7
                                set_zx zp1,$ff-fc
                       >            load_flag $ff-fc
2821 : a9fe            >            lda #$ff-fc|intdis      ;force disable interrupts
                       >
2823 : 48              >            pha         ;use stack to load status
2824 : b509            >            lda zp1,x    ;load to indexed zeropage
2826 : 9502            >            sta zpt,x
2828 : 28              >            plp
                        
2829 : 7602                     ror zpt,x
                                tst_zx rROR,fROR,$ff-fnzc
282b : 08              >            php         ;save flags
282c : b502            >            lda zpt,x
282e : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2831 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2833 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2834 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
2836 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2839 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
283b : ca                       dex
283c : 10e3                     bpl tror7
                        
283e : a203                     ldx #3
2840 :                  trorc6
                                set_zx zp1,fc
                       >            load_flag fc
2840 : a905            >            lda #fc|intdis      ;force disable interrupts
                       >
2842 : 48              >            pha         ;use stack to load status
2843 : b509            >            lda zp1,x    ;load to indexed zeropage
2845 : 9502            >            sta zpt,x
2847 : 28              >            plp
                        
2848 : 7602                     ror zpt,x
                                tst_zx rRORc,fRORc,0
284a : 08              >            php         ;save flags
284b : b502            >            lda zpt,x
284d : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2850 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2852 : 68              >            pla         ;load status
                       >            eor_flag 0
2853 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2855 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2858 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
285a : ca                       dex
285b : 10e3                     bpl trorc6
285d : a203                     ldx #3
285f :                  trorc7
                                set_zx zp1,$ff
                       >            load_flag $ff
285f : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2861 : 48              >            pha         ;use stack to load status
2862 : b509            >            lda zp1,x    ;load to indexed zeropage
2864 : 9502            >            sta zpt,x
2866 : 28              >            plp
                        
2867 : 7602                     ror zpt,x
                                tst_zx rRORc,fRORc,$ff-fnzc
2869 : 08              >            php         ;save flags
286a : b502            >            lda zpt,x
286c : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
286f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2871 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2872 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
2874 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2877 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2879 : ca                       dex
287a : 10e3                     bpl trorc7
                                next_test
287c : ad0002          >            lda test_case   ;previous test
287f : c920            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2881 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0021 =                 >test_num = test_num + 1
2883 : a921            >            lda #test_num   ;*** next tests' number
2885 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; shifts - abs indexed
2888 : a203                     ldx #3
288a :                  tasl8
                                set_absx zp1,0
                       >            load_flag 0
288a : a904            >            lda #0|intdis      ;force disable interrupts
                       >
288c : 48              >            pha         ;use stack to load status
288d : b509            >            lda zp1,x    ;load to indexed memory
288f : 9d0302          >            sta abst,x
2892 : 28              >            plp
                        
2893 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,0
2896 : 08              >            php         ;save flags
2897 : bd0302          >            lda abst,x
289a : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
289d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
289f : 68              >            pla         ;load status
                       >            eor_flag 0
28a0 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
28a2 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
28a5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28a7 : ca                       dex
28a8 : 10e0                     bpl tasl8
28aa : a203                     ldx #3
28ac :                  tasl9
                                set_absx zp1,$ff
                       >            load_flag $ff
28ac : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
28ae : 48              >            pha         ;use stack to load status
28af : b509            >            lda zp1,x    ;load to indexed memory
28b1 : 9d0302          >            sta abst,x
28b4 : 28              >            plp
                        
28b5 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,$ff-fnzc
28b8 : 08              >            php         ;save flags
28b9 : bd0302          >            lda abst,x
28bc : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
28bf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28c1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
28c2 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
28c4 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
28c7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28c9 : ca                       dex
28ca : 10e0                     bpl tasl9
                        
28cc : a203                     ldx #3
28ce :                  tlsr8
                                set_absx zp1,0
                       >            load_flag 0
28ce : a904            >            lda #0|intdis      ;force disable interrupts
                       >
28d0 : 48              >            pha         ;use stack to load status
28d1 : b509            >            lda zp1,x    ;load to indexed memory
28d3 : 9d0302          >            sta abst,x
28d6 : 28              >            plp
                        
28d7 : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,0
28da : 08              >            php         ;save flags
28db : bd0302          >            lda abst,x
28de : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
28e1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28e3 : 68              >            pla         ;load status
                       >            eor_flag 0
28e4 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
28e6 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
28e9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28eb : ca                       dex
28ec : 10e0                     bpl tlsr8
28ee : a203                     ldx #3
28f0 :                  tlsr9
                                set_absx zp1,$ff
                       >            load_flag $ff
28f0 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
28f2 : 48              >            pha         ;use stack to load status
28f3 : b509            >            lda zp1,x    ;load to indexed memory
28f5 : 9d0302          >            sta abst,x
28f8 : 28              >            plp
                        
28f9 : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,$ff-fnzc
28fc : 08              >            php         ;save flags
28fd : bd0302          >            lda abst,x
2900 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2903 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2905 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2906 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
2908 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
290b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
290d : ca                       dex
290e : 10e0                     bpl tlsr9
                        
2910 : a203                     ldx #3
2912 :                  trol8
                                set_absx zp1,0
                       >            load_flag 0
2912 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2914 : 48              >            pha         ;use stack to load status
2915 : b509            >            lda zp1,x    ;load to indexed memory
2917 : 9d0302          >            sta abst,x
291a : 28              >            plp
                        
291b : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,0
291e : 08              >            php         ;save flags
291f : bd0302          >            lda abst,x
2922 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2925 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2927 : 68              >            pla         ;load status
                       >            eor_flag 0
2928 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
292a : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
292d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
292f : ca                       dex
2930 : 10e0                     bpl trol8
2932 : a203                     ldx #3
2934 :                  trol9
                                set_absx zp1,$ff-fc
                       >            load_flag $ff-fc
2934 : a9fe            >            lda #$ff-fc|intdis      ;force disable interrupts
                       >
2936 : 48              >            pha         ;use stack to load status
2937 : b509            >            lda zp1,x    ;load to indexed memory
2939 : 9d0302          >            sta abst,x
293c : 28              >            plp
                        
293d : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,$ff-fnzc
2940 : 08              >            php         ;save flags
2941 : bd0302          >            lda abst,x
2944 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2947 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2949 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
294a : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
294c : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
294f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2951 : ca                       dex
2952 : 10e0                     bpl trol9
                        
2954 : a203                     ldx #3
2956 :                  trolc8
                                set_absx zp1,fc
                       >            load_flag fc
2956 : a905            >            lda #fc|intdis      ;force disable interrupts
                       >
2958 : 48              >            pha         ;use stack to load status
2959 : b509            >            lda zp1,x    ;load to indexed memory
295b : 9d0302          >            sta abst,x
295e : 28              >            plp
                        
295f : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,0
2962 : 08              >            php         ;save flags
2963 : bd0302          >            lda abst,x
2966 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2969 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
296b : 68              >            pla         ;load status
                       >            eor_flag 0
296c : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
296e : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2971 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2973 : ca                       dex
2974 : 10e0                     bpl trolc8
2976 : a203                     ldx #3
2978 :                  trolc9
                                set_absx zp1,$ff
                       >            load_flag $ff
2978 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
297a : 48              >            pha         ;use stack to load status
297b : b509            >            lda zp1,x    ;load to indexed memory
297d : 9d0302          >            sta abst,x
2980 : 28              >            plp
                        
2981 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,$ff-fnzc
2984 : 08              >            php         ;save flags
2985 : bd0302          >            lda abst,x
2988 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
298b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
298d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
298e : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
2990 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2993 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2995 : ca                       dex
2996 : 10e0                     bpl trolc9
                        
2998 : a203                     ldx #3
299a :                  tror8
                                set_absx zp1,0
                       >            load_flag 0
299a : a904            >            lda #0|intdis      ;force disable interrupts
                       >
299c : 48              >            pha         ;use stack to load status
299d : b509            >            lda zp1,x    ;load to indexed memory
299f : 9d0302          >            sta abst,x
29a2 : 28              >            plp
                        
29a3 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,0
29a6 : 08              >            php         ;save flags
29a7 : bd0302          >            lda abst,x
29aa : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
29ad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29af : 68              >            pla         ;load status
                       >            eor_flag 0
29b0 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
29b2 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
29b5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29b7 : ca                       dex
29b8 : 10e0                     bpl tror8
29ba : a203                     ldx #3
29bc :                  tror9
                                set_absx zp1,$ff-fc
                       >            load_flag $ff-fc
29bc : a9fe            >            lda #$ff-fc|intdis      ;force disable interrupts
                       >
29be : 48              >            pha         ;use stack to load status
29bf : b509            >            lda zp1,x    ;load to indexed memory
29c1 : 9d0302          >            sta abst,x
29c4 : 28              >            plp
                        
29c5 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,$ff-fnzc
29c8 : 08              >            php         ;save flags
29c9 : bd0302          >            lda abst,x
29cc : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
29cf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29d1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
29d2 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
29d4 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
29d7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29d9 : ca                       dex
29da : 10e0                     bpl tror9
                        
29dc : a203                     ldx #3
29de :                  trorc8
                                set_absx zp1,fc
                       >            load_flag fc
29de : a905            >            lda #fc|intdis      ;force disable interrupts
                       >
29e0 : 48              >            pha         ;use stack to load status
29e1 : b509            >            lda zp1,x    ;load to indexed memory
29e3 : 9d0302          >            sta abst,x
29e6 : 28              >            plp
                        
29e7 : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,0
29ea : 08              >            php         ;save flags
29eb : bd0302          >            lda abst,x
29ee : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
29f1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29f3 : 68              >            pla         ;load status
                       >            eor_flag 0
29f4 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
29f6 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
29f9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29fb : ca                       dex
29fc : 10e0                     bpl trorc8
29fe : a203                     ldx #3
2a00 :                  trorc9
                                set_absx zp1,$ff
                       >            load_flag $ff
2a00 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2a02 : 48              >            pha         ;use stack to load status
2a03 : b509            >            lda zp1,x    ;load to indexed memory
2a05 : 9d0302          >            sta abst,x
2a08 : 28              >            plp
                        
2a09 : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,$ff-fnzc
2a0c : 08              >            php         ;save flags
2a0d : bd0302          >            lda abst,x
2a10 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2a13 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a15 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2a16 : 497c            >            eor #($ff-fnzc|fai)       ;invert expected flags + always on bits + I
                       >
2a18 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2a1b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a1d : ca                       dex
2a1e : 10e0                     bpl trorc9
                                next_test
2a20 : ad0002          >            lda test_case   ;previous test
2a23 : c921            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2a25 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0022 =                 >test_num = test_num + 1
2a27 : a922            >            lda #test_num   ;*** next tests' number
2a29 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing memory increment/decrement - INC DEC all addressing modes
                        ; zeropage
2a2c : a200                     ldx #0
2a2e : a97e                     lda #$7e
2a30 : 8502                     sta zpt
2a32 :                  tinc    
                                set_stat 0
                       >            load_flag 0
2a32 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2a34 : 48              >            pha         ;use stack to load status
2a35 : 28              >            plp
                        
2a36 : e602                     inc zpt
                                tst_z rINC,fINC,0
2a38 : 08              >            php         ;save flags
2a39 : a502            >            lda zpt
2a3b : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2a3e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a40 : 68              >            pla         ;load status
                       >            eor_flag 0
2a41 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2a43 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a48 : e8                       inx
2a49 : e002                     cpx #2
2a4b : d004                     bne tinc1
2a4d : a9fe                     lda #$fe
2a4f : 8502                     sta zpt
2a51 : e005             tinc1   cpx #5
2a53 : d0dd                     bne tinc
2a55 : ca                       dex
2a56 : e602                     inc zpt
2a58 :                  tdec    
                                set_stat 0
                       >            load_flag 0
2a58 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2a5a : 48              >            pha         ;use stack to load status
2a5b : 28              >            plp
                        
2a5c : c602                     dec zpt
                                tst_z rINC,fINC,0
2a5e : 08              >            php         ;save flags
2a5f : a502            >            lda zpt
2a61 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2a64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a66 : 68              >            pla         ;load status
                       >            eor_flag 0
2a67 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2a69 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a6c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a6e : ca                       dex
2a6f : 300a                     bmi tdec1
2a71 : e001                     cpx #1
2a73 : d0e3                     bne tdec
2a75 : a981                     lda #$81
2a77 : 8502                     sta zpt
2a79 : d0dd                     bne tdec
2a7b :                  tdec1
2a7b : a200                     ldx #0
2a7d : a97e                     lda #$7e
2a7f : 8502                     sta zpt
2a81 :                  tinc10    
                                set_stat $ff
                       >            load_flag $ff
2a81 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2a83 : 48              >            pha         ;use stack to load status
2a84 : 28              >            plp
                        
2a85 : e602                     inc zpt
                                tst_z rINC,fINC,$ff-fnz
2a87 : 08              >            php         ;save flags
2a88 : a502            >            lda zpt
2a8a : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2a8d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a8f : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2a90 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2a92 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a95 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a97 : e8                       inx
2a98 : e002                     cpx #2
2a9a : d004                     bne tinc11
2a9c : a9fe                     lda #$fe
2a9e : 8502                     sta zpt
2aa0 : e005             tinc11  cpx #5
2aa2 : d0dd                     bne tinc10
2aa4 : ca                       dex
2aa5 : e602                     inc zpt
2aa7 :                  tdec10    
                                set_stat $ff
                       >            load_flag $ff
2aa7 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2aa9 : 48              >            pha         ;use stack to load status
2aaa : 28              >            plp
                        
2aab : c602                     dec zpt
                                tst_z rINC,fINC,$ff-fnz
2aad : 08              >            php         ;save flags
2aae : a502            >            lda zpt
2ab0 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2ab3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ab5 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ab6 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2ab8 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2abb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2abd : ca                       dex
2abe : 300a                     bmi tdec11
2ac0 : e001                     cpx #1
2ac2 : d0e3                     bne tdec10
2ac4 : a981                     lda #$81
2ac6 : 8502                     sta zpt
2ac8 : d0dd                     bne tdec10
2aca :                  tdec11
                                next_test
2aca : ad0002          >            lda test_case   ;previous test
2acd : c922            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2acf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0023 =                 >test_num = test_num + 1
2ad1 : a923            >            lda #test_num   ;*** next tests' number
2ad3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; absolute memory
2ad6 : a200                     ldx #0
2ad8 : a97e                     lda #$7e
2ada : 8d0302                   sta abst
2add :                  tinc2    
                                set_stat 0
                       >            load_flag 0
2add : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2adf : 48              >            pha         ;use stack to load status
2ae0 : 28              >            plp
                        
2ae1 : ee0302                   inc abst
                                tst_abs rINC,fINC,0
2ae4 : 08              >            php         ;save flags
2ae5 : ad0302          >            lda abst
2ae8 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2aeb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2aed : 68              >            pla         ;load status
                       >            eor_flag 0
2aee : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2af0 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2af3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2af5 : e8                       inx
2af6 : e002                     cpx #2
2af8 : d005                     bne tinc3
2afa : a9fe                     lda #$fe
2afc : 8d0302                   sta abst
2aff : e005             tinc3   cpx #5
2b01 : d0da                     bne tinc2
2b03 : ca                       dex
2b04 : ee0302                   inc abst
2b07 :                  tdec2    
                                set_stat 0
                       >            load_flag 0
2b07 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2b09 : 48              >            pha         ;use stack to load status
2b0a : 28              >            plp
                        
2b0b : ce0302                   dec abst
                                tst_abs rINC,fINC,0
2b0e : 08              >            php         ;save flags
2b0f : ad0302          >            lda abst
2b12 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b15 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b17 : 68              >            pla         ;load status
                       >            eor_flag 0
2b18 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2b1a : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b1f : ca                       dex
2b20 : 300b                     bmi tdec3
2b22 : e001                     cpx #1
2b24 : d0e1                     bne tdec2
2b26 : a981                     lda #$81
2b28 : 8d0302                   sta abst
2b2b : d0da                     bne tdec2
2b2d :                  tdec3
2b2d : a200                     ldx #0
2b2f : a97e                     lda #$7e
2b31 : 8d0302                   sta abst
2b34 :                  tinc12    
                                set_stat $ff
                       >            load_flag $ff
2b34 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2b36 : 48              >            pha         ;use stack to load status
2b37 : 28              >            plp
                        
2b38 : ee0302                   inc abst
                                tst_abs rINC,fINC,$ff-fnz
2b3b : 08              >            php         ;save flags
2b3c : ad0302          >            lda abst
2b3f : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b44 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b45 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2b47 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b4a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b4c : e8                       inx
2b4d : e002                     cpx #2
2b4f : d005                     bne tinc13
2b51 : a9fe                     lda #$fe
2b53 : 8d0302                   sta abst
2b56 : e005             tinc13   cpx #5
2b58 : d0da                     bne tinc12
2b5a : ca                       dex
2b5b : ee0302                   inc abst
2b5e :                  tdec12    
                                set_stat $ff
                       >            load_flag $ff
2b5e : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2b60 : 48              >            pha         ;use stack to load status
2b61 : 28              >            plp
                        
2b62 : ce0302                   dec abst
                                tst_abs rINC,fINC,$ff-fnz
2b65 : 08              >            php         ;save flags
2b66 : ad0302          >            lda abst
2b69 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b6c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b6e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b6f : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2b71 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b74 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b76 : ca                       dex
2b77 : 300b                     bmi tdec13
2b79 : e001                     cpx #1
2b7b : d0e1                     bne tdec12
2b7d : a981                     lda #$81
2b7f : 8d0302                   sta abst
2b82 : d0da                     bne tdec12
2b84 :                  tdec13
                                next_test
2b84 : ad0002          >            lda test_case   ;previous test
2b87 : c923            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2b89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0024 =                 >test_num = test_num + 1
2b8b : a924            >            lda #test_num   ;*** next tests' number
2b8d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; zeropage indexed
2b90 : a200                     ldx #0
2b92 : a97e                     lda #$7e
2b94 : 9502             tinc4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
2b96 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2b98 : 48              >            pha         ;use stack to load status
2b99 : 28              >            plp
                        
2b9a : f602                     inc zpt,x
                                tst_zx rINC,fINC,0
2b9c : 08              >            php         ;save flags
2b9d : b502            >            lda zpt,x
2b9f : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2ba2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ba4 : 68              >            pla         ;load status
                       >            eor_flag 0
2ba5 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2ba7 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2baa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bac : b502                     lda zpt,x
2bae : e8                       inx
2baf : e002                     cpx #2
2bb1 : d002                     bne tinc5
2bb3 : a9fe                     lda #$fe
2bb5 : e005             tinc5   cpx #5
2bb7 : d0db                     bne tinc4
2bb9 : ca                       dex
2bba : a902                     lda #2
2bbc : 9502             tdec4   sta zpt,x 
                                set_stat 0
                       >            load_flag 0
2bbe : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2bc0 : 48              >            pha         ;use stack to load status
2bc1 : 28              >            plp
                        
2bc2 : d602                     dec zpt,x
                                tst_zx rINC,fINC,0
2bc4 : 08              >            php         ;save flags
2bc5 : b502            >            lda zpt,x
2bc7 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2bca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bcc : 68              >            pla         ;load status
                       >            eor_flag 0
2bcd : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2bcf : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2bd2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bd4 : b502                     lda zpt,x
2bd6 : ca                       dex
2bd7 : 3008                     bmi tdec5
2bd9 : e001                     cpx #1
2bdb : d0df                     bne tdec4
2bdd : a981                     lda #$81
2bdf : d0db                     bne tdec4
2be1 :                  tdec5
2be1 : a200                     ldx #0
2be3 : a97e                     lda #$7e
2be5 : 9502             tinc14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
2be7 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2be9 : 48              >            pha         ;use stack to load status
2bea : 28              >            plp
                        
2beb : f602                     inc zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2bed : 08              >            php         ;save flags
2bee : b502            >            lda zpt,x
2bf0 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2bf3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bf5 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2bf6 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2bf8 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2bfb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bfd : b502                     lda zpt,x
2bff : e8                       inx
2c00 : e002                     cpx #2
2c02 : d002                     bne tinc15
2c04 : a9fe                     lda #$fe
2c06 : e005             tinc15  cpx #5
2c08 : d0db                     bne tinc14
2c0a : ca                       dex
2c0b : a902                     lda #2
2c0d : 9502             tdec14  sta zpt,x 
                                set_stat $ff
                       >            load_flag $ff
2c0f : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2c11 : 48              >            pha         ;use stack to load status
2c12 : 28              >            plp
                        
2c13 : d602                     dec zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2c15 : 08              >            php         ;save flags
2c16 : b502            >            lda zpt,x
2c18 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2c1b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c1d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2c1e : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2c20 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c23 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c25 : b502                     lda zpt,x
2c27 : ca                       dex
2c28 : 3008                     bmi tdec15
2c2a : e001                     cpx #1
2c2c : d0df                     bne tdec14
2c2e : a981                     lda #$81
2c30 : d0db                     bne tdec14
2c32 :                  tdec15
                                next_test
2c32 : ad0002          >            lda test_case   ;previous test
2c35 : c924            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2c37 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0025 =                 >test_num = test_num + 1
2c39 : a925            >            lda #test_num   ;*** next tests' number
2c3b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; memory indexed
2c3e : a200                     ldx #0
2c40 : a97e                     lda #$7e
2c42 : 9d0302           tinc6   sta abst,x
                                set_stat 0
                       >            load_flag 0
2c45 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2c47 : 48              >            pha         ;use stack to load status
2c48 : 28              >            plp
                        
2c49 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,0
2c4c : 08              >            php         ;save flags
2c4d : bd0302          >            lda abst,x
2c50 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2c53 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c55 : 68              >            pla         ;load status
                       >            eor_flag 0
2c56 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2c58 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c5b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c5d : bd0302                   lda abst,x
2c60 : e8                       inx
2c61 : e002                     cpx #2
2c63 : d002                     bne tinc7
2c65 : a9fe                     lda #$fe
2c67 : e005             tinc7   cpx #5
2c69 : d0d7                     bne tinc6
2c6b : ca                       dex
2c6c : a902                     lda #2
2c6e : 9d0302           tdec6   sta abst,x 
                                set_stat 0
                       >            load_flag 0
2c71 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2c73 : 48              >            pha         ;use stack to load status
2c74 : 28              >            plp
                        
2c75 : de0302                   dec abst,x
                                tst_absx rINC,fINC,0
2c78 : 08              >            php         ;save flags
2c79 : bd0302          >            lda abst,x
2c7c : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2c7f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c81 : 68              >            pla         ;load status
                       >            eor_flag 0
2c82 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2c84 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c89 : bd0302                   lda abst,x
2c8c : ca                       dex
2c8d : 3008                     bmi tdec7
2c8f : e001                     cpx #1
2c91 : d0db                     bne tdec6
2c93 : a981                     lda #$81
2c95 : d0d7                     bne tdec6
2c97 :                  tdec7
2c97 : a200                     ldx #0
2c99 : a97e                     lda #$7e
2c9b : 9d0302           tinc16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
2c9e : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2ca0 : 48              >            pha         ;use stack to load status
2ca1 : 28              >            plp
                        
2ca2 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,$ff-fnz
2ca5 : 08              >            php         ;save flags
2ca6 : bd0302          >            lda abst,x
2ca9 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2cac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2cae : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2caf : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2cb1 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2cb4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2cb6 : bd0302                   lda abst,x
2cb9 : e8                       inx
2cba : e002                     cpx #2
2cbc : d002                     bne tinc17
2cbe : a9fe                     lda #$fe
2cc0 : e005             tinc17  cpx #5
2cc2 : d0d7                     bne tinc16
2cc4 : ca                       dex
2cc5 : a902                     lda #2
2cc7 : 9d0302           tdec16  sta abst,x 
                                set_stat $ff
                       >            load_flag $ff
2cca : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2ccc : 48              >            pha         ;use stack to load status
2ccd : 28              >            plp
                        
2cce : de0302                   dec abst,x
                                tst_absx rINC,fINC,$ff-fnz
2cd1 : 08              >            php         ;save flags
2cd2 : bd0302          >            lda abst,x
2cd5 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2cd8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2cda : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2cdb : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2cdd : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ce0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ce2 : bd0302                   lda abst,x
2ce5 : ca                       dex
2ce6 : 3008                     bmi tdec17
2ce8 : e001                     cpx #1
2cea : d0db                     bne tdec16
2cec : a981                     lda #$81
2cee : d0d7                     bne tdec16
2cf0 :                  tdec17
                                next_test
2cf0 : ad0002          >            lda test_case   ;previous test
2cf3 : c925            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2cf5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0026 =                 >test_num = test_num + 1
2cf7 : a926            >            lda #test_num   ;*** next tests' number
2cf9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing logical instructions - AND EOR ORA all addressing modes
                        ; AND
2cfc : a203                     ldx #3          ;immediate
2cfe : b512             tand    lda zpAN,x
2d00 : 8d0902                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,0
                       >            load_flag 0
2d03 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2d05 : 48              >            pha         ;use stack to load status
2d06 : bd5a02          >            lda absANa,x    ;precharge accu
2d09 : 28              >            plp
                        
2d0a : 200802                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,0
2d0d : 08              >            php         ;save flags
2d0e : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d11 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d13 : 68              >            pla         ;load status
                       >            eor_flag 0
2d14 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2d16 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d19 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d1b : ca                       dex
2d1c : 10e0                     bpl tand
2d1e : a203                     ldx #3
2d20 : b512             tand1   lda zpAN,x
2d22 : 8d0902                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d25 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2d27 : 48              >            pha         ;use stack to load status
2d28 : bd5a02          >            lda absANa,x    ;precharge accu
2d2b : 28              >            plp
                        
2d2c : 200802                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
2d2f : 08              >            php         ;save flags
2d30 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d33 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d35 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d36 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2d38 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d3d : ca                       dex
2d3e : 10e0                     bpl tand1
                            
2d40 : a203                     ldx #3      ;zp
2d42 : b512             tand2   lda zpAN,x
2d44 : 8502                     sta zpt
                                set_ax  absANa,0
                       >            load_flag 0
2d46 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2d48 : 48              >            pha         ;use stack to load status
2d49 : bd5a02          >            lda absANa,x    ;precharge accu
2d4c : 28              >            plp
                        
2d4d : 2502                     and zpt
                                tst_ax  absrlo,absflo,0
2d4f : 08              >            php         ;save flags
2d50 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d53 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d55 : 68              >            pla         ;load status
                       >            eor_flag 0
2d56 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2d58 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d5b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d5d : ca                       dex
2d5e : 10e2                     bpl tand2
2d60 : a203                     ldx #3
2d62 : b512             tand3   lda zpAN,x
2d64 : 8502                     sta zpt
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d66 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2d68 : 48              >            pha         ;use stack to load status
2d69 : bd5a02          >            lda absANa,x    ;precharge accu
2d6c : 28              >            plp
                        
2d6d : 2502                     and zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2d6f : 08              >            php         ;save flags
2d70 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d73 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d75 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d76 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2d78 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d7b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d7d : ca                       dex
2d7e : 10e2                     bpl tand3
                        
2d80 : a203                     ldx #3      ;abs
2d82 : b512             tand4   lda zpAN,x
2d84 : 8d0302                   sta abst
                                set_ax  absANa,0
                       >            load_flag 0
2d87 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2d89 : 48              >            pha         ;use stack to load status
2d8a : bd5a02          >            lda absANa,x    ;precharge accu
2d8d : 28              >            plp
                        
2d8e : 2d0302                   and abst
                                tst_ax  absrlo,absflo,0
2d91 : 08              >            php         ;save flags
2d92 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d95 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d97 : 68              >            pla         ;load status
                       >            eor_flag 0
2d98 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2d9a : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d9d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d9f : ca                       dex
2da0 : 10e0                     bpl tand4
2da2 : a203                     ldx #3
2da4 : b512             tand5   lda zpAN,x
2da6 : 8d0302                   sta abst
                                set_ax  absANa,$ff
                       >            load_flag $ff
2da9 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2dab : 48              >            pha         ;use stack to load status
2dac : bd5a02          >            lda absANa,x    ;precharge accu
2daf : 28              >            plp
                        
2db0 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,$ff-fnz
2db3 : 08              >            php         ;save flags
2db4 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2db7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2db9 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2dba : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2dbc : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2dbf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2dc1 : ca                       dex
2dc2 : 1002                     bpl tand6
                        
2dc4 : a203                     ldx #3      ;zp,x
2dc6 :                  tand6
                                set_ax  absANa,0
                       >            load_flag 0
2dc6 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2dc8 : 48              >            pha         ;use stack to load status
2dc9 : bd5a02          >            lda absANa,x    ;precharge accu
2dcc : 28              >            plp
                        
2dcd : 3512                     and zpAN,x
                                tst_ax  absrlo,absflo,0
2dcf : 08              >            php         ;save flags
2dd0 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2dd3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dd5 : 68              >            pla         ;load status
                       >            eor_flag 0
2dd6 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2dd8 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ddb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ddd : ca                       dex
2dde : 10e6                     bpl tand6
2de0 : a203                     ldx #3
2de2 :                  tand7
                                set_ax  absANa,$ff
                       >            load_flag $ff
2de2 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2de4 : 48              >            pha         ;use stack to load status
2de5 : bd5a02          >            lda absANa,x    ;precharge accu
2de8 : 28              >            plp
                        
2de9 : 3512                     and zpAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2deb : 08              >            php         ;save flags
2dec : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2def : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2df1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2df2 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2df4 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2df7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2df9 : ca                       dex
2dfa : 10e6                     bpl tand7
                        
2dfc : a203                     ldx #3      ;abs,x
2dfe :                  tand8
                                set_ax  absANa,0
                       >            load_flag 0
2dfe : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2e00 : 48              >            pha         ;use stack to load status
2e01 : bd5a02          >            lda absANa,x    ;precharge accu
2e04 : 28              >            plp
                        
2e05 : 3d4e02                   and absAN,x
                                tst_ax  absrlo,absflo,0
2e08 : 08              >            php         ;save flags
2e09 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e0c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e0e : 68              >            pla         ;load status
                       >            eor_flag 0
2e0f : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2e11 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e14 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e16 : ca                       dex
2e17 : 10e5                     bpl tand8
2e19 : a203                     ldx #3
2e1b :                  tand9
                                set_ax  absANa,$ff
                       >            load_flag $ff
2e1b : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2e1d : 48              >            pha         ;use stack to load status
2e1e : bd5a02          >            lda absANa,x    ;precharge accu
2e21 : 28              >            plp
                        
2e22 : 3d4e02                   and absAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2e25 : 08              >            php         ;save flags
2e26 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e29 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e2b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e2c : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2e2e : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e31 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e33 : ca                       dex
2e34 : 10e5                     bpl tand9
                        
2e36 : a003                     ldy #3      ;abs,y
2e38 :                  tand10
                                set_ay  absANa,0
                       >            load_flag 0
2e38 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2e3a : 48              >            pha         ;use stack to load status
2e3b : b95a02          >            lda absANa,y    ;precharge accu
2e3e : 28              >            plp
                        
2e3f : 394e02                   and absAN,y
                                tst_ay  absrlo,absflo,0
2e42 : 08              >            php         ;save flags
2e43 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e48 : 68              >            pla         ;load status
                       >            eor_flag 0
2e49 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2e4b : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e4e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e50 : 88                       dey
2e51 : 10e5                     bpl tand10
2e53 : a003                     ldy #3
2e55 :                  tand11
                                set_ay  absANa,$ff
                       >            load_flag $ff
2e55 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2e57 : 48              >            pha         ;use stack to load status
2e58 : b95a02          >            lda absANa,y    ;precharge accu
2e5b : 28              >            plp
                        
2e5c : 394e02                   and absAN,y
                                tst_ay  absrlo,absflo,$ff-fnz
2e5f : 08              >            php         ;save flags
2e60 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e63 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e65 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e66 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2e68 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e6d : 88                       dey
2e6e : 10e5                     bpl tand11
                        
2e70 : a206                     ldx #6      ;(zp,x)
2e72 : a003                     ldy #3
2e74 :                  tand12
                                set_ay  absANa,0
                       >            load_flag 0
2e74 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2e76 : 48              >            pha         ;use stack to load status
2e77 : b95a02          >            lda absANa,y    ;precharge accu
2e7a : 28              >            plp
                        
2e7b : 2130                     and (indAN,x)
                                tst_ay  absrlo,absflo,0
2e7d : 08              >            php         ;save flags
2e7e : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e81 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e83 : 68              >            pla         ;load status
                       >            eor_flag 0
2e84 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2e86 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e8b : ca                       dex
2e8c : ca                       dex
2e8d : 88                       dey
2e8e : 10e4                     bpl tand12
2e90 : a206                     ldx #6
2e92 : a003                     ldy #3
2e94 :                  tand13
                                set_ay  absANa,$ff
                       >            load_flag $ff
2e94 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2e96 : 48              >            pha         ;use stack to load status
2e97 : b95a02          >            lda absANa,y    ;precharge accu
2e9a : 28              >            plp
                        
2e9b : 2130                     and (indAN,x)
                                tst_ay  absrlo,absflo,$ff-fnz
2e9d : 08              >            php         ;save flags
2e9e : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2ea1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ea3 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ea4 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2ea6 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2ea9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2eab : ca                       dex
2eac : ca                       dex
2ead : 88                       dey
2eae : 10e4                     bpl tand13
                        
2eb0 : a003                     ldy #3      ;(zp),y
2eb2 :                  tand14
                                set_ay  absANa,0
                       >            load_flag 0
2eb2 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2eb4 : 48              >            pha         ;use stack to load status
2eb5 : b95a02          >            lda absANa,y    ;precharge accu
2eb8 : 28              >            plp
                        
2eb9 : 3130                     and (indAN),y
                                tst_ay  absrlo,absflo,0
2ebb : 08              >            php         ;save flags
2ebc : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2ebf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ec1 : 68              >            pla         ;load status
                       >            eor_flag 0
2ec2 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2ec4 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2ec7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ec9 : 88                       dey
2eca : 10e6                     bpl tand14
2ecc : a003                     ldy #3
2ece :                  tand15
                                set_ay  absANa,$ff
                       >            load_flag $ff
2ece : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2ed0 : 48              >            pha         ;use stack to load status
2ed1 : b95a02          >            lda absANa,y    ;precharge accu
2ed4 : 28              >            plp
                        
2ed5 : 3130                     and (indAN),y
                                tst_ay  absrlo,absflo,$ff-fnz
2ed7 : 08              >            php         ;save flags
2ed8 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2edb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2edd : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ede : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2ee0 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2ee3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ee5 : 88                       dey
2ee6 : 10e6                     bpl tand15
                                next_test
2ee8 : ad0002          >            lda test_case   ;previous test
2eeb : c926            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2eed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0027 =                 >test_num = test_num + 1
2eef : a927            >            lda #test_num   ;*** next tests' number
2ef1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; EOR
2ef4 : a203                     ldx #3          ;immediate - self modifying code
2ef6 : b516             teor    lda zpEO,x
2ef8 : 8d0c02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,0
                       >            load_flag 0
2efb : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2efd : 48              >            pha         ;use stack to load status
2efe : bd5e02          >            lda absEOa,x    ;precharge accu
2f01 : 28              >            plp
                        
2f02 : 200b02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,0
2f05 : 08              >            php         ;save flags
2f06 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f09 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f0b : 68              >            pla         ;load status
                       >            eor_flag 0
2f0c : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2f0e : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f11 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f13 : ca                       dex
2f14 : 10e0                     bpl teor
2f16 : a203                     ldx #3
2f18 : b516             teor1   lda zpEO,x
2f1a : 8d0c02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f1d : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2f1f : 48              >            pha         ;use stack to load status
2f20 : bd5e02          >            lda absEOa,x    ;precharge accu
2f23 : 28              >            plp
                        
2f24 : 200b02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
2f27 : 08              >            php         ;save flags
2f28 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f2b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f2d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f2e : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2f30 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f33 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f35 : ca                       dex
2f36 : 10e0                     bpl teor1
                            
2f38 : a203                     ldx #3      ;zp
2f3a : b516             teor2    lda zpEO,x
2f3c : 8502                     sta zpt
                                set_ax  absEOa,0
                       >            load_flag 0
2f3e : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2f40 : 48              >            pha         ;use stack to load status
2f41 : bd5e02          >            lda absEOa,x    ;precharge accu
2f44 : 28              >            plp
                        
2f45 : 4502                     eor zpt
                                tst_ax  absrlo,absflo,0
2f47 : 08              >            php         ;save flags
2f48 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f4b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f4d : 68              >            pla         ;load status
                       >            eor_flag 0
2f4e : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2f50 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f53 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f55 : ca                       dex
2f56 : 10e2                     bpl teor2
2f58 : a203                     ldx #3
2f5a : b516             teor3   lda zpEO,x
2f5c : 8502                     sta zpt
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f5e : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2f60 : 48              >            pha         ;use stack to load status
2f61 : bd5e02          >            lda absEOa,x    ;precharge accu
2f64 : 28              >            plp
                        
2f65 : 4502                     eor zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2f67 : 08              >            php         ;save flags
2f68 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f6d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f6e : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2f70 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f73 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f75 : ca                       dex
2f76 : 10e2                     bpl teor3
                        
2f78 : a203                     ldx #3      ;abs
2f7a : b516             teor4   lda zpEO,x
2f7c : 8d0302                   sta abst
                                set_ax  absEOa,0
                       >            load_flag 0
2f7f : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2f81 : 48              >            pha         ;use stack to load status
2f82 : bd5e02          >            lda absEOa,x    ;precharge accu
2f85 : 28              >            plp
                        
2f86 : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,0
2f89 : 08              >            php         ;save flags
2f8a : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f8d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f8f : 68              >            pla         ;load status
                       >            eor_flag 0
2f90 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2f92 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f95 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f97 : ca                       dex
2f98 : 10e0                     bpl teor4
2f9a : a203                     ldx #3
2f9c : b516             teor5   lda zpEO,x
2f9e : 8d0302                   sta abst
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2fa1 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2fa3 : 48              >            pha         ;use stack to load status
2fa4 : bd5e02          >            lda absEOa,x    ;precharge accu
2fa7 : 28              >            plp
                        
2fa8 : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,$ff-fnz
2fab : 08              >            php         ;save flags
2fac : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2faf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fb1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2fb2 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2fb4 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fb7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fb9 : ca                       dex
2fba : 1002                     bpl teor6
                        
2fbc : a203                     ldx #3      ;zp,x
2fbe :                  teor6
                                set_ax  absEOa,0
                       >            load_flag 0
2fbe : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2fc0 : 48              >            pha         ;use stack to load status
2fc1 : bd5e02          >            lda absEOa,x    ;precharge accu
2fc4 : 28              >            plp
                        
2fc5 : 5516                     eor zpEO,x
                                tst_ax  absrlo,absflo,0
2fc7 : 08              >            php         ;save flags
2fc8 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fcb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fcd : 68              >            pla         ;load status
                       >            eor_flag 0
2fce : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
2fd0 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fd3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fd5 : ca                       dex
2fd6 : 10e6                     bpl teor6
2fd8 : a203                     ldx #3
2fda :                  teor7
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2fda : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
2fdc : 48              >            pha         ;use stack to load status
2fdd : bd5e02          >            lda absEOa,x    ;precharge accu
2fe0 : 28              >            plp
                        
2fe1 : 5516                     eor zpEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
2fe3 : 08              >            php         ;save flags
2fe4 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fe7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fe9 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2fea : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
2fec : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ff1 : ca                       dex
2ff2 : 10e6                     bpl teor7
                        
2ff4 : a203                     ldx #3      ;abs,x
2ff6 :                  teor8
                                set_ax  absEOa,0
                       >            load_flag 0
2ff6 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
2ff8 : 48              >            pha         ;use stack to load status
2ff9 : bd5e02          >            lda absEOa,x    ;precharge accu
2ffc : 28              >            plp
                        
2ffd : 5d5202                   eor absEO,x
                                tst_ax  absrlo,absflo,0
3000 : 08              >            php         ;save flags
3001 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3004 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3006 : 68              >            pla         ;load status
                       >            eor_flag 0
3007 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
3009 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
300c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
300e : ca                       dex
300f : 10e5                     bpl teor8
3011 : a203                     ldx #3
3013 :                  teor9
                                set_ax  absEOa,$ff
                       >            load_flag $ff
3013 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
3015 : 48              >            pha         ;use stack to load status
3016 : bd5e02          >            lda absEOa,x    ;precharge accu
3019 : 28              >            plp
                        
301a : 5d5202                   eor absEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
301d : 08              >            php         ;save flags
301e : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3021 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3023 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3024 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
3026 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3029 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
302b : ca                       dex
302c : 10e5                     bpl teor9
                        
302e : a003                     ldy #3      ;abs,y
3030 :                  teor10
                                set_ay  absEOa,0
                       >            load_flag 0
3030 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
3032 : 48              >            pha         ;use stack to load status
3033 : b95e02          >            lda absEOa,y    ;precharge accu
3036 : 28              >            plp
                        
3037 : 595202                   eor absEO,y
                                tst_ay  absrlo,absflo,0
303a : 08              >            php         ;save flags
303b : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
303e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3040 : 68              >            pla         ;load status
                       >            eor_flag 0
3041 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
3043 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3046 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3048 : 88                       dey
3049 : 10e5                     bpl teor10
304b : a003                     ldy #3
304d :                  teor11
                                set_ay  absEOa,$ff
                       >            load_flag $ff
304d : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
304f : 48              >            pha         ;use stack to load status
3050 : b95e02          >            lda absEOa,y    ;precharge accu
3053 : 28              >            plp
                        
3054 : 595202                   eor absEO,y
                                tst_ay  absrlo,absflo,$ff-fnz
3057 : 08              >            php         ;save flags
3058 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
305b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
305d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
305e : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
3060 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3063 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3065 : 88                       dey
3066 : 10e5                     bpl teor11
                        
3068 : a206                     ldx #6      ;(zp,x)
306a : a003                     ldy #3
306c :                  teor12
                                set_ay  absEOa,0
                       >            load_flag 0
306c : a904            >            lda #0|intdis      ;force disable interrupts
                       >
306e : 48              >            pha         ;use stack to load status
306f : b95e02          >            lda absEOa,y    ;precharge accu
3072 : 28              >            plp
                        
3073 : 4138                     eor (indEO,x)
                                tst_ay  absrlo,absflo,0
3075 : 08              >            php         ;save flags
3076 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3079 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
307b : 68              >            pla         ;load status
                       >            eor_flag 0
307c : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
307e : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3081 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3083 : ca                       dex
3084 : ca                       dex
3085 : 88                       dey
3086 : 10e4                     bpl teor12
3088 : a206                     ldx #6
308a : a003                     ldy #3
308c :                  teor13
                                set_ay  absEOa,$ff
                       >            load_flag $ff
308c : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
308e : 48              >            pha         ;use stack to load status
308f : b95e02          >            lda absEOa,y    ;precharge accu
3092 : 28              >            plp
                        
3093 : 4138                     eor (indEO,x)
                                tst_ay  absrlo,absflo,$ff-fnz
3095 : 08              >            php         ;save flags
3096 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3099 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
309b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
309c : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
309e : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
30a1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30a3 : ca                       dex
30a4 : ca                       dex
30a5 : 88                       dey
30a6 : 10e4                     bpl teor13
                        
30a8 : a003                     ldy #3      ;(zp),y
30aa :                  teor14
                                set_ay  absEOa,0
                       >            load_flag 0
30aa : a904            >            lda #0|intdis      ;force disable interrupts
                       >
30ac : 48              >            pha         ;use stack to load status
30ad : b95e02          >            lda absEOa,y    ;precharge accu
30b0 : 28              >            plp
                        
30b1 : 5138                     eor (indEO),y
                                tst_ay  absrlo,absflo,0
30b3 : 08              >            php         ;save flags
30b4 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
30b7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30b9 : 68              >            pla         ;load status
                       >            eor_flag 0
30ba : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
30bc : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
30bf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30c1 : 88                       dey
30c2 : 10e6                     bpl teor14
30c4 : a003                     ldy #3
30c6 :                  teor15
                                set_ay  absEOa,$ff
                       >            load_flag $ff
30c6 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
30c8 : 48              >            pha         ;use stack to load status
30c9 : b95e02          >            lda absEOa,y    ;precharge accu
30cc : 28              >            plp
                        
30cd : 5138                     eor (indEO),y
                                tst_ay  absrlo,absflo,$ff-fnz
30cf : 08              >            php         ;save flags
30d0 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
30d3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30d5 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30d6 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
30d8 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
30db : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30dd : 88                       dey
30de : 10e6                     bpl teor15
                                next_test
30e0 : ad0002          >            lda test_case   ;previous test
30e3 : c927            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
30e5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0028 =                 >test_num = test_num + 1
30e7 : a928            >            lda #test_num   ;*** next tests' number
30e9 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; OR
30ec : a203                     ldx #3          ;immediate - self modifying code
30ee : b50e             tora    lda zpOR,x
30f0 : 8d0f02                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,0
                       >            load_flag 0
30f3 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
30f5 : 48              >            pha         ;use stack to load status
30f6 : bd5602          >            lda absORa,x    ;precharge accu
30f9 : 28              >            plp
                        
30fa : 200e02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,0
30fd : 08              >            php         ;save flags
30fe : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3101 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3103 : 68              >            pla         ;load status
                       >            eor_flag 0
3104 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
3106 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3109 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
310b : ca                       dex
310c : 10e0                     bpl tora
310e : a203                     ldx #3
3110 : b50e             tora1   lda zpOR,x
3112 : 8d0f02                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,$ff
                       >            load_flag $ff
3115 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
3117 : 48              >            pha         ;use stack to load status
3118 : bd5602          >            lda absORa,x    ;precharge accu
311b : 28              >            plp
                        
311c : 200e02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
311f : 08              >            php         ;save flags
3120 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3123 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3125 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3126 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
3128 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
312b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
312d : ca                       dex
312e : 10e0                     bpl tora1
                            
3130 : a203                     ldx #3      ;zp
3132 : b50e             tora2   lda zpOR,x
3134 : 8502                     sta zpt
                                set_ax  absORa,0
                       >            load_flag 0
3136 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
3138 : 48              >            pha         ;use stack to load status
3139 : bd5602          >            lda absORa,x    ;precharge accu
313c : 28              >            plp
                        
313d : 0502                     ora zpt
                                tst_ax  absrlo,absflo,0
313f : 08              >            php         ;save flags
3140 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3143 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3145 : 68              >            pla         ;load status
                       >            eor_flag 0
3146 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
3148 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
314b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
314d : ca                       dex
314e : 10e2                     bpl tora2
3150 : a203                     ldx #3
3152 : b50e             tora3   lda zpOR,x
3154 : 8502                     sta zpt
                                set_ax  absORa,$ff
                       >            load_flag $ff
3156 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
3158 : 48              >            pha         ;use stack to load status
3159 : bd5602          >            lda absORa,x    ;precharge accu
315c : 28              >            plp
                        
315d : 0502                     ora zpt
                                tst_ax  absrlo,absflo,$ff-fnz
315f : 08              >            php         ;save flags
3160 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3163 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3165 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3166 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
3168 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
316b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
316d : ca                       dex
316e : 10e2                     bpl tora3
                        
3170 : a203                     ldx #3      ;abs
3172 : b50e             tora4   lda zpOR,x
3174 : 8d0302                   sta abst
                                set_ax  absORa,0
                       >            load_flag 0
3177 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
3179 : 48              >            pha         ;use stack to load status
317a : bd5602          >            lda absORa,x    ;precharge accu
317d : 28              >            plp
                        
317e : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,0
3181 : 08              >            php         ;save flags
3182 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3185 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3187 : 68              >            pla         ;load status
                       >            eor_flag 0
3188 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
318a : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
318d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
318f : ca                       dex
3190 : 10e0                     bpl tora4
3192 : a203                     ldx #3
3194 : b50e             tora5   lda zpOR,x
3196 : 8d0302                   sta abst
                                set_ax  absORa,$ff
                       >            load_flag $ff
3199 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
319b : 48              >            pha         ;use stack to load status
319c : bd5602          >            lda absORa,x    ;precharge accu
319f : 28              >            plp
                        
31a0 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,$ff-fnz
31a3 : 08              >            php         ;save flags
31a4 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31a7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31a9 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31aa : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
31ac : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31af : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31b1 : ca                       dex
31b2 : 1002                     bpl tora6
                        
31b4 : a203                     ldx #3      ;zp,x
31b6 :                  tora6
                                set_ax  absORa,0
                       >            load_flag 0
31b6 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
31b8 : 48              >            pha         ;use stack to load status
31b9 : bd5602          >            lda absORa,x    ;precharge accu
31bc : 28              >            plp
                        
31bd : 150e                     ora zpOR,x
                                tst_ax  absrlo,absflo,0
31bf : 08              >            php         ;save flags
31c0 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31c3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31c5 : 68              >            pla         ;load status
                       >            eor_flag 0
31c6 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
31c8 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31cb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31cd : ca                       dex
31ce : 10e6                     bpl tora6
31d0 : a203                     ldx #3
31d2 :                  tora7
                                set_ax  absORa,$ff
                       >            load_flag $ff
31d2 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
31d4 : 48              >            pha         ;use stack to load status
31d5 : bd5602          >            lda absORa,x    ;precharge accu
31d8 : 28              >            plp
                        
31d9 : 150e                     ora zpOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
31db : 08              >            php         ;save flags
31dc : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31df : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31e1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31e2 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
31e4 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31e7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31e9 : ca                       dex
31ea : 10e6                     bpl tora7
                        
31ec : a203                     ldx #3      ;abs,x
31ee :                  tora8
                                set_ax  absORa,0
                       >            load_flag 0
31ee : a904            >            lda #0|intdis      ;force disable interrupts
                       >
31f0 : 48              >            pha         ;use stack to load status
31f1 : bd5602          >            lda absORa,x    ;precharge accu
31f4 : 28              >            plp
                        
31f5 : 1d4a02                   ora absOR,x
                                tst_ax  absrlo,absflo,0
31f8 : 08              >            php         ;save flags
31f9 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31fc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31fe : 68              >            pla         ;load status
                       >            eor_flag 0
31ff : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
3201 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3204 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3206 : ca                       dex
3207 : 10e5                     bpl tora8
3209 : a203                     ldx #3
320b :                  tora9
                                set_ax  absORa,$ff
                       >            load_flag $ff
320b : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
320d : 48              >            pha         ;use stack to load status
320e : bd5602          >            lda absORa,x    ;precharge accu
3211 : 28              >            plp
                        
3212 : 1d4a02                   ora absOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
3215 : 08              >            php         ;save flags
3216 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3219 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
321b : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
321c : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
321e : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3221 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3223 : ca                       dex
3224 : 10e5                     bpl tora9
                        
3226 : a003                     ldy #3      ;abs,y
3228 :                  tora10
                                set_ay  absORa,0
                       >            load_flag 0
3228 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
322a : 48              >            pha         ;use stack to load status
322b : b95602          >            lda absORa,y    ;precharge accu
322e : 28              >            plp
                        
322f : 194a02                   ora absOR,y
                                tst_ay  absrlo,absflo,0
3232 : 08              >            php         ;save flags
3233 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3236 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3238 : 68              >            pla         ;load status
                       >            eor_flag 0
3239 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
323b : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
323e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3240 : 88                       dey
3241 : 10e5                     bpl tora10
3243 : a003                     ldy #3
3245 :                  tora11
                                set_ay  absORa,$ff
                       >            load_flag $ff
3245 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
3247 : 48              >            pha         ;use stack to load status
3248 : b95602          >            lda absORa,y    ;precharge accu
324b : 28              >            plp
                        
324c : 194a02                   ora absOR,y
                                tst_ay  absrlo,absflo,$ff-fnz
324f : 08              >            php         ;save flags
3250 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3253 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3255 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3256 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
3258 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
325b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
325d : 88                       dey
325e : 10e5                     bpl tora11
                        
3260 : a206                     ldx #6      ;(zp,x)
3262 : a003                     ldy #3
3264 :                  tora12
                                set_ay  absORa,0
                       >            load_flag 0
3264 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
3266 : 48              >            pha         ;use stack to load status
3267 : b95602          >            lda absORa,y    ;precharge accu
326a : 28              >            plp
                        
326b : 0140                     ora (indOR,x)
                                tst_ay  absrlo,absflo,0
326d : 08              >            php         ;save flags
326e : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3271 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3273 : 68              >            pla         ;load status
                       >            eor_flag 0
3274 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
3276 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3279 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
327b : ca                       dex
327c : ca                       dex
327d : 88                       dey
327e : 10e4                     bpl tora12
3280 : a206                     ldx #6
3282 : a003                     ldy #3
3284 :                  tora13
                                set_ay  absORa,$ff
                       >            load_flag $ff
3284 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
3286 : 48              >            pha         ;use stack to load status
3287 : b95602          >            lda absORa,y    ;precharge accu
328a : 28              >            plp
                        
328b : 0140                     ora (indOR,x)
                                tst_ay  absrlo,absflo,$ff-fnz
328d : 08              >            php         ;save flags
328e : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3291 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3293 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3294 : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
3296 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3299 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
329b : ca                       dex
329c : ca                       dex
329d : 88                       dey
329e : 10e4                     bpl tora13
                        
32a0 : a003                     ldy #3      ;(zp),y
32a2 :                  tora14
                                set_ay  absORa,0
                       >            load_flag 0
32a2 : a904            >            lda #0|intdis      ;force disable interrupts
                       >
32a4 : 48              >            pha         ;use stack to load status
32a5 : b95602          >            lda absORa,y    ;precharge accu
32a8 : 28              >            plp
                        
32a9 : 1140                     ora (indOR),y
                                tst_ay  absrlo,absflo,0
32ab : 08              >            php         ;save flags
32ac : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32af : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32b1 : 68              >            pla         ;load status
                       >            eor_flag 0
32b2 : 4934            >            eor #(0|fai)       ;invert expected flags + always on bits + I
                       >
32b4 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
32b7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32b9 : 88                       dey
32ba : 10e6                     bpl tora14
32bc : a003                     ldy #3
32be :                  tora15
                                set_ay  absORa,$ff
                       >            load_flag $ff
32be : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
32c0 : 48              >            pha         ;use stack to load status
32c1 : b95602          >            lda absORa,y    ;precharge accu
32c4 : 28              >            plp
                        
32c5 : 1140                     ora (indOR),y
                                tst_ay  absrlo,absflo,$ff-fnz
32c7 : 08              >            php         ;save flags
32c8 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32cb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32cd : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
32ce : 497d            >            eor #($ff-fnz|fai)       ;invert expected flags + always on bits + I
                       >
32d0 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
32d3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32d5 : 88                       dey
32d6 : 10e6                     bpl tora15
                            if I_flag = 3
                                cli
                            endif                
                                next_test
32d8 : ad0002          >            lda test_case   ;previous test
32db : c928            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
32dd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0029 =                 >test_num = test_num + 1
32df : a929            >            lda #test_num   ;*** next tests' number
32e1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
32e4 : d8                       cld
32e5 : a204                     ldx #ad2        ;for indexed test
32e7 : a0ff                     ldy #$ff        ;max range
32e9 : a900                     lda #0          ;start with adding zeroes & no carry
32eb : 8502                     sta adfc        ;carry in - for diag
32ed : 8503                     sta ad1         ;operand 1 - accumulator
32ef : 8504                     sta ad2         ;operand 2 - memory or immediate
32f1 : 8d0302                   sta ada2        ;non zp
32f4 : 8505                     sta adrl        ;expected result bits 0-7
32f6 : 8506                     sta adrh        ;expected result bit 8 (carry out)
32f8 : a9ff                     lda #$ff        ;complemented operand 2 for subtract
32fa : 8508                     sta sb2
32fc : 8d0402                   sta sba2        ;non zp
32ff : a902                     lda #2          ;expected Z-flag
3301 : 8507                     sta adrf
3303 : 18               tadd    clc             ;test with carry clear
3304 : 207e35                   jsr chkadd
3307 : e602                     inc adfc        ;now with carry
3309 : e605                     inc adrl        ;result +1
330b : 08                       php             ;save N & Z from low result
330c : 08                       php
330d : 68                       pla             ;accu holds expected flags
330e : 2982                     and #$82        ;mask N & Z
3310 : 28                       plp
3311 : d002                     bne tadd1
3313 : e606                     inc adrh        ;result bit 8 - carry
3315 : 0506             tadd1   ora adrh        ;merge C to expected flags
3317 : 8507                     sta adrf        ;save expected flags except overflow
3319 : 38                       sec             ;test with carry set
331a : 207e35                   jsr chkadd
331d : c602                     dec adfc        ;same for operand +1 but no carry
331f : e603                     inc ad1
3321 : d0e0                     bne tadd        ;iterate op1
3323 : a900                     lda #0          ;preset result to op2 when op1 = 0
3325 : 8506                     sta adrh
3327 : ee0302                   inc ada2
332a : e604                     inc ad2
332c : 08                       php             ;save NZ as operand 2 becomes the new result
332d : 68                       pla
332e : 2982                     and #$82        ;mask N00000Z0
3330 : 8507                     sta adrf        ;no need to check carry as we are adding to 0
3332 : c608                     dec sb2         ;complement subtract operand 2
3334 : ce0402                   dec sba2
3337 : a504                     lda ad2         
3339 : 8505                     sta adrl
333b : d0c6                     bne tadd        ;iterate op2
                            if disable_decimal < 1
                                next_test
333d : ad0002          >            lda test_case   ;previous test
3340 : c929            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
3342 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
002a =                 >test_num = test_num + 1
3344 : a92a            >            lda #test_num   ;*** next tests' number
3346 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
3349 : f8                       sed 
334a : a204                     ldx #ad2        ;for indexed test
334c : a0ff                     ldy #$ff        ;max range
334e : a999                     lda #$99        ;start with adding 99 to 99 with carry
3350 : 8503                     sta ad1         ;operand 1 - accumulator
3352 : 8504                     sta ad2         ;operand 2 - memory or immediate
3354 : 8d0302                   sta ada2        ;non zp
3357 : 8505                     sta adrl        ;expected result bits 0-7
3359 : a901                     lda #1          ;set carry in & out
335b : 8502                     sta adfc        ;carry in - for diag
335d : 8506                     sta adrh        ;expected result bit 8 (carry out)
335f : a900                     lda #0          ;complemented operand 2 for subtract
3361 : 8508                     sta sb2
3363 : 8d0402                   sta sba2        ;non zp
3366 : 38               tdad    sec             ;test with carry set
3367 : 204b34                   jsr chkdad
336a : c602                     dec adfc        ;now with carry clear
336c : a505                     lda adrl        ;decimal adjust result
336e : d008                     bne tdad1       ;skip clear carry & preset result 99 (9A-1)
3370 : c606                     dec adrh
3372 : a999                     lda #$99
3374 : 8505                     sta adrl
3376 : d012                     bne tdad3
3378 : 290f             tdad1   and #$f         ;lower nibble mask
337a : d00c                     bne tdad2       ;no decimal adjust needed
337c : c605                     dec adrl        ;decimal adjust (?0-6)
337e : c605                     dec adrl
3380 : c605                     dec adrl
3382 : c605                     dec adrl
3384 : c605                     dec adrl
3386 : c605                     dec adrl
3388 : c605             tdad2   dec adrl        ;result -1
338a : 18               tdad3   clc             ;test with carry clear
338b : 204b34                   jsr chkdad
338e : e602                     inc adfc        ;same for operand -1 but with carry
3390 : a503                     lda ad1         ;decimal adjust operand 1
3392 : f015                     beq tdad5       ;iterate operand 2
3394 : 290f                     and #$f         ;lower nibble mask
3396 : d00c                     bne tdad4       ;skip decimal adjust
3398 : c603                     dec ad1         ;decimal adjust (?0-6)
339a : c603                     dec ad1
339c : c603                     dec ad1
339e : c603                     dec ad1
33a0 : c603                     dec ad1
33a2 : c603                     dec ad1
33a4 : c603             tdad4   dec ad1         ;operand 1 -1
33a6 : 4c6633                   jmp tdad        ;iterate op1
                        
33a9 : a999             tdad5   lda #$99        ;precharge op1 max
33ab : 8503                     sta ad1
33ad : a504                     lda ad2         ;decimal adjust operand 2
33af : f030                     beq tdad7       ;end of iteration
33b1 : 290f                     and #$f         ;lower nibble mask
33b3 : d018                     bne tdad6       ;skip decimal adjust
33b5 : c604                     dec ad2         ;decimal adjust (?0-6)
33b7 : c604                     dec ad2
33b9 : c604                     dec ad2
33bb : c604                     dec ad2
33bd : c604                     dec ad2
33bf : c604                     dec ad2
33c1 : e608                     inc sb2         ;complemented decimal adjust for subtract (?9+6)
33c3 : e608                     inc sb2
33c5 : e608                     inc sb2
33c7 : e608                     inc sb2
33c9 : e608                     inc sb2
33cb : e608                     inc sb2
33cd : c604             tdad6   dec ad2         ;operand 2 -1
33cf : e608                     inc sb2         ;complemented operand for subtract
33d1 : a508                     lda sb2
33d3 : 8d0402                   sta sba2        ;copy as non zp operand
33d6 : a504                     lda ad2
33d8 : 8d0302                   sta ada2        ;copy as non zp operand
33db : 8505                     sta adrl        ;new result since op1+carry=00+carry +op2=op2
33dd : e606                     inc adrh        ;result carry
33df : d085                     bne tdad        ;iterate op2
33e1 :                  tdad7
                                next_test
33e1 : ad0002          >            lda test_case   ;previous test
33e4 : c92a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
33e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
002b =                 >test_num = test_num + 1
33e8 : a92b            >            lda #test_num   ;*** next tests' number
33ea : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; decimal/binary switch test
                        ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
                        ;   tables
33ed : 18                       clc
33ee : d8                       cld
33ef : 08                       php
33f0 : a955                     lda #$55
33f2 : 6955                     adc #$55
33f4 : c9aa                     cmp #$aa
                                trap_ne         ;expected binary result after cld
33f6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33f8 : 18                       clc
33f9 : f8                       sed
33fa : 08                       php
33fb : a955                     lda #$55
33fd : 6955                     adc #$55
33ff : c910                     cmp #$10
                                trap_ne         ;expected decimal result after sed
3401 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3403 : d8                       cld
3404 : 28                       plp
3405 : a955                     lda #$55
3407 : 6955                     adc #$55
3409 : c910                     cmp #$10
                                trap_ne         ;expected decimal result after plp D=1
340b : d0fe            >        bne *           ;failed not equal (non zero)
                        
340d : 28                       plp
340e : a955                     lda #$55
3410 : 6955                     adc #$55
3412 : c9aa                     cmp #$aa
                                trap_ne         ;expected binary result after plp D=0
3414 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3416 : 18                       clc
3417 : a934                     lda #hi bin_rti_ret ;emulated interrupt for rti
3419 : 48                       pha
341a : a931                     lda #lo bin_rti_ret
341c : 48                       pha
341d : 08                       php
341e : f8                       sed
341f : a934                     lda #hi dec_rti_ret ;emulated interrupt for rti
3421 : 48                       pha
3422 : a928                     lda #lo dec_rti_ret
3424 : 48                       pha
3425 : 08                       php
3426 : d8                       cld
3427 : 40                       rti
3428 :                  dec_rti_ret
3428 : a955                     lda #$55
342a : 6955                     adc #$55
342c : c910                     cmp #$10
                                trap_ne         ;expected decimal result after rti D=1
342e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3430 : 40                       rti
3431 :                  bin_rti_ret        
3431 : a955                     lda #$55
3433 : 6955                     adc #$55
3435 : c9aa                     cmp #$aa
                                trap_ne         ;expected binary result after rti D=0
3437 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                            endif
                            
3439 : ad0002                   lda test_case
343c : c92b                     cmp #test_num
                                trap_ne         ;previous test is out of sequence
343e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3440 : a9f0                     lda #$f0        ;mark opcode testing complete
3442 : 8d0002                   sta test_case
                                
                        ; final RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                                check_ram
                       >            ;RAM check disabled - RAM size not set
                        
                        ; *** DEBUG INFO ***
                        ; to debug checksum errors uncomment check_ram in the next_test macro to
                        ; narrow down the responsible opcode.
                        ; may give false errors when monitor, OS or other background activity is
                        ; allowed during previous tests.
                        
                        
                        ; S U C C E S S ************************************************
                        ; -------------       
                                success         ;if you get here everything went well
3445 : 4c4534          >        jmp *           ;test passed, no errors
                        
                        ; -------------       
                        ; S U C C E S S ************************************************
3448 : 4c0004                   jmp start       ;run again      
                        
                            if disable_decimal < 1
                        ; core subroutine of the decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
344b :                  chkdad
                        ; decimal ADC / SBC zp
344b : 08                       php             ;save carry for subtract
344c : a503                     lda ad1
344e : 6504                     adc ad2         ;perform add
3450 : 08                       php          
3451 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3453 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3455 : 68                       pla             ;check flags
3456 : 2901                     and #1          ;mask carry
3458 : c506                     cmp adrh
                                trap_ne         ;bad carry
345a : d0fe            >        bne *           ;failed not equal (non zero)
                        
345c : 28                       plp
345d : 08                       php             ;save carry for next add
345e : a503                     lda ad1
3460 : e508                     sbc sb2         ;perform subtract
3462 : 08                       php          
3463 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3465 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3467 : 68                       pla             ;check flags
3468 : 2901                     and #1          ;mask carry
346a : c506                     cmp adrh
                                trap_ne         ;bad flags
346c : d0fe            >        bne *           ;failed not equal (non zero)
                        
346e : 28                       plp
                        ; decimal ADC / SBC abs
346f : 08                       php             ;save carry for subtract
3470 : a503                     lda ad1
3472 : 6d0302                   adc ada2        ;perform add
3475 : 08                       php          
3476 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3478 : d0fe            >        bne *           ;failed not equal (non zero)
                        
347a : 68                       pla             ;check flags
347b : 2901                     and #1          ;mask carry
347d : c506                     cmp adrh
                                trap_ne         ;bad carry
347f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3481 : 28                       plp
3482 : 08                       php             ;save carry for next add
3483 : a503                     lda ad1
3485 : ed0402                   sbc sba2        ;perform subtract
3488 : 08                       php          
3489 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
348b : d0fe            >        bne *           ;failed not equal (non zero)
                        
348d : 68                       pla             ;check flags
348e : 2901                     and #1          ;mask carry
3490 : c506                     cmp adrh
                                trap_ne         ;bad carry
3492 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3494 : 28                       plp
                        ; decimal ADC / SBC #
3495 : 08                       php             ;save carry for subtract
3496 : a504                     lda ad2
3498 : 8d1202                   sta ex_adci+1   ;set ADC # operand
349b : a503                     lda ad1
349d : 201102                   jsr ex_adci     ;execute ADC # in RAM
34a0 : 08                       php          
34a1 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
34a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34a5 : 68                       pla             ;check flags
34a6 : 2901                     and #1          ;mask carry
34a8 : c506                     cmp adrh
                                trap_ne         ;bad carry
34aa : d0fe            >        bne *           ;failed not equal (non zero)
                        
34ac : 28                       plp
34ad : 08                       php             ;save carry for next add
34ae : a508                     lda sb2
34b0 : 8d1502                   sta ex_sbci+1   ;set SBC # operand
34b3 : a503                     lda ad1
34b5 : 201402                   jsr ex_sbci     ;execute SBC # in RAM
34b8 : 08                       php          
34b9 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
34bb : d0fe            >        bne *           ;failed not equal (non zero)
                        
34bd : 68                       pla             ;check flags
34be : 2901                     and #1          ;mask carry
34c0 : c506                     cmp adrh
                                trap_ne         ;bad carry
34c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34c4 : 28                       plp
                        ; decimal ADC / SBC zp,x
34c5 : 08                       php             ;save carry for subtract
34c6 : a503                     lda ad1
34c8 : 7500                     adc 0,x         ;perform add
34ca : 08                       php          
34cb : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
34cd : d0fe            >        bne *           ;failed not equal (non zero)
                        
34cf : 68                       pla             ;check flags
34d0 : 2901                     and #1          ;mask carry
34d2 : c506                     cmp adrh
                                trap_ne         ;bad carry
34d4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34d6 : 28                       plp
34d7 : 08                       php             ;save carry for next add
34d8 : a503                     lda ad1
34da : f504                     sbc sb2-ad2,x   ;perform subtract
34dc : 08                       php          
34dd : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
34df : d0fe            >        bne *           ;failed not equal (non zero)
                        
34e1 : 68                       pla             ;check flags
34e2 : 2901                     and #1          ;mask carry
34e4 : c506                     cmp adrh
                                trap_ne         ;bad carry
34e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34e8 : 28                       plp
                        ; decimal ADC / SBC abs,x
34e9 : 08                       php             ;save carry for subtract
34ea : a503                     lda ad1
34ec : 7dff01                   adc ada2-ad2,x  ;perform add
34ef : 08                       php          
34f0 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
34f2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34f4 : 68                       pla             ;check flags
34f5 : 2901                     and #1          ;mask carry
34f7 : c506                     cmp adrh
                                trap_ne         ;bad carry
34f9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34fb : 28                       plp
34fc : 08                       php             ;save carry for next add
34fd : a503                     lda ad1
34ff : fd0002                   sbc sba2-ad2,x  ;perform subtract
3502 : 08                       php          
3503 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3505 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3507 : 68                       pla             ;check flags
3508 : 2901                     and #1          ;mask carry
350a : c506                     cmp adrh
                                trap_ne         ;bad carry
350c : d0fe            >        bne *           ;failed not equal (non zero)
                        
350e : 28                       plp
                        ; decimal ADC / SBC abs,y
350f : 08                       php             ;save carry for subtract
3510 : a503                     lda ad1
3512 : 790401                   adc ada2-$ff,y  ;perform add
3515 : 08                       php          
3516 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3518 : d0fe            >        bne *           ;failed not equal (non zero)
                        
351a : 68                       pla             ;check flags
351b : 2901                     and #1          ;mask carry
351d : c506                     cmp adrh
                                trap_ne         ;bad carry
351f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3521 : 28                       plp
3522 : 08                       php             ;save carry for next add
3523 : a503                     lda ad1
3525 : f90501                   sbc sba2-$ff,y  ;perform subtract
3528 : 08                       php          
3529 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
352b : d0fe            >        bne *           ;failed not equal (non zero)
                        
352d : 68                       pla             ;check flags
352e : 2901                     and #1          ;mask carry
3530 : c506                     cmp adrh
                                trap_ne         ;bad carry
3532 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3534 : 28                       plp
                        ; decimal ADC / SBC (zp,x)
3535 : 08                       php             ;save carry for subtract
3536 : a503                     lda ad1
3538 : 6144                     adc (lo adi2-ad2,x) ;perform add
353a : 08                       php          
353b : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
353d : d0fe            >        bne *           ;failed not equal (non zero)
                        
353f : 68                       pla             ;check flags
3540 : 2901                     and #1          ;mask carry
3542 : c506                     cmp adrh
                                trap_ne         ;bad carry
3544 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3546 : 28                       plp
3547 : 08                       php             ;save carry for next add
3548 : a503                     lda ad1
354a : e146                     sbc (lo sbi2-ad2,x) ;perform subtract
354c : 08                       php          
354d : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
354f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3551 : 68                       pla             ;check flags
3552 : 2901                     and #1          ;mask carry
3554 : c506                     cmp adrh
                                trap_ne         ;bad carry
3556 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3558 : 28                       plp
                        ; decimal ADC / SBC (abs),y
3559 : 08                       php             ;save carry for subtract
355a : a503                     lda ad1
355c : 714c                     adc (adiy2),y   ;perform add
355e : 08                       php          
355f : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3561 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3563 : 68                       pla             ;check flags
3564 : 2901                     and #1          ;mask carry
3566 : c506                     cmp adrh
                                trap_ne         ;bad carry
3568 : d0fe            >        bne *           ;failed not equal (non zero)
                        
356a : 28                       plp
356b : 08                       php             ;save carry for next add
356c : a503                     lda ad1
356e : f14e                     sbc (sbiy2),y   ;perform subtract
3570 : 08                       php          
3571 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3573 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3575 : 68                       pla             ;check flags
3576 : 2901                     and #1          ;mask carry
3578 : c506                     cmp adrh
                                trap_ne         ;bad carry
357a : d0fe            >        bne *           ;failed not equal (non zero)
                        
357c : 28                       plp
357d : 60                       rts
                            endif
                        
                        ; core subroutine of the full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
357e : a507             chkadd  lda adrf        ;add V-flag if overflow
3580 : 2983                     and #$83        ;keep N-----ZC / clear V
3582 : 48                       pha
3583 : a503                     lda ad1         ;test sign unequal between operands
3585 : 4504                     eor ad2
3587 : 300a                     bmi ckad1       ;no overflow possible - operands have different sign
3589 : a503                     lda ad1         ;test sign equal between operands and result
358b : 4505                     eor adrl
358d : 1004                     bpl ckad1       ;no overflow occured - operand and result have same sign
358f : 68                       pla
3590 : 0940                     ora #$40        ;set V
3592 : 48                       pha
3593 : 68               ckad1   pla
3594 : 8507                     sta adrf        ;save expected flags
                        ; binary ADC / SBC zp
3596 : 08                       php             ;save carry for subtract
3597 : a503                     lda ad1
3599 : 6504                     adc ad2         ;perform add
359b : 08                       php          
359c : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
359e : d0fe            >        bne *           ;failed not equal (non zero)
                        
35a0 : 68                       pla             ;check flags
35a1 : 29c3                     and #$c3        ;mask NV----ZC
35a3 : c507                     cmp adrf
                                trap_ne         ;bad flags
35a5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35a7 : 28                       plp
35a8 : 08                       php             ;save carry for next add
35a9 : a503                     lda ad1
35ab : e508                     sbc sb2         ;perform subtract
35ad : 08                       php          
35ae : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
35b0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35b2 : 68                       pla             ;check flags
35b3 : 29c3                     and #$c3        ;mask NV----ZC
35b5 : c507                     cmp adrf
                                trap_ne         ;bad flags
35b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35b9 : 28                       plp
                        ; binary ADC / SBC abs
35ba : 08                       php             ;save carry for subtract
35bb : a503                     lda ad1
35bd : 6d0302                   adc ada2        ;perform add
35c0 : 08                       php          
35c1 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
35c3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35c5 : 68                       pla             ;check flags
35c6 : 29c3                     and #$c3        ;mask NV----ZC
35c8 : c507                     cmp adrf
                                trap_ne         ;bad flags
35ca : d0fe            >        bne *           ;failed not equal (non zero)
                        
35cc : 28                       plp
35cd : 08                       php             ;save carry for next add
35ce : a503                     lda ad1
35d0 : ed0402                   sbc sba2        ;perform subtract
35d3 : 08                       php          
35d4 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
35d6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35d8 : 68                       pla             ;check flags
35d9 : 29c3                     and #$c3        ;mask NV----ZC
35db : c507                     cmp adrf
                                trap_ne         ;bad flags
35dd : d0fe            >        bne *           ;failed not equal (non zero)
                        
35df : 28                       plp
                        ; binary ADC / SBC #
35e0 : 08                       php             ;save carry for subtract
35e1 : a504                     lda ad2
35e3 : 8d1202                   sta ex_adci+1   ;set ADC # operand
35e6 : a503                     lda ad1
35e8 : 201102                   jsr ex_adci     ;execute ADC # in RAM
35eb : 08                       php          
35ec : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
35ee : d0fe            >        bne *           ;failed not equal (non zero)
                        
35f0 : 68                       pla             ;check flags
35f1 : 29c3                     and #$c3        ;mask NV----ZC
35f3 : c507                     cmp adrf
                                trap_ne         ;bad flags
35f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35f7 : 28                       plp
35f8 : 08                       php             ;save carry for next add
35f9 : a508                     lda sb2
35fb : 8d1502                   sta ex_sbci+1   ;set SBC # operand
35fe : a503                     lda ad1
3600 : 201402                   jsr ex_sbci     ;execute SBC # in RAM
3603 : 08                       php          
3604 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3606 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3608 : 68                       pla             ;check flags
3609 : 29c3                     and #$c3        ;mask NV----ZC
360b : c507                     cmp adrf
                                trap_ne         ;bad flags
360d : d0fe            >        bne *           ;failed not equal (non zero)
                        
360f : 28                       plp
                        ; binary ADC / SBC zp,x
3610 : 08                       php             ;save carry for subtract
3611 : a503                     lda ad1
3613 : 7500                     adc 0,x         ;perform add
3615 : 08                       php          
3616 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3618 : d0fe            >        bne *           ;failed not equal (non zero)
                        
361a : 68                       pla             ;check flags
361b : 29c3                     and #$c3        ;mask NV----ZC
361d : c507                     cmp adrf
                                trap_ne         ;bad flags
361f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3621 : 28                       plp
3622 : 08                       php             ;save carry for next add
3623 : a503                     lda ad1
3625 : f504                     sbc sb2-ad2,x   ;perform subtract
3627 : 08                       php          
3628 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
362a : d0fe            >        bne *           ;failed not equal (non zero)
                        
362c : 68                       pla             ;check flags
362d : 29c3                     and #$c3        ;mask NV----ZC
362f : c507                     cmp adrf
                                trap_ne         ;bad flags
3631 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3633 : 28                       plp
                        ; binary ADC / SBC abs,x
3634 : 08                       php             ;save carry for subtract
3635 : a503                     lda ad1
3637 : 7dff01                   adc ada2-ad2,x  ;perform add
363a : 08                       php          
363b : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
363d : d0fe            >        bne *           ;failed not equal (non zero)
                        
363f : 68                       pla             ;check flags
3640 : 29c3                     and #$c3        ;mask NV----ZC
3642 : c507                     cmp adrf
                                trap_ne         ;bad flags
3644 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3646 : 28                       plp
3647 : 08                       php             ;save carry for next add
3648 : a503                     lda ad1
364a : fd0002                   sbc sba2-ad2,x  ;perform subtract
364d : 08                       php          
364e : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3650 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3652 : 68                       pla             ;check flags
3653 : 29c3                     and #$c3        ;mask NV----ZC
3655 : c507                     cmp adrf
                                trap_ne         ;bad flags
3657 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3659 : 28                       plp
                        ; binary ADC / SBC abs,y
365a : 08                       php             ;save carry for subtract
365b : a503                     lda ad1
365d : 790401                   adc ada2-$ff,y  ;perform add
3660 : 08                       php          
3661 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3663 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3665 : 68                       pla             ;check flags
3666 : 29c3                     and #$c3        ;mask NV----ZC
3668 : c507                     cmp adrf
                                trap_ne         ;bad flags
366a : d0fe            >        bne *           ;failed not equal (non zero)
                        
366c : 28                       plp
366d : 08                       php             ;save carry for next add
366e : a503                     lda ad1
3670 : f90501                   sbc sba2-$ff,y  ;perform subtract
3673 : 08                       php          
3674 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3676 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3678 : 68                       pla             ;check flags
3679 : 29c3                     and #$c3        ;mask NV----ZC
367b : c507                     cmp adrf
                                trap_ne         ;bad flags
367d : d0fe            >        bne *           ;failed not equal (non zero)
                        
367f : 28                       plp
                        ; binary ADC / SBC (zp,x)
3680 : 08                       php             ;save carry for subtract
3681 : a503                     lda ad1
3683 : 6144                     adc (lo adi2-ad2,x) ;perform add
3685 : 08                       php          
3686 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
3688 : d0fe            >        bne *           ;failed not equal (non zero)
                        
368a : 68                       pla             ;check flags
368b : 29c3                     and #$c3        ;mask NV----ZC
368d : c507                     cmp adrf
                                trap_ne         ;bad flags
368f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3691 : 28                       plp
3692 : 08                       php             ;save carry for next add
3693 : a503                     lda ad1
3695 : e146                     sbc (lo sbi2-ad2,x) ;perform subtract
3697 : 08                       php          
3698 : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
369a : d0fe            >        bne *           ;failed not equal (non zero)
                        
369c : 68                       pla             ;check flags
369d : 29c3                     and #$c3        ;mask NV----ZC
369f : c507                     cmp adrf
                                trap_ne         ;bad flags
36a1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36a3 : 28                       plp
                        ; binary ADC / SBC (abs),y
36a4 : 08                       php             ;save carry for subtract
36a5 : a503                     lda ad1
36a7 : 714c                     adc (adiy2),y   ;perform add
36a9 : 08                       php          
36aa : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
36ac : d0fe            >        bne *           ;failed not equal (non zero)
                        
36ae : 68                       pla             ;check flags
36af : 29c3                     and #$c3        ;mask NV----ZC
36b1 : c507                     cmp adrf
                                trap_ne         ;bad flags
36b3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36b5 : 28                       plp
36b6 : 08                       php             ;save carry for next add
36b7 : a503                     lda ad1
36b9 : f14e                     sbc (sbiy2),y   ;perform subtract
36bb : 08                       php          
36bc : c505                     cmp adrl        ;check result
                                trap_ne         ;bad result
36be : d0fe            >        bne *           ;failed not equal (non zero)
                        
36c0 : 68                       pla             ;check flags
36c1 : 29c3                     and #$c3        ;mask NV----ZC
36c3 : c507                     cmp adrf
                                trap_ne         ;bad flags
36c5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36c7 : 28                       plp
36c8 : 60                       rts
                        
                        ; target for the jump absolute test
36c9 : 88                       dey
36ca : 88                       dey
36cb :                  test_far
36cb : 08                       php             ;either SP or Y count will fail, if we do not hit
36cc : 88                       dey
36cd : 88                       dey
36ce : 88                       dey
36cf : 28                       plp
                                trap_cs         ;flags loaded?
36d0 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
36d2 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
36d4 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
36d6 : f0fe            >        beq *           ;failed equal (zero)
                        
36d8 : c946                     cmp #'F'        ;registers loaded?
                                trap_ne
36da : d0fe            >        bne *           ;failed not equal (non zero)
                        
36dc : e041                     cpx #'A'
                                trap_ne        
36de : d0fe            >        bne *           ;failed not equal (non zero)
                        
36e0 : c04f                     cpy #('R'-3)
                                trap_ne
36e2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36e4 : 48                       pha             ;save a,x
36e5 : 8a                       txa
36e6 : 48                       pha
36e7 : ba                       tsx
36e8 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
36ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
36ec : 68                       pla             ;restore x
36ed : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
36ee : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
36f0 : 48              >            pha         ;use stack to load status
36f1 : 28              >            plp
                        
36f2 : 68                       pla             ;restore a
36f3 : e8                       inx             ;return registers with modifications
36f4 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
36f6 : 4c1009                   jmp far_ret
                                
                        ; target for the jump indirect test
36f9 : 00                       align
36fa : 0337             ptr_tst_ind dw test_ind
36fc : 6509             ptr_ind_ret dw ind_ret
                                trap            ;runover protection
36fe : 4cfe36          >        jmp *           ;failed anyway
                        
3701 : 88                       dey
3702 : 88                       dey
3703 :                  test_ind
3703 : 08                       php             ;either SP or Y count will fail, if we do not hit
3704 : 88                       dey
3705 : 88                       dey
3706 : 88                       dey
3707 : 28                       plp
                                trap_cs         ;flags loaded?
3708 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
370a : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
370c : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
370e : f0fe            >        beq *           ;failed equal (zero)
                        
3710 : c949                     cmp #'I'        ;registers loaded?
                                trap_ne
3712 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3714 : e04e                     cpx #'N'
                                trap_ne        
3716 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3718 : c041                     cpy #('D'-3)
                                trap_ne
371a : d0fe            >        bne *           ;failed not equal (non zero)
                        
371c : 48                       pha             ;save a,x
371d : 8a                       txa
371e : 48                       pha
371f : ba                       tsx
3720 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
3722 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3724 : 68                       pla             ;restore x
3725 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
3726 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
3728 : 48              >            pha         ;use stack to load status
3729 : 28              >            plp
                        
372a : 68                       pla             ;restore a
372b : e8                       inx             ;return registers with modifications
372c : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
372e : 6cfc36                   jmp (ptr_ind_ret)
                                trap            ;runover protection
3731 : 4c3137          >        jmp *           ;failed anyway
                        
3734 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                        ; target for the jump subroutine test
3737 : 88                       dey
3738 : 88                       dey
3739 :                  test_jsr
3739 : 08                       php             ;either SP or Y count will fail, if we do not hit
373a : 88                       dey
373b : 88                       dey
373c : 88                       dey
373d : 28                       plp
                                trap_cs         ;flags loaded?
373e : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
3740 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
3742 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
3744 : f0fe            >        beq *           ;failed equal (zero)
                        
3746 : c94a                     cmp #'J'        ;registers loaded?
                                trap_ne
3748 : d0fe            >        bne *           ;failed not equal (non zero)
                        
374a : e053                     cpx #'S'
                                trap_ne        
374c : d0fe            >        bne *           ;failed not equal (non zero)
                        
374e : c04f                     cpy #('R'-3)
                                trap_ne
3750 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3752 : 48                       pha             ;save a,x
3753 : 8a                       txa
3754 : 48                       pha       
3755 : ba                       tsx             ;sp -4? (return addr,a,x)
3756 : e0fb                     cpx #$fb
                                trap_ne
3758 : d0fe            >        bne *           ;failed not equal (non zero)
                        
375a : adff01                   lda $1ff        ;propper return on stack
375d : c909                     cmp #hi(jsr_ret)
                                trap_ne
375f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3761 : adfe01                   lda $1fe
3764 : c99b                     cmp #lo(jsr_ret)
                                trap_ne
3766 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
3768 : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                       >
376a : 48              >            pha         ;use stack to load status
376b : 28              >            plp
                        
376c : 68                       pla             ;pull x,a
376d : aa                       tax
376e : 68                       pla
376f : e8                       inx             ;return registers with modifications
3770 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
3772 : 60                       rts
                                trap            ;runover protection
3773 : 4c7337          >        jmp *           ;failed anyway
                        
3776 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
3779 :                  nmi_trap
                                trap            ;check stack for conditions at NMI
3779 : 4c7937          >        jmp *           ;failed anyway
                        
377c : 4c0004                   jmp start       ;catastrophic error - cannot continue
377f :                  res_trap
                                trap            ;unexpected RESET
377f : 4c7f37          >        jmp *           ;failed anyway
                        
3782 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
3785 : 88                       dey
3786 : 88                       dey
3787 :                  irq_trap                ;BRK test or unextpected BRK or IRQ
3787 : 08                       php             ;either SP or Y count will fail, if we do not hit
3788 : 88                       dey
3789 : 88                       dey
378a : 88                       dey
                                ;next traps could be caused by unexpected BRK or IRQ
                                ;check stack for BREAK and originating location
                                ;possible jump/branch into weeds (uninitialized space)
378b : c9bd                     cmp #$ff-'B'    ;BRK pass 2 registers loaded?
378d : f042                     beq break2
378f : c942                     cmp #'B'        ;BRK pass 1 registers loaded?
                                trap_ne
3791 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3793 : e052                     cpx #'R'
                                trap_ne        
3795 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3797 : c048                     cpy #'K'-3
                                trap_ne
3799 : d0fe            >        bne *           ;failed not equal (non zero)
                        
379b : 8500                     sta irq_a       ;save registers during break test
379d : 8601                     stx irq_x
379f : ba                       tsx             ;test break on stack
37a0 : bd0201                   lda $102,x
                                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
37a3 : c934            >            cmp #(0      |fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne         ; - no break flag on stack
37a5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
37a7 : 68                       pla
                                cmp_flag intdis ;should have added interrupt disable
37a8 : c934            >            cmp #(intdis |fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
37aa : d0fe            >        bne *           ;failed not equal (non zero)
                        
37ac : ba                       tsx
37ad : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
37af : d0fe            >        bne *           ;failed not equal (non zero)
                        
37b1 : adff01                   lda $1ff        ;propper return on stack
37b4 : c909                     cmp #hi(brk_ret0)
                                trap_ne
37b6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
37b8 : adfe01                   lda $1fe
37bb : c9d2                     cmp #lo(brk_ret0)
                                trap_ne
37bd : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                load_flag $ff
37bf : a9ff            >            lda #$ff|intdis      ;force disable interrupts
                        
37c1 : 48                       pha
37c2 : a601                     ldx irq_x
37c4 : e8                       inx             ;return registers with modifications
37c5 : a500                     lda irq_a
37c7 : 49aa                     eor #$aa
37c9 : 28                       plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
37ca : 40                       rti
                                trap            ;runover protection
37cb : 4ccb37          >        jmp *           ;failed anyway
                        
37ce : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
37d1 :                  break2                  ;BRK pass 2        
37d1 : e0ad                     cpx #$ff-'R'
                                trap_ne        
37d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
37d5 : c0b1                     cpy #$ff-'K'-3
                                trap_ne
37d7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
37d9 : 8500                     sta irq_a       ;save registers during break test
37db : 8601                     stx irq_x
37dd : ba                       tsx             ;test break on stack
37de : bd0201                   lda $102,x
                                cmp_flag $ff    ;break test should have B=1
37e1 : c9ff            >            cmp #($ff    |fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne         ; - no break flag on stack
37e3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
37e5 : 68                       pla
37e6 : 0908                     ora #decmode    ;ignore decmode cleared if 65c02
                                cmp_flag $ff    ;actual passed flags
37e8 : c9ff            >            cmp #($ff    |fai)&m8    ;I_flag is always disabled + always on bits
                        
                                trap_ne
37ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
37ec : ba                       tsx
37ed : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
37ef : d0fe            >        bne *           ;failed not equal (non zero)
                        
37f1 : adff01                   lda $1ff        ;propper return on stack
37f4 : c909                     cmp #hi(brk_ret1)
                                trap_ne
37f6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
37f8 : adfe01                   lda $1fe
37fb : c9f8                     cmp #lo(brk_ret1)
                                trap_ne
37fd : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                load_flag intdis
37ff : a904            >            lda #intdis|intdis      ;force disable interrupts
                        
3801 : 48                       pha      
3802 : a601                     ldx irq_x
3804 : e8                       inx             ;return registers with modifications
3805 : a500                     lda irq_a
3807 : 49aa                     eor #$aa
3809 : 28                       plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
380a : 40                       rti
                                trap            ;runover protection
380b : 4c0b38          >        jmp *           ;failed anyway
                        
380e : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                            if report = 1
                                include "report.i65"
                            endif
                                
                        ;copy of data to initialize BSS segment
                            if load_data_direct != 1
                        zp_init
                        zp1_    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        zp7f_   db  $7f             ;test pattern for compare
                        ;logical zeropage operands
                        zpOR_   db  0,$1f,$71,$80   ;test pattern for OR
                        zpAN_   db  $0f,$ff,$7f,$80 ;test pattern for AND
                        zpEO_   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
                        ind1_   dw  abs1            ;indirect pointer to pattern in absolute memory
                                dw  abs1+1
                                dw  abs1+2
                                dw  abs1+3
                                dw  abs7f
                        inw1_   dw  abs1-$f8        ;indirect pointer for wrap-test pattern
                        indt_   dw  abst            ;indirect pointer to store area in absolute memory
                                dw  abst+1
                                dw  abst+2
                                dw  abst+3
                        inwt_   dw  abst-$f8        ;indirect pointer for wrap-test store
                        indAN_  dw  absAN           ;indirect pointer to AND pattern in absolute memory
                                dw  absAN+1
                                dw  absAN+2
                                dw  absAN+3
                        indEO_  dw  absEO           ;indirect pointer to EOR pattern in absolute memory
                                dw  absEO+1
                                dw  absEO+2
                                dw  absEO+3
                        indOR_  dw  absOR           ;indirect pointer to OR pattern in absolute memory
                                dw  absOR+1
                                dw  absOR+2
                                dw  absOR+3
                        ;add/subtract indirect pointers
                        adi2_   dw  ada2            ;indirect pointer to operand 2 in absolute memory
                        sbi2_   dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
                        adiy2_  dw  ada2-$ff        ;with offset for indirect indexed
                        sbiy2_  dw  sba2-$ff
                        zp_end
                            if (zp_end - zp_init) != (zp_bss_end - zp_bss)   
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and zeropage data
                            endif 
                        data_init
                        ex_and_ and #0              ;execute immediate opcodes
                                rts
                        ex_eor_ eor #0              ;execute immediate opcodes
                                rts
                        ex_ora_ ora #0              ;execute immediate opcodes
                                rts
                        ex_adc_ adc #0              ;execute immediate opcodes
                                rts
                        ex_sbc_ sbc #0              ;execute immediate opcodes
                                rts
                        abs1_   db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        abs7f_  db  $7f             ;test pattern for compare
                        ;loads
                        fLDx_   db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
                        rASL_                       ;expected result ASL & ROL -carry
                        rROL_   db  $86,$04,$82,0   ; "
                        rROLc_  db  $87,$05,$83,1   ;expected result ROL +carry
                        rLSR_                       ;expected result LSR & ROR -carry
                        rROR_   db  $61,$41,$20,0   ; "
                        rRORc_  db  $e1,$c1,$a0,$80 ;expected result ROR +carry
                        fASL_                       ;expected flags for shifts
                        fROL_   db  fnc,fc,fn,fz    ;no carry in
                        fROLc_  db  fnc,fc,fn,0     ;carry in
                        fLSR_
                        fROR_   db  fc,0,fc,fz      ;no carry in
                        fRORc_  db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
                        rINC_   db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
                        fINC_   db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
                        absOR_  db  0,$1f,$71,$80   ;test pattern for OR
                        absAN_  db  $0f,$ff,$7f,$80 ;test pattern for AND
                        absEO_  db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
                        absORa_ db  0,$f1,$1f,0     ;test pattern for OR
                        absANa_ db  $f0,$ff,$ff,$ff ;test pattern for AND
                        absEOa_ db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
                        absrlo_ db  0,$ff,$7f,$80
                        absflo_ db  fz,fn,0,fn
                        data_end
                            if (data_end - data_init) != (data_bss_end - data_bss)
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and data
                            endif 
                        
                        vec_init
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                        vec_bss equ $fffa
                            endif                   ;end of RAM init data
                            
                            if (load_data_direct = 1) & (ROM_vectors = 1)  
fffa =                          org $fffa       ;vectors
fffa : 7937                     dw  nmi_trap
fffc : 7f37                     dw  res_trap
fffe : 8737                     dw  irq_trap
                            endif
                        
fffa =                          end start
                                    
No errors in pass 2.
Wrote binary from address $0000 through $ffff.
Total size 65536 bytes.
Program start address is at $0400 (1024).
