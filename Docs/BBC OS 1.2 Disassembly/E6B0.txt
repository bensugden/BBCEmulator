**************************************************************************                                                                       **        OSBYTE LOOK UP TABLE                                           **                                                                       **************************************************************************E5B3	DB  &21,&E8         ;OSBYTE   0  (&E821)E5B5	DB  &88,&E9         ;OSBYTE   1  (&E988)E5B7	DB  &D3,&E6         ;OSBYTE   2  (&E6D3)E5B9	DB  &97,&E9         ;OSBYTE   3  (&E997)E5BB	DB  &97,&E9         ;OSBYTE   4  (&E997)E5BD	DB  &76,&E9         ;OSBYTE   5  (&E976)E5BF	DB  &88,&E9         ;OSBYTE   6  (&E988)E5C1	DB  &8B,&E6         ;OSBYTE   7  (&E68B)E5C3	DB  &89,&E6         ;OSBYTE   8  (&E689)E5C5	DB  &B0,&E6         ;OSBYTE   9  (&E6B0)E5C7	DB  &B2,&E6         ;OSBYTE  10  (&E6B2)E5C9	DB  &95,&E9         ;OSBYTE  11  (&E995)E5CB	DB  &8C,&E9         ;OSBYTE  12  (&E98C)E5CD	DB  &F9,&E6         ;OSBYTE  13  (&E6F9)E5CF	DB  &FA,&E6         ;OSBYTE  14  (&E6FA)E5D1	DB  &A8,&F0         ;OSBYTE  15  (&F0A8)E5D3	DB  &06,&E7         ;OSBYTE  16  (&E706)E5D5	DB  &8C,&DE         ;OSBYTE  17  (&DE8C)E5D7	DB  &C8,&E9         ;OSBYTE  18  (&E9C8)E5D9	DB  &B6,&E9         ;OSBYTE  19  (&E9B6)E5DB	DB  &07,&CD         ;OSBYTE  20  (&CD07)E5DD	DB  &B4,&F0         ;OSBYTE  21  (&F0B4)E5DF	DB  &6C,&E8         ;OSBYTE 117  (&E86C)E5E1	DB  &D9,&E9         ;OSBYTE 118  (&E9D9)E5E3	DB  &75,&E2         ;OSBYTE 119  (&E275)E5E5	DB  &45,&F0         ;OSBYTE 120  (&F045)E5E7	DB  &CF,&F0         ;OSBYTE 121  (&F0CF)E5E9	DB  &CD,&F0         ;OSBYTE 122  (&F0CD)E5EB	DB  &97,&E1         ;OSBYTE 123  (&E197)E5ED	DB  &73,&E6         ;OSBYTE 124  (&E673)E5EF	DB  &74,&E6         ;OSBYTE 125  (&E674)E5F1	DB  &5C,&E6         ;OSBYTE 126  (&E65C)E5F3	DB  &35,&E0         ;OSBYTE 127  (&E035)E5F5	DB  &4F,&E7         ;OSBYTE 128  (&E74F)E5F7	DB  &13,&E7         ;OSBYTE 129  (&E713)E5F9	DB  &29,&E7         ;OSBYTE 130  (&E729)E5FB	DB  &85,&F0         ;OSBYTE 131  (&F085)E5FD	DB  &23,&D9         ;OSBYTE 132  (&D923)E5FF	DB  &26,&D9         ;OSBYTE 133  (&D926)E601	DB  &47,&D6         ;OSBYTE 134  (&D647)E603	DB  &C2,&D7         ;OSBYTE 135  (&D7C2)E605	DB  &57,&E6         ;OSBYTE 136  (&E657)E607	DB  &7F,&E6         ;OSBYTE 137  (&E67F)E609	DB  &AF,&E4         ;OSBYTE 138  (&E4AF)E60B	DB  &34,&E0         ;OSBYTE 139  (&E034)E60D	DB  &35,&F1         ;OSBYTE 140  (&F135)E60F	DB  &35,&F1         ;OSBYTE 141  (&F135)E611	DB  &E7,&DB         ;OSBYTE 142  (&DBE7)E613	DB  &68,&F1         ;OSBYTE 143  (&F168)E615	DB  &E3,&EA         ;OSBYTE 144  (&EAE3)E617	DB  &60,&E4         ;OSBYTE 145  (&E460)E619	DB  &AA,&FF         ;OSBYTE 146  (&FFAA)E61B	DB  &F4,&EA         ;OSBYTE 147  (&EAF4)E61D	DB  &AE,&FF         ;OSBYTE 148  (&FFAE)E61F	DB  &F9,&EA         ;OSBYTE 149  (&EAF9)E621	DB  &B2,&FF         ;OSBYTE 150  (&FFB2)E623	DB  &FE,&EA         ;OSBYTE 151  (&EAFE)E625	DB  &5B,&E4         ;OSBYTE 152  (&E45B)E627	DB  &F3,&E4         ;OSBYTE 153  (&E4F3)E629	DB  &FF,&E9         ;OSBYTE 154  (&E9FF)E62B	DB  &10,&EA         ;OSBYTE 155  (&EA10)E62D	DB  &7C,&E1         ;OSBYTE 156  (&E17C)E62F	DB  &A7,&FF         ;OSBYTE 157  (&FFA7)E631	DB  &6D,&EE         ;OSBYTE 158  (&EE6D)E633	DB  &7F,&EE         ;OSBYTE 159  (&EE7F)E635	DB  &C0,&E9         ;OSBYTE 160  (&E9C0)E637	DB  &9C,&E9         ;OSBYTE 166+E639	DB  &59,&E6         ;OSWORD &E0+**************************************************************************                                                                       **        OSWORD LOOK UP TABLE                                           **                                                                       **************************************************************************E63B	DB  &02,&E9         ;OSWORD   0  (&E902)E63D	DB  &D5,&E8         ;OSWORD   1  (&E8D5)E63F	DB  &E8,&E8         ;OSWORD   2  (&E8E8)E641	DB  &D1,&E8         ;OSWORD   3  (&E8D1)E643	DB  &E4,&E8         ;OSWORD   4  (&E8E4)E645	DB  &03,&E8         ;OSWORD   5  (&E803)E647	DB  &0B,&E8         ;OSWORD   6  (&E80B)E649	DB  &2D,&E8         ;OSWORD   7  (&E82D)E64B	DB  &AE,&E8         ;OSWORD   8  (&E8AE)E64D	DB  &35,&C7         ;OSWORD   9  (&C735)E64F	DB  &F3,&CB         ;OSWORD  10  (&CBF3)E651	DB  &48,&C7         ;OSWORD  11  (&C748)E653	DB  &E0,&C8         ;OSWORD  12  (&C8E0)E655	DB  &CE,&D5         ;OSWORD  13  (&D5CE)**************************************************************************                                                                       **       OSBYTE 136   Execute Code via User Vector                       **                                                                       **       *CODE effectively                                               **                                                                       **************************************************************************E658	LDA #00     ;A=0**************************************************************************                                                                       **       *LINE   entry                                                   **                                                                       **************************************************************************E659	JMP (&0200) ;Jump via USERV**************************************************************************                                                                       **       OSBYTE  126  Acknowledge detection of ESCAPE condition          **                                                                       **************************************************************************E65C	LDX #&00    ;X=0E65E	BIT &FF     ;if bit 7 not set there is no ESCAPE conditionE660	BPL &E673   ;so E673E662	LDA &0276   ;else get ESCAPE Action, if this is 0    	            ;Clear ESCAPE    	            ;close EXEC files    	            ;purge all buffers    	            ;reset VDU paging counterE665	BNE &E671   ;else do none of the aboveE667	CLI         ;allow interruptsE668	STA &0269   ;number of lines printed since last halt in paged    	            ;mode = 0E66B	JSR &F68D   ;close any open EXEC filesE66E	JSR &F0AA   ;clear all buffersE671	LDX #&FF    ;X=&FF to indicate ESCAPE acknowledged**************************************************************************                                                                       **       OSBYTE  124  Clear ESCAPE condition                             **                                                                       **************************************************************************E673	CLC         ;clear carry**************************************************************************                                                                       **       OSBYTE  125  Set ESCAPE flag                                    **                                                                       **************************************************************************E674	ROR &FF     ;clear  bit 7 of ESCAPE flagE676	BIT &027A   ;read bit 7 of Tube flagE679	BMI &E67C   ;if set TUBE exists so E67CE67B	RTS         ;else RETURN    	            ;E67C	JMP &0403   ;Jump to Tube entry point**************************************************************************                                                                       **       OSBYTE  137  Turn on Tape motor                                 **                                                                       **************************************************************************E67F	LDA &0282   ;get serial ULA control settingE682	TAY         ;Y=AE683	ROL         ;rotate left to get bit 7 into carryE684	CPX #&01    ;if X=1 then user wants motor on so CARRY set else    	            ;carry is clearedE686	ROR         ;put carry back in control RAM copyE687	BVC &E6A7   ;if bit 6 is clear then cassette is selected    	            ;so write to control register and RAM copyE689	LDA #&38    ;A=ASCII 8**************************************************************************                                                                       **       OSBYTE 08/07 set serial baud rates                              **                                                                       **************************************************************************    	on entry X=baud rate    	     A=8 transmit    	     A=7 receiveE68B	EOR #&3F    ;converts ASCII 8 to 7 binary and ASCII 7 to 8 binaryE68D	STA &FA     ;store resultE68F	LDY &0282   ;get serial ULA control register settingE692	CPX #&09    ;is it 9 or more?E694	BCS &E6AD   ;if so exitE696	AND &E9AD,X ;and with byte from look up tableE699	STA &FB     ;store itE69B	TYA         ;put Y in AE69C	ORA &FA     ;and or with AccumulatorE69E	EOR &FA     ;zero the three bits set trueE6A0	ORA &FB     ;set up data read from look up table + bit 6E6A2	ORA #&40    ;E6A4	EOR &025D   ;write cassette/RS423 flagE6A7	STA &0282   ;store serial ULA flagE6AA	STA &FE10   ;and write to control registerE6AD	TYA         ;put Y in A to save old contentsE6AE	TAX         ;write new setting to XE6AF	RTS         ;and returnOS SERIES VIIGEOFF COX**************************************************************************                                                                       **       OSBYTE  9   Duration of first colour                            **                                                                       **************************************************************************;on entry Y=0, X=new valueE6B0	INY         ;Y is incremented to 1E6B1	CLC         ;clear carry**************************************************************************                                                                       **       OSBYTE  10   Duration of second colour                          **                                                                       **************************************************************************;on entry Y=0 or 1 if from FX 9 call, X=new valueE6B2	LDA &0252,Y ;get mark period countE6B5	PHA         ;push itE6B6	TXA         ;get new countE6B7	STA &0252,Y ;store itE6BA	PLA         ;get back original valueE6BB	TAY         ;put it in YE6BC	LDA &0251   ;get value of flash counterE6BF	BNE &E6D1   ;if not zero E6D1E6C1	STX &0251   ;else restore old valueE6C4	LDA &0248   ;get current video ULA control register settingE6C7	PHP         ;push flagsE6C8	ROR         ;rotate bit 0 into carry, carry into bit 7E6C9	PLP         ;get back flagsE6CA	ROL         ;rotate back carry into bit 0E6CB	STA &0248   ;store it in RAM copyE6CE	STA &FE20   ;and ULA control registerE6D1	BVC &E6AD   ;then exit via OSBYTE 7/8**************************************************************************                                                                       **       OSBYTE  2   select input stream                                 **                                                                       **************************************************************************;on input X contains stream numberE6D3	TXA         ;A=XE6D4	AND #&01    ;blank out bits 1 - 7E6D6	PHA         ;push AE6D7	LDA &0250   ;and get current ACIA control settingE6DA	ROL         ;Bit 7 into carryE6DB	CPX #&01    ;if X>=1 thenE6DD	ROR         ;bit 7 of A=1E6DE	CMP &0250   ;compare this with ACIA control settingE6E1	PHP         ;push processorE6E2	STA &0250   ;put A into ACIA control settingE6E5	STA &FE08   ;and write to control registerE6E8	JSR &E173   ;set up RS423 bufferE6EB	PLP         ;get back PE6EC	BEQ &E6F1   ;if new setting different from old E6F1 elseE6EE	BIT &FE09   ;set bit 6 and 7E6F1	LDX &0241   ;get current input buffer numberE6F4	PLA         ;get back AE6F5	STA &0241   ;store itE6F8	RTS         ;and return**************************************************************************                                                                       **       OSBYTE  13   disable events                                     **                                                                       **************************************************************************    	;X contains event number 0-9E6F9	TYA         ;Y=0 A=0**************************************************************************                                                                       **       OSBYTE  14   enable events                                      **                                                                       **************************************************************************;X contains event number 0-9E6FA	CPX #&0A    ;if X>9E6FC	BCS &E6AE   ;goto E6AE for exitE6FE	LDY &02BF,X ;else get event enable flagE701	STA &02BF,X ;store new value in flagE704	BVC &E6AD   ;and exit via E6AD**************************************************************************                                                                       **       OSBYTE  16   Select A/D channel                                 **                                                                       **************************************************************************;X contains channel number or 0 if disable conversionE706	BEQ &E70B   ;if X=0 then E70BE708	JSR &DE8C   ;start conversionE70B	LDA &024D   ;get  current maximum ADC channel numberE70E	STX &024D   ;store new valueE711	TAX         ;put old value in XE712	RTS         ;and exit**************************************************************************                                                                       **       OSBYTE 129   Read key within time limit                         **                                                                       **************************************************************************;X and Y contains either time limit in centi seconds Y=&7F max; or Y=&FF and X=-ve INKEY valueE713	TYA         ;A=YE714	BMI &E721   ;if Y=&FF the E721E716	CLI         ;else allow interruptsE717	JSR &DEBB   ;and go to timed routineE71A	BCS &E71F   ;if carry set then E71FE71C	TAX         ;then X=AE71D	LDA #&00    ;A=0E71F	TAY         ;Y=AE720	RTS         ;and return    	            ;    	            ;scan keyboardE721	TXA         ;A=XE722	EOR #&7F    ;convert to keyboard inputE724	TAX         ;X=AE725	JSR &F068   ;then scan keyboardE728	ROL         ;put bit 7 into carryE729	LDX #&FF    ;X=&FFE72B	LDY #&FF    ;Y=&FFE72D	BCS &E731   ;if bit 7 of A was set goto E731 (RTS)E72F	INX         ;else X=0E730	INY         ;and Y=0E731	RTS         ;and exit********** check occupancy of input or free space of output buffer *******    	            ;X=buffer number    	;Buffer number  Address         Flag    Out pointer     In pointer    	;0=Keyboard     3E0-3FF         2CF     2D8             2E1    	;1=RS423 Input  A00-AFF         2D0     2D9             2E2    	;2=RS423 output 900-9BF         2D1     2DA             2E3    	;3=printer      880-8BF         2D2     2DB             2E4    	;4=sound0       840-84F         2D3     2DC             2E5    	;5=sound1       850-85F         2D4     2DD             2E6    	;6=sound2       860-86F         2D5     2DE             2E7    	;7=sound3       870-87F         2D6     2DF             2E8    	;8=speech       8C0-8FF         2D7     2E0             2E9E732	TXA         ;buffer number in AE733	EOR #&FF    ;invert itE735	TAX         ;X=AE736	CPX #&02    ;is X>1E738	CLV         ;clear V flagE739	BVC &E73E   ;and goto E73E count bufferE73B	BIT &D9B7   ;set VE73E	JMP (&022E) ;CNPV defaults to E1D1************* check RS423 input buffer ************************************E741	SECE742	LDX #&01    ;X=1 to point to bufferE744	JSR &E738   ;and count itE747	CPY #&01    ;if the hi byte of the answer is 1 or moreE749	BCS &E74E   ;then ReturnE74B	CPX &025B   ;else compare with minimum buffer spaceE74E	RTS         ;and exit**************************************************************************                                                                       **       OSBYTE 128  READ ADC CHANNEL                                    **                                                                       **************************************************************************;ON Entry: X=0             Exit Y contains number of last channel converted;   	   X=channel number       X,Y contain 16 bit value read from channe;   	   X<0 Y=&FF              X returns information about various buffers;   	   X=&FF (keyboard )      X=number of characters in buffer;   	   X=&FE (RS423 Input)    X=number of characters in buffer;   	   X=&FD (RS423 output)   X=number of empty spaces in buffer;   	   X=&FC (Printer)        X=number of empty spaces in buffer;   	   X=&FB (sound 0)        X=number of empty spaces in buffer;   	   X=&FA (sound 1)        X=number of empty spaces in buffer;   	   X=&F9 (sound 2)        X=number of empty spaces in buffer;   	   X=&F8 (sound 3)        X=number of empty spaces in buffer;   	   X=&F7 (Speech )        X=number of empty spaces in bufferE74F	BMI &E732   ;if X is -ve then E732 count spacesE751	BEQ &E75F   ;if X=0 then E75FE753	CPX #&05    ;else check for Valid channelE755	BCS &E729   ;if not E729 set X & Y to 0 and exitE757	LDY &02B9,X ;get conversion values for channel of interest Hi &E75A	LDA &02B5,X ;lo byteE75D	TAX         ;X=lo byteE75E	RTS         ;and exitE75F	LDA &FE40   ;read system VIA port BE762	ROR         ;move high nybble to lowE763	ROR         ;E764	ROR         ;E765	ROR         ;E766	EOR #&FF    ;and invert itE768	AND #&03    ;isolate the FIRE buttonsE76A	LDY &02BE   ;get analogue system flag byteE76D	STX &02BE   ;store X hereE770	TAX         ;A=X bits 0 and 1 indicate fire buttonsE771	RTS         ;and return******************************************************************************************************************************************************                                                                      ****      OSBYTE  DEFAULT ENTRY POINT                                     ****                                                                      ****      pointed to by default BYTEV                                     ****                                                                      ******************************************************************************************************************************************************E772	PHA         ;save AE773	PHP         ;save Processor flagsE774	SEI         ;disable interruptsE775	STA &EF     ;store A,X,Y in zero pageE777	STX &F0     ;E779	STY &F1     ;E77B	LDX #&07    ;X=7 to signal osbyte is being attemptedE77D	CMP #&75    ;if A=0-116E77F	BCC &E7C2   ;then E7C2E781	CMP #&A1    ;if A<161E783	BCC &E78E   ;then E78EE785	CMP #&A6    ;if A=161-165E787	BCC &E7C8   ;then EC78E789	CLC         ;clear carryE78A	LDA #&A1    ;A=&A1E78C	ADC #&00    ;********* process osbyte calls 117 - 160 *****************************E78E	SEC         ;set carryE78F	SBC #&5F    ;convert to &16 to &41 (22-65)E791	ASL         ;double it (44-130)E792	SEC         ;set carryE793	STY &F1     ;store YE795	TAY         ;Y=AE796	BIT &025E   ;read econet intercept flagE799	BPL &E7A2   ;if no econet intercept required E7A2E79B	TXA         ;else A=XE79C	CLV         ;V=0E79D	JSR &E57E   ; to JMP via ECONET vectorE7A0	BVS &E7BC   ;if return with V set E7BCE7A2	LDA &E5B4,Y ;get address from tableE7A5	STA &FB     ;store it as hi byteE7A7	LDA &E5B3,Y ;repeat for lo byteE7AA	STA &FA     ;E7AC	LDA &EF     ;restore AE7AE	LDY &F1     ;YE7B0	BCS &E7B6   ;if carry is set E7B6E7B2	LDY #&00    ;elseE7B4	LDA (&F0),Y ;get value from address pointed to by &F0/1 (Y,X)E7B6	SEC         ;set carryE7B7	LDX &F0     ;restore XE7B9	JSR &F058   ;call &FA/BE7BC	ROR         ;C=bit 0E7BD	PLP         ;get back flagsE7BE	ROL         ;bit 0=CarryE7BF	PLA         ;get back AE7C0	CLV         ;clear VE7C1	RTS         ;and exit*************** Process OSBYTE CALLS BELOW &75 **************************E7C2	LDY #&00    ;Y=0E7C4	CMP #&16    ;if A<&16E7C6	BCC &E791   ;goto E791E7C8	PHP         ;push flagsE7C9	PHP         ;push flagsE7CA	PLA         ;pull flagsE7CB	PLA         ;pull flagsE7CC	JSR &F168   ;offer paged ROMS service 7/8 unrecognised osbyte/wordE7CF	BNE &E7D6   ;if roms don't recognise it then E7D6E7D1	LDX &F0     ;else restore XE7D3	JMP &E7BC   ;and exitE7D6	PLP         ;else pull flagsE7D7	PLA         ;and AE7D8	BIT &D9B7   ;set V and CE7DB	RTS         ;and returnE7DC	LDA &EB     ;read cassette critical flag bit 7 = busyE7DE	BMI &E812   ;if busy then EB12E7E0	LDA #&08    ;else A=8 to check current Catalogue statusE7E2	AND &E2     ;by anding with CFS status flagE7E4	BNE &E7EA   ;if not set (not in use) then E7EA RTSE7E6	LDA #&88    ;A=%10001000E7E8	AND &BB     ;AND with FS options (short msg bits)E7EA	RTS         ;RETURN******************************************************************************************************************************************************                                                                      ****      OSWORD  DEFAULT ENTRY POINT                                     ****                                                                      ****      pointed to by default WORDV                                     ****                                                                      ******************************************************************************************************************************************************E7EB	PHA         ;Push AE7EC	PHP         ;Push flagsE7ED	SEI         ;disable interruptsE7EE	STA &EF     ;store A,X,YE7F0	STX &F0     ;E7F2	STY &F1     ;E7F4	LDX #&08    ;X=8E7F6	CMP #&E0    ;if A=>224E7F8	BCS &E78A   ;then E78A with carry setE7FA	CMP #&0E    ;else if A=>14E7FC	BCS &E7C8   ;else E7C8 with carry set pass to ROMS & exitE7FE	ADC #&44    ;add to form pointer to tableE800	ASL         ;double itE801	BCC &E793   ;goto E793 ALWAYS!! (carry clear E7F8)    	            ;this reads bytes from table and enters routine**************************************************************************                                                                       **       OSWORD  05   ENTRY POINT                                        **                                                                       **       read a byte from I/O memory                                     **                                                                       **************************************************************************;block of 4 bytes set at address pointed to by 00F0/1 (Y,X);XY +0  ADDRESS of byte;   +4  on exit byte readE803	JSR &E815   ;set up address of data blockE806	LDA (&F9,X) ;get byteE808	STA (&F0),Y ;store itE80A	RTS         ;exit**************************************************************************                                                                       **       OSWORD  06   ENTRY POINT                                        **                                                                       **       write a byte to I/O memory                                      **                                                                       **************************************************************************;block of 5 bytes set at address pointed to by 00F0/1 (Y,X);XY +0  ADDRESS of byte;   +4  byte to be writtenE80B	JSR &E815   ;set up addressE80E	LDA (&F0),Y ;get byteE810	STA (&F9,X) ;store itE812	LDA #&00    ;a=0E814	RTS         ;exit********************: set up data block *********************************E815	STA &FA     ;&FA=AE817	INY         ;Y=1E818	LDA (&F0),Y ;get byte from blockE81A	STA &FB     ;store itE81C	LDY #&04    ;Y=4E81E	LDX #&01    ;X=1E820	RTS         ;and exit**************************************************************************                                                                       **       OSBYTE  00   ENTRY POINT                                        **                                                                       **       read OS version number                                          **                                                                       **************************************************************************E821	BNE &E81E   ;if A <> 0 then exit else print errorE823	BRK         ;E824	DB  &F7             ;error numberE825	DB  'OS 1.20'       ;error messageE82C	BRK