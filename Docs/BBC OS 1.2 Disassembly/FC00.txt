************** FRED 1MHz Bus memory-mapped I/O **************************FC00	;test hardwareFC10-13 ;teletextFC14-1F ;PrestelFC20-27 ;IEEE interfaceFC30	 ;FC40-47 ;winchester disc interfaceFC50	;FC60	;FC70	;FC80	;FC90	;FCA0	;FCB0	;FCC0	;FCD0	;FCE0	;FCF0	;FCFF	;paging register for JIM expansion memory************** JIM 1MHz Bus memory-expansion page ***********************FD00-FF ;FDFE	;Ecosoak Vector************** SHEILA MOS memory-mapped I/O ***************************    	;DEVICE         WRITE                   READFE00	;6845 CRTC      address registerFE01	;6845 CRTC      data registerFE02	;Border colour  border colourFE03	;FE04	;FE05	;FE06	;FE07	;FE08	;6850 ACIA      control register        status registerFE09	;6850 ACIA      transmit data           recieve dataFE0A	;FE0B	;FE0C	;FE0D	;FE0E	;FE0F	;FE10	;SERIAL ULA     control registerFE11	;FE12	;FE13	;FE14	;FE15	;FE16	;FE17	;FE18	;68B54 ADLC     Disable interrupts      Econet station IDFE19	;FE1A	;FE1B	;FE1C	;FE1D	;FE1E	;FE1F	;FE20	;Video ULA      control registerFE21	;Video ULA      palette register        palette registerFE22	;FE23	;FE24	;FE25	;FE26	;FE27	;FE28	;FE29	;FE2A	;FE2B	;FE2C	;FE2D	;FE2E	;FE2F	;FE30	;ROM latch      paged ROM ID            write onlyFE31	;ALTAIR         RAM protectFE32	;FE33	;FE34	;Shadow RAM     B+ only         note different OSFE35	;FE36	;FE37	;FE38	;FE39	;FE3A	;FE3B	;FE3C	;FE3D	;FE3E	;FE3F	;FE40	;MOS 6522 VIA Output Register B                 Input Register BFE41	;MOS 6522 VIA Output Register A                 Input Register AFE42	;MOS 6522 VIA data direction register BFE43	;MOS 6522 VIA data direction register AFE44	;MOS 6522 VIA T1C-L  latches                    T1 low Order counterFE45	;MOS 6522 VIA T1C-H  counterFE46	;MOS 6522 VIA T1L-L low order latchesFE47	;MOS 6522 VIA T1L-H high order latchesFE48	;MOS 6522 VIA T2C-L latches                     T2C-L lo order counterFE49	;MOS 6522 VIA T2C-H T2 high order counterFE4A	;MOS 6522 VIA shift registerFE4B	;MOS 6522 VIA auxilliary control register ACRFE4C	;MOS 6522 VIA Peripheral control register PCRFE4D	;MOS 6522 VIA Interrupt  flag    register IFRFE4E	;MOS 6522 VIA Interrupt enable   register IERFE4F	;MOS 6522 VIA ORB/IRB but no handshakeFE50	;FE51	;FE52	;FE53	;FE54	;FE55	;FE56	;FE57	;FE58	;FE59	;FE5A	;FE5B	;FE5C	;FE5D	;FE5E	;FE5F	;FE60	;USER 6522 VIA Output Register B                Input Register BFE61	;USER 6522 VIA Output Register A                Input Register AFE62	;USER 6522 VIA data direction register BFE63	;USER 6522 VIA data direction register AFE64	;USER 6522 VIA T1C-L  latches                   T1 low Order counterFE65	;USER 6522 VIA T1C-H  counterFE66	;USER 6522 VIA T1L-L low order latchesFE67	;USER 6522 VIA T1L-H high order latchesFE68	;USER 6522 VIA T2C-L latches                    T2C-L lo order counterFE69	;USER 6522 VIA T2C-H T2 high order counterFE6A	;USER 6522 VIA shift registerFE6B	;USER 6522 VIA auxilliary control register ACRFE6C	;USER 6522 VIA Peripheral control register PCRFE6D	;USER 6522 VIA Interrupt  flag    register IFRFE6E	;USER 6522 VIA Interrupt enable   register IERFE6F	;USER 6522 VIA ORB/IRB but no handshakeFE70	;FE71	;FE72	;FE73	;FE74	;FE75	;FE76	;FE77	;FE78	;FE79	;FE7A	;FE7B	;FE7C	;FE7D	;FE7E	;FE7F	;FE80	;8271 FDC       command register                status registerFE81	;8271 FDC       parameter register              result registerFE82	;8271 FDC       reset registerFE83	;8271 FDC       illegal                         illegalFE84	;8271 FDC       data                            dataFE85	;FE86	;FE87	;FE88	;FE89	;FE8A	;FE8B	;FE8C	;FE8D	;FE8E	;FE8F	;FE90	;FE91	;FE92	;FE93	;FE94	;FE95	;FE96	;FE97	;FE98	;FE99	;FE9A	;FE9B	;FE9C	;FE9D	;FE9E	;FE9F	;FEA0	;68B54 ADLC     control register 1              status register 1FEA1	;68B54 ADLC     control register 2/3            status register 2/3FEA2	;68B54 ADLC     Tx FIFO (frame continue)        Rx      FIFOFEA3	;68B54 ADLC     Tx FIFO (frame terminate)       Rx      FIFOFEA4	;FEA5	;FEA6	;FEA7	;FEA8	;FEA9	;FEAA	;FEAB	;FEAC	;FEAD	;FEAE	;FEAF	;FEB0	;FEB1	;FEB2	;FEB3	;FEB4	;FEB5	;FEB6	;FEB7	;FEB8	;FEB9	;FEBA	;FEBB	;FEBC	;FEBD	;FEBE	;FEBF	;FEC0	;7002 ADC       data latch A/D start            statusFEC1	;7002 ADC       hi data byteFEC2	;7002 ADC       lo data byteFEC3	;FEC4	;FEC5	;FEC6	;FEC7	;FEC8	;FEC9	;FECA	;FECB	;FECC	;FECD	;FECE	;FECF	;FED0	;FED1	;FED2	;FED3	;FED4	;FED5	;FED6	;FED7	;FED8	;FED9	;FEDA	;FEDB	;FEDC	;FEDD	;FEDE	;FEDF	;FEE0	;TUBE FIFO1     status registerFEE1	;TUBE FIFO1FEE2	;TUBE FIFO2     status registerFEE3	;TUBE FIFO2FEE4	;TUBE FIFO3     status registerFEE5	;TUBE FIFO3FEE6	;TUBE FIFO4     status registerFEE7	;TUBE FIFO4FEE8	;FEE9	;FEEA	;FEEB	;FEEC	;FEED	;FEEE	;FEEF	;FEF0	;FEF1	;FEF2	;FEF3	;FEF4	;FEF5	;FEF6	;FEF7	;FEF8	;FEF9	;FEFA	;FEFB	;FEFC	;FEFD	;FEFE	;FEFF	;********** EXTENDED VECTOR ENTRY POINTS**********************************;vectors are pointed to &F000 +vector No. vectors may then be directed thru;a three byte vector table whose XY address is given by osbyte A8, X=0, Y=&FF;this is set up as lo-hi byte in ROM and ROM numberFF00	JSR &FF51   ;XUSERVFF03	JSR &FF51   ;XBRKVFF06	JSR &FF51   ;XIRQ1VFF09	JSR &FF51   ;XIRQ2VFF0C	JSR &FF51   ;XCLIVFF0F	JSR &FF51   ;XBYTEVFF12	JSR &FF51   ;XWORDVFF15	JSR &FF51   ;XWRCHVFF18	JSR &FF51   ;XRDCHVFF1B	JSR &FF51   ;XFILEVFF1E	JSR &FF51   ;XARGSVFF21	JSR &FF51   ;XBGETVFF24	JSR &FF51   ;XBPUTVFF27	JSR &FF51   ;XGBPBVFF2A	JSR &FF51   ;XFINDVFF2D	JSR &FF51   ;XFSCVFF30	JSR &FF51   ;XEVENTVFF33	JSR &FF51   ;XUPTVFF36	JSR &FF51   ;XNETVFF39	JSR &FF51   ;XVDUVFF3C	JSR &FF51   ;XKEYVFF3F	JSR &FF51   ;XINSVFF42	JSR &FF51   ;XREMVFF45	JSR &FF51   ;XCNPVFF48	JSR &FF51   ;XIND1VFF4B	JSR &FF51   ;XIND2VFF4E	JSR &FF51   ;XIND3V;at this point the stack will hold 4 bytes (at least);S 0,1 extended vector address;S 2,3 address of calling routine;A,X,Y,P will be as at entryFF51	PHA         ;save A on stackFF52	PHA         ;save A on stackFF53	PHA         ;save A on stackFF54	PHA         ;save A on stackFF55	PHA         ;save A on stackFF56	PHP         ;save flags on stackFF57	PHA         ;save A on stackFF58	TXA         ;A=XFF59	PHA         ;save X on stackFF5A	TYA         ;A=YFF5B	PHA         ;save Y on stackFF5C	TSX         ;get stack pointer into X (&F2 or less)FF5D	LDA #&FF    ;A=&FFFF5F	STA &0108,X ;AFF62	LDA #&88    ;FF64	STA &0107,X ;FF67	LDY &010A,X ;this is VECTOR number*3+2!!FF6A	LDA &0D9D,Y ;lo byte of action addressFF6D	STA &0105,X ;store it on stackFF70	LDA &0D9E,Y ;get hi byteFF73	STA &0106,X ;store it on stack    	            ;at this point stack has YXAP and action address    	            ;followed by return address and 5 more bytesFF76	LDA &F4     ;FF78	STA &0109,X ;store original ROM number below thisFF7B	LDA &0D9F,Y ;get new ROM numberFF7E	STA &F4     ;store it as ram copyFF80	STA &FE30   ;and switch to that ROMFF83	PLA         ;get back AFF84	TAY         ;Y=AFF85	PLA         ;get back AFF86	TAX         ;X=AFF87	PLA         ;get back AFF88	RTI         ;get back flags and jump to ROM vectored entry    	            ;leaving return address and 5 more bytes on stack************ return address from ROM indirection ************************;at this point stack comprises original ROM number,return from JSR &FF51,;return from original call the return from FF51 is garbage so;FF89	PHP         ;save flags on stackFF8A	PHA         ;save A on stackFF8B	TXA         ;A=XFF8C	PHA         ;save X on stackFF8D	TSX         ; (&F7 or less)FF8E	LDA &0102,X ;STORE A AND P OVERFF91	STA &0105,X ;return address from (JSR &FF51)FF94	LDA &0103,X ;hiding garbage by duplicating A and X just savedFF97	STA &0106,X ;    	            ;now we have    	            ;flags,    	            ;A,    	            ;X,    	            ;ROM number,    	            ;A,    	            ;flags,    	            ;and original return address on stack    	            ;soFF9A	PLA         ;get back XFF9B	TAX         ;X=AFF9C	PLA         ;get back A lose next two bytesFF9D	PLA         ;get back A loseFF9E	PLA         ;get back A ROM numberFF9F	STA &F4     ;store itFFA1	STA &FE30   ;and set itFFA4	PLA         ;get back AFFA5	PLP         ;get back flagsFFA6	RTS         ;return and exit pulling original return address    	            ;from stack;FFA6 is also default input for CFS OSBPGB, VDUV, IND1V,IND2V,IND3V;as these functions are not implemented by the OS but may be used;by software or other filing systems or ROMs**************************************************************************                                                                       **       OSBYTE &9D    FAST BPUT                                         **                                                                       **************************************************************************FFA7	TXA         ;A=XFFA8	BCS &FFD4   ;carry always set, jump to BPUT**************************************************************************                                                                       **       OSBYTE &92      READ A BYTE FROM FRED                           **                                                                       **************************************************************************       ;FFAA	LDY &FC00,X ;read a byte from FRED areaFFAD	RTS         ;return**************************************************************************                                                                       **       OSBYTE &94      READ A BYTE FROM JIM                            **                                                                       **************************************************************************       ;    	;FFAE	LDY &FD00,X ;read a byte from JIM areaFFB1	RTS         ;return**************************************************************************                                                                       **       OSBYTE &96      READ A BYTE FROM SHEILA                         **                                                                       **************************************************************************       ;    	;FFB2	LDY &FE00,X ;read a byte from SHEILA memory mapped I/O areaFFB5	RTS         ;return*********** DEFAULT VECTOR TABLE ****************************************FFB6	DB  36      ;length of look up table in bytesFFB7	DB  40      ;low byte of address of this tableFFB8	DB  D9      ;high byte of address of this table******************************************************************************************************************************************************                                                                      ****      OPERATING SYSTEM FUNCTION CALLS                                 ****                                                                      ******************************************************************************************************************************************************FFB9	JMP &DC0B   ;OSRDRM get a byte from sideways ROMFFBC	JMP &C4C0   ;VDUCHR VDU character outputFFBF	JMP &E494   ;OSEVEN generate an EVENTFFC2	JMP &EA1E   ;GSINIT initialise OS stringFFC5	JMP &EA2F   ;GSREAD read character from input streamFFC8	JMP &DEC5   ;NVRDCH non vectored OSRDCHFFCB	JMP &E0A4   ;NVWRCH non vectored OSWRCHFFCE	JMP (&021C) ;OSFIND open or close a fileFFD1	JMP (&021A) ;OSGBPB transfer block to or from a fileFFD4	JMP (&0218) ;OSBPUT save a byte to fileFFD7	JMP (&0216) ;OSBGET get a byte from fileFFDA	JMP (&0214) ;OSARGS read or write file argumentsFFDD	JMP (&0212) ;OSFILE read or write a fileFFE0	JMP (&0210) ;OSRDCH get a byte from current input streamFFE3	CMP #&0D    ;OSASCI output a byte to VDU stream expandingFFE5	BNE &FFEE   ; carriage returns (&0D) to LF/CR (&0A,&0D)FFE7	LDA #&0A    ;OSNEWL output a CR/LF to VDU streamFFE9	JSR OSWRCH  ;Outputs A followed by CR to VDU streamFFEC	LDA #&0D    ;OSWRCR output a CR to VDU streamFFEE	JMP (&020E) ;OSWRCH output a character to the VDU streamFFF1	JMP (&020C) ;OSWORD perform operation using parameter tableFFF4	JMP (&020A) ;OSBYTE perform operation with single bytesFFF7	JMP (&0208) ;OSCLI  pass string to command line interpreter**************************************************************************                                                                       **       6502 Vectors                                                    **                                                                       **************************************************************************FFFA	DW  &0D00   ;NMI   addressFFFC	DW  &D9CD   ;RESET addressFFFE	DW  &DC1C   ;IRQ   addressThat's it the end of the series and the end of Micronet.See you on the new system or in the paper mags.Geoff